{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Python SDK","text":"<p>A Python implementation of the Model Context Protocol (MCP) that enables applications to provide context for LLMs in a standardized way.</p>"},{"location":"#examples","title":"Examples","text":"<p>The Examples section provides working code examples covering many aspects of MCP development. Each code example in these documents corresponds to an example .py file in the examples/ directory in the repository.</p> <ul> <li>Getting started: Quick introduction to FastMCP and basic server patterns</li> <li>Server development: Tools, resources, prompts, and structured output examples</li> <li>Transport protocols: HTTP and streamable transport implementations</li> <li>Low-level servers: Advanced patterns using the low-level server API</li> <li>Authentication: OAuth 2.1 server and client implementations</li> <li>Client development: Complete client examples with various connection types</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation is auto-generated from the source code and available in the API Reference section.</p>"},{"location":"#code-example-index","title":"Code example index","text":""},{"location":"#servers","title":"Servers","text":"File Transport Resources Prompts Tools Completions Sampling Elicitation Progress Logging Authentication Configuration Complex input handling stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Desktop integration stdio \u2705 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Enhanced echo server stdio \u2705 \u2705 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Memory and state management stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Parameter descriptions stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Basic server stdio \u2705 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Screenshot tools stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Simple echo server stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Text messaging tool stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 Unicode and internationalization stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Weather service with structured output stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Complete authentication server streamable-http \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 \u2014 Legacy Authorization Server streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 \u2705 Resource server with introspection streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 \u2705 Simple prompt server stdio \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Simple resource server stdio \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Stateless HTTP server streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2705 \u2014 \u2705 Stateful HTTP server streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2705 \u2014 \u2705 Simple tool server stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Low-level structured output stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Basic prompts stdio \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Basic resources stdio \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 Basic tools stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Completion support stdio \u2705 \u2705 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Direct execution stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 User interaction and elicitation stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 FastMCP quickstart stdio \u2705 \u2705 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Image handling stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Lifespan management stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 Basic low-level server stdio \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Low-level server with lifespan stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 Low-level structured output stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Logging and notifications stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2705 \u2014 \u2014 OAuth server implementation streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 \u2014 LLM sampling and integration stdio \u2014 \u2014 \u2705 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 Streamable HTTP configuration streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 Mounting multiple servers streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2705 FastMCP structured output stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 \u2014 Tools with context and progress reporting stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 \u2705 \u2705 \u2014 \u2014"},{"location":"#clients","title":"Clients","text":"File Transport Resources Prompts Tools Completions Sampling Authentication Authentication client streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2705 Complete chatbot client stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 Completion client stdio \u2705 \u2705 \u2014 \u2705 \u2014 \u2014 Display utilities stdio \u2705 \u2014 \u2705 \u2014 \u2014 \u2014 OAuth authentication client streamable-http \u2705 \u2014 \u2705 \u2014 \u2014 \u2705 Tool result parsing stdio \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 Basic stdio client stdio \u2705 \u2705 \u2705 \u2014 \u2705 \u2014 Streamable HTTP client streamable-http \u2014 \u2014 \u2705 \u2014 \u2014 \u2014 <p>Notes:</p> <ul> <li>Resources for clients indicates the example uses the Resources API (reading resources or listing resource templates).</li> <li>Completions refers to the completion/complete API for argument autocompletion.</li> <li>Sampling indicates the example exercises the sampling/createMessage flow (server-initiated in server examples; client-provided callback in stdio_client).</li> <li>Authentication indicates OAuth support is implemented in the example.</li> <li>Em dash (\u2014) indicates not demonstrated in the example.</li> </ul>"},{"location":"examples-authentication/","title":"Authentication examples","text":"<p>MCP supports OAuth 2.1 authentication for protecting server resources. This section demonstrates both server-side token verification and client-side authentication flows.</p>"},{"location":"examples-authentication/#security-considerations","title":"Security considerations","text":"<p>When implementing authentication:</p> <ul> <li>Use HTTPS: All OAuth flows must use HTTPS in production</li> <li>Token validation: Always validate tokens on the resource server side</li> <li>Scope checking: Verify that tokens have required scopes</li> <li>Introspection: Use token introspection for distributed validation</li> <li>RFC compliance: Follow RFC 9728 for proper authoriazation server (AS) discovery</li> </ul>"},{"location":"examples-authentication/#oauth-architecture","title":"OAuth architecture","text":"<p>The MCP OAuth implementation follows the OAuth 2.1 authorization code flow with token introspection:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant AS as Authorization Server\n    participant RS as Resource Server&lt;br/&gt;(MCP Server)\n    participant U as User\n\n    Note over C,RS: 1. Discovery Phase (RFC 9728)\n    C-&gt;&gt;RS: GET /.well-known/oauth-protected-resource\n    RS-&gt;&gt;C: Protected Resource Metadata&lt;br/&gt;(issuer, scopes, etc.)\n\n    Note over C,AS: 2. Authorization Phase\n    C-&gt;&gt;AS: GET /authorize?response_type=code&amp;client_id=...\n    AS-&gt;&gt;U: Redirect to login/consent\n    U-&gt;&gt;AS: User authenticates and consents\n    AS-&gt;&gt;C: Authorization code (via redirect)\n\n    Note over C,AS: 3. Token Exchange\n    C-&gt;&gt;AS: POST /token&lt;br/&gt;(authorization_code grant)\n    AS-&gt;&gt;C: Access token + refresh token\n\n    Note over C,RS: 4. Resource Access\n    C-&gt;&gt;RS: MCP request + Authorization: Bearer &lt;token&gt;\n    RS-&gt;&gt;AS: POST /introspect&lt;br/&gt;(validate token)\n    AS-&gt;&gt;RS: Token info (active, scopes, user)\n    RS-&gt;&gt;C: MCP response (if authorized)\n\n    Note over C,AS: 5. Token Refresh (when needed)\n    C-&gt;&gt;AS: POST /token&lt;br/&gt;(refresh_token grant)\n    AS-&gt;&gt;C: New access token</code></pre> <p>Components:</p> <ul> <li>Authorization Server (AS): Handles OAuth flows, issues and validates tokens</li> <li>Resource Server (RS): Your MCP server that validates tokens and serves protected resources</li> <li>Client: Discovers AS through RFC 9728, obtains tokens, and uses them with MCP server</li> <li>User: Resource owner who authorizes access</li> </ul>"},{"location":"examples-authentication/#oauth-server-implementation","title":"OAuth server implementation","text":"<p>FastMCP server with OAuth token verification:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/oauth_server.py\n\"\"\"\n\nfrom pydantic import AnyHttpUrl\n\nfrom mcp.server.auth.provider import AccessToken, TokenVerifier\nfrom mcp.server.auth.settings import AuthSettings\nfrom mcp.server.fastmcp import FastMCP\n\n\nclass SimpleTokenVerifier(TokenVerifier):\n    \"\"\"Simple token verifier for demonstration.\"\"\"\n\n    async def verify_token(self, token: str) -&gt; AccessToken | None:\n        pass  # This is where you would implement actual token validation\n\n\n# Create FastMCP instance as a Resource Server\nmcp = FastMCP(\n    \"Weather Service\",\n    # Token verifier for authentication\n    token_verifier=SimpleTokenVerifier(),\n    # Auth settings for RFC 9728 Protected Resource Metadata\n    auth=AuthSettings(\n        issuer_url=AnyHttpUrl(\"https://auth.example.com\"),  # Authorization Server URL\n        resource_server_url=AnyHttpUrl(\"http://localhost:3001\"),  # This server's URL\n        required_scopes=[\"user\"],\n    ),\n)\n\n\n@mcp.tool()\nasync def get_weather(city: str = \"London\") -&gt; dict[str, str]:\n    \"\"\"Get weather data for a city\"\"\"\n    return {\n        \"city\": city,\n        \"temperature\": \"22\",\n        \"condition\": \"Partly cloudy\",\n        \"humidity\": \"65%\",\n    }\n\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre> <p>This example shows:</p> <ul> <li>Implementing the <code>TokenVerifier</code> protocol for token validation</li> <li>Using <code>AuthSettings</code> for RFC 9728 Protected Resource Metadata</li> <li>Resource server configuration with authorization server discovery</li> <li>Protected tools that require authentication</li> </ul>"},{"location":"examples-authentication/#complete-authentication-server","title":"Complete authentication server","text":"<p>Full Authorization Server implementation with token introspection:</p> <pre><code>\"\"\"\nAuthorization Server for MCP Split Demo.\n\nThis server handles OAuth flows, client registration, and token issuance.\nCan be replaced with enterprise authorization servers like Auth0, Entra ID, etc.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\n\nimport click\nfrom pydantic import AnyHttpUrl, BaseModel\nfrom starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import Route\nfrom uvicorn import Config, Server\n\nfrom mcp.server.auth.routes import cors_middleware, create_auth_routes\nfrom mcp.server.auth.settings import AuthSettings, ClientRegistrationOptions\n\nfrom .simple_auth_provider import SimpleAuthSettings, SimpleOAuthProvider\n\nlogger = logging.getLogger(__name__)\n\n\nclass AuthServerSettings(BaseModel):\n    \"\"\"Settings for the Authorization Server.\"\"\"\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 9000\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:9000\")\n    auth_callback_path: str = \"http://localhost:9000/login/callback\"\n\n\nclass SimpleAuthProvider(SimpleOAuthProvider):\n    \"\"\"\n    Authorization Server provider with simple demo authentication.\n\n    This provider:\n    1. Issues MCP tokens after simple credential authentication\n    2. Stores token state for introspection by Resource Servers\n    \"\"\"\n\n    def __init__(self, auth_settings: SimpleAuthSettings, auth_callback_path: str, server_url: str):\n        super().__init__(auth_settings, auth_callback_path, server_url)\n\n\ndef create_authorization_server(server_settings: AuthServerSettings, auth_settings: SimpleAuthSettings) -&gt; Starlette:\n    \"\"\"Create the Authorization Server application.\"\"\"\n    oauth_provider = SimpleAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n    mcp_auth_settings = AuthSettings(\n        issuer_url=server_settings.server_url,\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[auth_settings.mcp_scope],\n            default_scopes=[auth_settings.mcp_scope],\n        ),\n        required_scopes=[auth_settings.mcp_scope],\n        resource_server_url=None,\n    )\n\n    # Create OAuth routes\n    routes = create_auth_routes(\n        provider=oauth_provider,\n        issuer_url=mcp_auth_settings.issuer_url,\n        service_documentation_url=mcp_auth_settings.service_documentation_url,\n        client_registration_options=mcp_auth_settings.client_registration_options,\n        revocation_options=mcp_auth_settings.revocation_options,\n    )\n\n    # Add login page route (GET)\n    async def login_page_handler(request: Request) -&gt; Response:\n        \"\"\"Show login form.\"\"\"\n        state = request.query_params.get(\"state\")\n        if not state:\n            raise HTTPException(400, \"Missing state parameter\")\n        return await oauth_provider.get_login_page(state)\n\n    routes.append(Route(\"/login\", endpoint=login_page_handler, methods=[\"GET\"]))\n\n    # Add login callback route (POST)\n    async def login_callback_handler(request: Request) -&gt; Response:\n        \"\"\"Handle simple authentication callback.\"\"\"\n        return await oauth_provider.handle_login_callback(request)\n\n    routes.append(Route(\"/login/callback\", endpoint=login_callback_handler, methods=[\"POST\"]))\n\n    # Add token introspection endpoint (RFC 7662) for Resource Servers\n    async def introspect_handler(request: Request) -&gt; Response:\n        \"\"\"\n        Token introspection endpoint for Resource Servers.\n\n        Resource Servers call this endpoint to validate tokens without\n        needing direct access to token storage.\n        \"\"\"\n        form = await request.form()\n        token = form.get(\"token\")\n        if not token or not isinstance(token, str):\n            return JSONResponse({\"active\": False}, status_code=400)\n\n        # Look up token in provider\n        access_token = await oauth_provider.load_access_token(token)\n        if not access_token:\n            return JSONResponse({\"active\": False})\n\n        return JSONResponse(\n            {\n                \"active\": True,\n                \"client_id\": access_token.client_id,\n                \"scope\": \" \".join(access_token.scopes),\n                \"exp\": access_token.expires_at,\n                \"iat\": int(time.time()),\n                \"token_type\": \"Bearer\",\n                \"aud\": access_token.resource,  # RFC 8707 audience claim\n            }\n        )\n\n    routes.append(\n        Route(\n            \"/introspect\",\n            endpoint=cors_middleware(introspect_handler, [\"POST\", \"OPTIONS\"]),\n            methods=[\"POST\", \"OPTIONS\"],\n        )\n    )\n\n    return Starlette(routes=routes)\n\n\nasync def run_server(server_settings: AuthServerSettings, auth_settings: SimpleAuthSettings):\n    \"\"\"Run the Authorization Server.\"\"\"\n    auth_server = create_authorization_server(server_settings, auth_settings)\n\n    config = Config(\n        auth_server,\n        host=server_settings.host,\n        port=server_settings.port,\n        log_level=\"info\",\n    )\n    server = Server(config)\n\n    logger.info(f\"\ud83d\ude80 MCP Authorization Server running on {server_settings.server_url}\")\n\n    await server.serve()\n\n\n@click.command()\n@click.option(\"--port\", default=9000, help=\"Port to listen on\")\ndef main(port: int) -&gt; int:\n    \"\"\"\n    Run the MCP Authorization Server.\n\n    This server handles OAuth flows and can be used by multiple Resource Servers.\n\n    Uses simple hardcoded credentials for demo purposes.\n    \"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    # Load simple auth settings\n    auth_settings = SimpleAuthSettings()\n\n    # Create server settings\n    host = \"localhost\"\n    server_url = f\"http://{host}:{port}\"\n    server_settings = AuthServerSettings(\n        host=host,\n        port=port,\n        server_url=AnyHttpUrl(server_url),\n        auth_callback_path=f\"{server_url}/login\",\n    )\n\n    asyncio.run(run_server(server_settings, auth_settings))\n    return 0\n\n\nif __name__ == \"__main__\":\n    main()  # type: ignore[call-arg]\n</code></pre> <p>This comprehensive example includes:</p> <ul> <li>OAuth 2.1 authorization flows (authorization code, refresh token)</li> <li>Token introspection endpoint for resource servers</li> <li>Client registration and metadata management</li> <li>RFC 9728 protected resource metadata endpoint</li> </ul>"},{"location":"examples-authentication/#resource-server-with-introspection","title":"Resource server with introspection","text":"<p>MCP Resource Server that validates tokens via Authorization Server introspection:</p> <pre><code>\"\"\"\nMCP Resource Server with Token Introspection.\n\nThis server validates tokens via Authorization Server introspection and serves MCP resources.\nDemonstrates RFC 9728 Protected Resource Metadata for AS/RS separation.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\"\"\"\n\nimport datetime\nimport logging\nfrom typing import Any, Literal\n\nimport click\nfrom pydantic import AnyHttpUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nfrom mcp.server.auth.settings import AuthSettings\nfrom mcp.server.fastmcp.server import FastMCP\n\nfrom .token_verifier import IntrospectionTokenVerifier\n\nlogger = logging.getLogger(__name__)\n\n\nclass ResourceServerSettings(BaseSettings):\n    \"\"\"Settings for the MCP Resource Server.\"\"\"\n\n    model_config = SettingsConfigDict(env_prefix=\"MCP_RESOURCE_\")\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 8001\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:8001\")\n\n    # Authorization Server settings\n    auth_server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:9000\")\n    auth_server_introspection_endpoint: str = \"http://localhost:9000/introspect\"\n    # No user endpoint needed - we get user data from token introspection\n\n    # MCP settings\n    mcp_scope: str = \"user\"\n\n    # RFC 8707 resource validation\n    oauth_strict: bool = False\n\n    # TODO(Marcelo): Is this even needed? I didn't have time to check.\n    def __init__(self, **data: Any):\n        \"\"\"Initialize settings with values from environment variables.\"\"\"\n        super().__init__(**data)\n\n\ndef create_resource_server(settings: ResourceServerSettings) -&gt; FastMCP:\n    \"\"\"\n    Create MCP Resource Server with token introspection.\n\n    This server:\n    1. Provides protected resource metadata (RFC 9728)\n    2. Validates tokens via Authorization Server introspection\n    3. Serves MCP tools and resources\n    \"\"\"\n    # Create token verifier for introspection with RFC 8707 resource validation\n    token_verifier = IntrospectionTokenVerifier(\n        introspection_endpoint=settings.auth_server_introspection_endpoint,\n        server_url=str(settings.server_url),\n        validate_resource=settings.oauth_strict,  # Only validate when --oauth-strict is set\n    )\n\n    # Create FastMCP server as a Resource Server\n    app = FastMCP(\n        name=\"MCP Resource Server\",\n        instructions=\"Resource Server that validates tokens via Authorization Server introspection\",\n        host=settings.host,\n        port=settings.port,\n        debug=True,\n        # Auth configuration for RS mode\n        token_verifier=token_verifier,\n        auth=AuthSettings(\n            issuer_url=settings.auth_server_url,\n            required_scopes=[settings.mcp_scope],\n            resource_server_url=settings.server_url,\n        ),\n    )\n\n    @app.tool()\n    async def get_time() -&gt; dict[str, Any]:\n        \"\"\"\n        Get the current server time.\n\n        This tool demonstrates that system information can be protected\n        by OAuth authentication. User must be authenticated to access it.\n        \"\"\"\n\n        now = datetime.datetime.now()\n\n        return {\n            \"current_time\": now.isoformat(),\n            \"timezone\": \"UTC\",  # Simplified for demo\n            \"timestamp\": now.timestamp(),\n            \"formatted\": now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        }\n\n    return app\n\n\n@click.command()\n@click.option(\"--port\", default=8001, help=\"Port to listen on\")\n@click.option(\"--auth-server\", default=\"http://localhost:9000\", help=\"Authorization Server URL\")\n@click.option(\n    \"--transport\",\n    default=\"streamable-http\",\n    type=click.Choice([\"sse\", \"streamable-http\"]),\n    help=\"Transport protocol to use ('sse' or 'streamable-http')\",\n)\n@click.option(\n    \"--oauth-strict\",\n    is_flag=True,\n    help=\"Enable RFC 8707 resource validation\",\n)\ndef main(port: int, auth_server: str, transport: Literal[\"sse\", \"streamable-http\"], oauth_strict: bool) -&gt; int:\n    \"\"\"\n    Run the MCP Resource Server.\n\n    This server:\n    - Provides RFC 9728 Protected Resource Metadata\n    - Validates tokens via Authorization Server introspection\n    - Serves MCP tools requiring authentication\n\n    Must be used with a running Authorization Server.\n    \"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    try:\n        # Parse auth server URL\n        auth_server_url = AnyHttpUrl(auth_server)\n\n        # Create settings\n        host = \"localhost\"\n        server_url = f\"http://{host}:{port}\"\n        settings = ResourceServerSettings(\n            host=host,\n            port=port,\n            server_url=AnyHttpUrl(server_url),\n            auth_server_url=auth_server_url,\n            auth_server_introspection_endpoint=f\"{auth_server}/introspect\",\n            oauth_strict=oauth_strict,\n        )\n    except ValueError as e:\n        logger.error(f\"Configuration error: {e}\")\n        logger.error(\"Make sure to provide a valid Authorization Server URL\")\n        return 1\n\n    try:\n        mcp_server = create_resource_server(settings)\n\n        logger.info(f\"\ud83d\ude80 MCP Resource Server running on {settings.server_url}\")\n        logger.info(f\"\ud83d\udd11 Using Authorization Server: {settings.auth_server_url}\")\n\n        # Run the server - this should block and keep running\n        mcp_server.run(transport=transport)\n        logger.info(\"Server stopped\")\n        return 0\n    except Exception:\n        logger.exception(\"Server error\")\n        return 1\n\n\nif __name__ == \"__main__\":\n    main()  # type: ignore[call-arg]\n</code></pre> <p>This demonstrates:</p> <ul> <li>Token introspection for validation instead of local token verification</li> <li>Separation of Authorization Server (AS) and Resource Server (RS)</li> <li>Protected MCP tools and resources</li> <li>Production-ready server patterns</li> </ul>"},{"location":"examples-authentication/#token-verification-implementation","title":"Token verification implementation","text":"<p>Custom token verification logic:</p> <pre><code>\"\"\"Example token verifier implementation using OAuth 2.0 Token Introspection (RFC 7662).\"\"\"\n\nimport logging\nfrom typing import Any\n\nfrom mcp.server.auth.provider import AccessToken, TokenVerifier\nfrom mcp.shared.auth_utils import check_resource_allowed, resource_url_from_server_url\n\nlogger = logging.getLogger(__name__)\n\n\nclass IntrospectionTokenVerifier(TokenVerifier):\n    \"\"\"Example token verifier that uses OAuth 2.0 Token Introspection (RFC 7662).\n\n    This is a simple example implementation for demonstration purposes.\n    Production implementations should consider:\n    - Connection pooling and reuse\n    - More sophisticated error handling\n    - Rate limiting and retry logic\n    - Comprehensive configuration options\n    \"\"\"\n\n    def __init__(\n        self,\n        introspection_endpoint: str,\n        server_url: str,\n        validate_resource: bool = False,\n    ):\n        self.introspection_endpoint = introspection_endpoint\n        self.server_url = server_url\n        self.validate_resource = validate_resource\n        self.resource_url = resource_url_from_server_url(server_url)\n\n    async def verify_token(self, token: str) -&gt; AccessToken | None:\n        \"\"\"Verify token via introspection endpoint.\"\"\"\n        import httpx\n\n        # Validate URL to prevent SSRF attacks\n        if not self.introspection_endpoint.startswith((\"https://\", \"http://localhost\", \"http://127.0.0.1\")):\n            logger.warning(f\"Rejecting introspection endpoint with unsafe scheme: {self.introspection_endpoint}\")\n            return None\n\n        # Configure secure HTTP client\n        timeout = httpx.Timeout(10.0, connect=5.0)\n        limits = httpx.Limits(max_connections=10, max_keepalive_connections=5)\n\n        async with httpx.AsyncClient(\n            timeout=timeout,\n            limits=limits,\n            verify=True,  # Enforce SSL verification\n        ) as client:\n            try:\n                response = await client.post(\n                    self.introspection_endpoint,\n                    data={\"token\": token},\n                    headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n                )\n\n                if response.status_code != 200:\n                    logger.debug(f\"Token introspection returned status {response.status_code}\")\n                    return None\n\n                data = response.json()\n                if not data.get(\"active\", False):\n                    return None\n\n                # RFC 8707 resource validation (only when --oauth-strict is set)\n                if self.validate_resource and not self._validate_resource(data):\n                    logger.warning(f\"Token resource validation failed. Expected: {self.resource_url}\")\n                    return None\n\n                return AccessToken(\n                    token=token,\n                    client_id=data.get(\"client_id\", \"unknown\"),\n                    scopes=data.get(\"scope\", \"\").split() if data.get(\"scope\") else [],\n                    expires_at=data.get(\"exp\"),\n                    resource=data.get(\"aud\"),  # Include resource in token\n                )\n            except Exception as e:\n                logger.warning(f\"Token introspection failed: {e}\")\n                return None\n\n    def _validate_resource(self, token_data: dict[str, Any]) -&gt; bool:\n        \"\"\"Validate token was issued for this resource server.\"\"\"\n        if not self.server_url or not self.resource_url:\n            return False  # Fail if strict validation requested but URLs missing\n\n        # Check 'aud' claim first (standard JWT audience)\n        aud: list[str] | str | None = token_data.get(\"aud\")\n        if isinstance(aud, list):\n            for audience in aud:\n                if self._is_valid_resource(audience):\n                    return True\n            return False\n        elif aud:\n            return self._is_valid_resource(aud)\n\n        # No resource binding - invalid per RFC 8707\n        return False\n\n    def _is_valid_resource(self, resource: str) -&gt; bool:\n        \"\"\"Check if resource matches this server using hierarchical matching.\"\"\"\n        if not self.resource_url:\n            return False\n\n        return check_resource_allowed(requested_resource=self.resource_url, configured_resource=resource)\n</code></pre> <p>This component handles:</p> <ul> <li>HTTP token introspection requests</li> <li>Token validation with scope checking</li> <li>RFC 8707 resource parameter validation</li> <li>Error handling and logging</li> </ul>"},{"location":"examples-authentication/#simple-authentication-provider","title":"Simple authentication provider","text":"<p>Authentication provider for development and testing:</p> <pre><code>\"\"\"\nSimple OAuth provider for MCP servers.\n\nThis module contains a basic OAuth implementation using hardcoded user credentials\nfor demonstration purposes. No external authentication provider is required.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport logging\nimport secrets\nimport time\nfrom typing import Any\n\nfrom pydantic import AnyHttpUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, RedirectResponse, Response\n\nfrom mcp.server.auth.provider import (\n    AccessToken,\n    AuthorizationCode,\n    AuthorizationParams,\n    OAuthAuthorizationServerProvider,\n    RefreshToken,\n    construct_redirect_uri,\n)\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthToken\n\nlogger = logging.getLogger(__name__)\n\n\nclass SimpleAuthSettings(BaseSettings):\n    \"\"\"Simple OAuth settings for demo purposes.\"\"\"\n\n    model_config = SettingsConfigDict(env_prefix=\"MCP_\")\n\n    # Demo user credentials\n    demo_username: str = \"demo_user\"\n    demo_password: str = \"demo_password\"\n\n    # MCP OAuth scope\n    mcp_scope: str = \"user\"\n\n\nclass SimpleOAuthProvider(OAuthAuthorizationServerProvider[AuthorizationCode, RefreshToken, AccessToken]):\n    \"\"\"\n    Simple OAuth provider for demo purposes.\n\n    This provider handles the OAuth flow by:\n    1. Providing a simple login form for demo credentials\n    2. Issuing MCP tokens after successful authentication\n    3. Maintaining token state for introspection\n    \"\"\"\n\n    def __init__(self, settings: SimpleAuthSettings, auth_callback_url: str, server_url: str):\n        self.settings = settings\n        self.auth_callback_url = auth_callback_url\n        self.server_url = server_url\n        self.clients: dict[str, OAuthClientInformationFull] = {}\n        self.auth_codes: dict[str, AuthorizationCode] = {}\n        self.tokens: dict[str, AccessToken] = {}\n        self.state_mapping: dict[str, dict[str, str | None]] = {}\n        # Store authenticated user information\n        self.user_data: dict[str, dict[str, Any]] = {}\n\n    async def get_client(self, client_id: str) -&gt; OAuthClientInformationFull | None:\n        \"\"\"Get OAuth client information.\"\"\"\n        return self.clients.get(client_id)\n\n    async def register_client(self, client_info: OAuthClientInformationFull):\n        \"\"\"Register a new OAuth client.\"\"\"\n        self.clients[client_info.client_id] = client_info\n\n    async def authorize(self, client: OAuthClientInformationFull, params: AuthorizationParams) -&gt; str:\n        \"\"\"Generate an authorization URL for simple login flow.\"\"\"\n        state = params.state or secrets.token_hex(16)\n\n        # Store state mapping for callback\n        self.state_mapping[state] = {\n            \"redirect_uri\": str(params.redirect_uri),\n            \"code_challenge\": params.code_challenge,\n            \"redirect_uri_provided_explicitly\": str(params.redirect_uri_provided_explicitly),\n            \"client_id\": client.client_id,\n            \"resource\": params.resource,  # RFC 8707\n        }\n\n        # Build simple login URL that points to login page\n        auth_url = f\"{self.auth_callback_url}?state={state}&amp;client_id={client.client_id}\"\n\n        return auth_url\n\n    async def get_login_page(self, state: str) -&gt; HTMLResponse:\n        \"\"\"Generate login page HTML for the given state.\"\"\"\n        if not state:\n            raise HTTPException(400, \"Missing state parameter\")\n\n        # Create simple login form HTML\n        html_content = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;MCP Demo Authentication&lt;/title&gt;\n            &lt;style&gt;\n                body {{ font-family: Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; }}\n                .form-group {{ margin-bottom: 15px; }}\n                input {{ width: 100%; padding: 8px; margin-top: 5px; }}\n                button {{ background-color: #4CAF50; color: white; padding: 10px 15px; border: none; cursor: pointer; }}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h2&gt;MCP Demo Authentication&lt;/h2&gt;\n            &lt;p&gt;This is a simplified authentication demo. Use the demo credentials below:&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Username:&lt;/strong&gt; demo_user&lt;br&gt;\n            &lt;strong&gt;Password:&lt;/strong&gt; demo_password&lt;/p&gt;\n\n            &lt;form action=\"{self.server_url.rstrip(\"/\")}/login/callback\" method=\"post\"&gt;\n                &lt;input type=\"hidden\" name=\"state\" value=\"{state}\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;Username:&lt;/label&gt;\n                    &lt;input type=\"text\" name=\"username\" value=\"demo_user\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;Password:&lt;/label&gt;\n                    &lt;input type=\"password\" name=\"password\" value=\"demo_password\" required&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Sign In&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return HTMLResponse(content=html_content)\n\n    async def handle_login_callback(self, request: Request) -&gt; Response:\n        \"\"\"Handle login form submission callback.\"\"\"\n        form = await request.form()\n        username = form.get(\"username\")\n        password = form.get(\"password\")\n        state = form.get(\"state\")\n\n        if not username or not password or not state:\n            raise HTTPException(400, \"Missing username, password, or state parameter\")\n\n        # Ensure we have strings, not UploadFile objects\n        if not isinstance(username, str) or not isinstance(password, str) or not isinstance(state, str):\n            raise HTTPException(400, \"Invalid parameter types\")\n\n        redirect_uri = await self.handle_simple_callback(username, password, state)\n        return RedirectResponse(url=redirect_uri, status_code=302)\n\n    async def handle_simple_callback(self, username: str, password: str, state: str) -&gt; str:\n        \"\"\"Handle simple authentication callback and return redirect URI.\"\"\"\n        state_data = self.state_mapping.get(state)\n        if not state_data:\n            raise HTTPException(400, \"Invalid state parameter\")\n\n        redirect_uri = state_data[\"redirect_uri\"]\n        code_challenge = state_data[\"code_challenge\"]\n        redirect_uri_provided_explicitly = state_data[\"redirect_uri_provided_explicitly\"] == \"True\"\n        client_id = state_data[\"client_id\"]\n        resource = state_data.get(\"resource\")  # RFC 8707\n\n        # These are required values from our own state mapping\n        assert redirect_uri is not None\n        assert code_challenge is not None\n        assert client_id is not None\n\n        # Validate demo credentials\n        if username != self.settings.demo_username or password != self.settings.demo_password:\n            raise HTTPException(401, \"Invalid credentials\")\n\n        # Create MCP authorization code\n        new_code = f\"mcp_{secrets.token_hex(16)}\"\n        auth_code = AuthorizationCode(\n            code=new_code,\n            client_id=client_id,\n            redirect_uri=AnyHttpUrl(redirect_uri),\n            redirect_uri_provided_explicitly=redirect_uri_provided_explicitly,\n            expires_at=time.time() + 300,\n            scopes=[self.settings.mcp_scope],\n            code_challenge=code_challenge,\n            resource=resource,  # RFC 8707\n        )\n        self.auth_codes[new_code] = auth_code\n\n        # Store user data\n        self.user_data[username] = {\n            \"username\": username,\n            \"user_id\": f\"user_{secrets.token_hex(8)}\",\n            \"authenticated_at\": time.time(),\n        }\n\n        del self.state_mapping[state]\n        return construct_redirect_uri(redirect_uri, code=new_code, state=state)\n\n    async def load_authorization_code(\n        self, client: OAuthClientInformationFull, authorization_code: str\n    ) -&gt; AuthorizationCode | None:\n        \"\"\"Load an authorization code.\"\"\"\n        return self.auth_codes.get(authorization_code)\n\n    async def exchange_authorization_code(\n        self, client: OAuthClientInformationFull, authorization_code: AuthorizationCode\n    ) -&gt; OAuthToken:\n        \"\"\"Exchange authorization code for tokens.\"\"\"\n        if authorization_code.code not in self.auth_codes:\n            raise ValueError(\"Invalid authorization code\")\n\n        # Generate MCP access token\n        mcp_token = f\"mcp_{secrets.token_hex(32)}\"\n\n        # Store MCP token\n        self.tokens[mcp_token] = AccessToken(\n            token=mcp_token,\n            client_id=client.client_id,\n            scopes=authorization_code.scopes,\n            expires_at=int(time.time()) + 3600,\n            resource=authorization_code.resource,  # RFC 8707\n        )\n\n        # Store user data mapping for this token\n        self.user_data[mcp_token] = {\n            \"username\": self.settings.demo_username,\n            \"user_id\": f\"user_{secrets.token_hex(8)}\",\n            \"authenticated_at\": time.time(),\n        }\n\n        del self.auth_codes[authorization_code.code]\n\n        return OAuthToken(\n            access_token=mcp_token,\n            token_type=\"Bearer\",\n            expires_in=3600,\n            scope=\" \".join(authorization_code.scopes),\n        )\n\n    async def load_access_token(self, token: str) -&gt; AccessToken | None:\n        \"\"\"Load and validate an access token.\"\"\"\n        access_token = self.tokens.get(token)\n        if not access_token:\n            return None\n\n        # Check if expired\n        if access_token.expires_at and access_token.expires_at &lt; time.time():\n            del self.tokens[token]\n            return None\n\n        return access_token\n\n    async def load_refresh_token(self, client: OAuthClientInformationFull, refresh_token: str) -&gt; RefreshToken | None:\n        \"\"\"Load a refresh token - not supported in this example.\"\"\"\n        return None\n\n    async def exchange_refresh_token(\n        self,\n        client: OAuthClientInformationFull,\n        refresh_token: RefreshToken,\n        scopes: list[str],\n    ) -&gt; OAuthToken:\n        \"\"\"Exchange refresh token - not supported in this example.\"\"\"\n        raise NotImplementedError(\"Refresh tokens not supported\")\n\n    # TODO(Marcelo): The type hint is wrong. We need to fix, and test to check if it works.\n    async def revoke_token(self, token: str, token_type_hint: str | None = None) -&gt; None:  # type: ignore\n        \"\"\"Revoke a token.\"\"\"\n        if token in self.tokens:\n            del self.tokens[token]\n</code></pre> <p>This utility provides:</p> <ul> <li>Simplified token generation for testing</li> <li>Development authentication flows</li> <li>Testing utilities for protected resources</li> </ul>"},{"location":"examples-authentication/#legacy-authorization-server","title":"Legacy Authorization Server","text":"<p>Backward compatibility with older OAuth implementations:</p> <pre><code>\"\"\"\nLegacy Combined Authorization Server + Resource Server for MCP.\n\nThis server implements the old spec where MCP servers could act as both AS and RS.\nUsed for backwards compatibility testing with the new split AS/RS architecture.\n\nNOTE: this is a simplified example for demonstration purposes.\nThis is not a production-ready implementation.\n\n\"\"\"\n\nimport datetime\nimport logging\nfrom typing import Any, Literal\n\nimport click\nfrom pydantic import AnyHttpUrl, BaseModel\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom mcp.server.auth.settings import AuthSettings, ClientRegistrationOptions\nfrom mcp.server.fastmcp.server import FastMCP\n\nfrom .simple_auth_provider import SimpleAuthSettings, SimpleOAuthProvider\n\nlogger = logging.getLogger(__name__)\n\n\nclass ServerSettings(BaseModel):\n    \"\"\"Settings for the simple auth MCP server.\"\"\"\n\n    # Server settings\n    host: str = \"localhost\"\n    port: int = 8000\n    server_url: AnyHttpUrl = AnyHttpUrl(\"http://localhost:8000\")\n    auth_callback_path: str = \"http://localhost:8000/login/callback\"\n\n\nclass LegacySimpleOAuthProvider(SimpleOAuthProvider):\n    \"\"\"Simple OAuth provider for legacy MCP server.\"\"\"\n\n    def __init__(self, auth_settings: SimpleAuthSettings, auth_callback_path: str, server_url: str):\n        super().__init__(auth_settings, auth_callback_path, server_url)\n\n\ndef create_simple_mcp_server(server_settings: ServerSettings, auth_settings: SimpleAuthSettings) -&gt; FastMCP:\n    \"\"\"Create a simple FastMCP server with simple authentication.\"\"\"\n    oauth_provider = LegacySimpleOAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n    mcp_auth_settings = AuthSettings(\n        issuer_url=server_settings.server_url,\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[auth_settings.mcp_scope],\n            default_scopes=[auth_settings.mcp_scope],\n        ),\n        required_scopes=[auth_settings.mcp_scope],\n        # No resource_server_url parameter in legacy mode\n        resource_server_url=None,\n    )\n\n    app = FastMCP(\n        name=\"Simple Auth MCP Server\",\n        instructions=\"A simple MCP server with simple credential authentication\",\n        auth_server_provider=oauth_provider,\n        host=server_settings.host,\n        port=server_settings.port,\n        debug=True,\n        auth=mcp_auth_settings,\n    )\n\n    @app.custom_route(\"/login\", methods=[\"GET\"])\n    async def login_page_handler(request: Request) -&gt; Response:\n        \"\"\"Show login form.\"\"\"\n        state = request.query_params.get(\"state\")\n        if not state:\n            raise HTTPException(400, \"Missing state parameter\")\n        return await oauth_provider.get_login_page(state)\n\n    @app.custom_route(\"/login/callback\", methods=[\"POST\"])\n    async def login_callback_handler(request: Request) -&gt; Response:\n        \"\"\"Handle simple authentication callback.\"\"\"\n        return await oauth_provider.handle_login_callback(request)\n\n    @app.tool()\n    async def get_time() -&gt; dict[str, Any]:\n        \"\"\"\n        Get the current server time.\n\n        This tool demonstrates that system information can be protected\n        by OAuth authentication. User must be authenticated to access it.\n        \"\"\"\n\n        now = datetime.datetime.now()\n\n        return {\n            \"current_time\": now.isoformat(),\n            \"timezone\": \"UTC\",  # Simplified for demo\n            \"timestamp\": now.timestamp(),\n            \"formatted\": now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        }\n\n    return app\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on\")\n@click.option(\n    \"--transport\",\n    default=\"streamable-http\",\n    type=click.Choice([\"sse\", \"streamable-http\"]),\n    help=\"Transport protocol to use ('sse' or 'streamable-http')\",\n)\ndef main(port: int, transport: Literal[\"sse\", \"streamable-http\"]) -&gt; int:\n    \"\"\"Run the simple auth MCP server.\"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    auth_settings = SimpleAuthSettings()\n    # Create server settings\n    host = \"localhost\"\n    server_url = f\"http://{host}:{port}\"\n    server_settings = ServerSettings(\n        host=host,\n        port=port,\n        server_url=AnyHttpUrl(server_url),\n        auth_callback_path=f\"{server_url}/login\",\n    )\n\n    mcp_server = create_simple_mcp_server(server_settings, auth_settings)\n    logger.info(f\"\ud83d\ude80 MCP Legacy Server running on {server_url}\")\n    mcp_server.run(transport=transport)\n    return 0\n\n\nif __name__ == \"__main__\":\n    main()  # type: ignore[call-arg]\n</code></pre> <p>This example shows:</p> <ul> <li>Support for non-RFC 9728 compliant clients</li> <li>Legacy endpoint compatibility</li> <li>Migration patterns for existing systems</li> </ul>"},{"location":"examples-clients/","title":"Client examples","text":"<p>MCP clients connect to servers to access tools, resources, and prompts. This section demonstrates various client patterns and connection types.</p> <p>These examples provide comprehensive patterns for building MCP clients that can handle various server types, authentication methods, and interaction patterns.</p>"},{"location":"examples-clients/#basic-stdio-client","title":"Basic stdio client","text":"<p>Connecting to MCP servers over stdio transport:</p> <pre><code>\"\"\"\ncd to the `examples/snippets/clients` directory and run:\n    uv run client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom pydantic import AnyUrl\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\nfrom mcp.shared.context import RequestContext\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"fastmcp_quickstart\", \"stdio\"],  # We're already in snippets dir\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\n# Optional: create a sampling callback\nasync def handle_sampling_message(\n    context: RequestContext[ClientSession, None], params: types.CreateMessageRequestParams\n) -&gt; types.CreateMessageResult:\n    print(f\"Sampling request: {params.messages}\")\n    return types.CreateMessageResult(\n        role=\"assistant\",\n        content=types.TextContent(\n            type=\"text\",\n            text=\"Hello, world! from model\",\n        ),\n        model=\"gpt-3.5-turbo\",\n        stopReason=\"endTurn\",\n    )\n\n\nasync def run():\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write, sampling_callback=handle_sampling_message) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            # List available prompts\n            prompts = await session.list_prompts()\n            print(f\"Available prompts: {[p.name for p in prompts.prompts]}\")\n\n            # Get a prompt (greet_user prompt from fastmcp_quickstart)\n            if prompts.prompts:\n                prompt = await session.get_prompt(\"greet_user\", arguments={\"name\": \"Alice\", \"style\": \"friendly\"})\n                print(f\"Prompt result: {prompt.messages[0].content}\")\n\n            # List available resources\n            resources = await session.list_resources()\n            print(f\"Available resources: {[r.uri for r in resources.resources]}\")\n\n            # List available tools\n            tools = await session.list_tools()\n            print(f\"Available tools: {[t.name for t in tools.tools]}\")\n\n            # Read a resource (greeting resource from fastmcp_quickstart)\n            resource_content = await session.read_resource(AnyUrl(\"greeting://World\"))\n            content_block = resource_content.contents[0]\n            if isinstance(content_block, types.TextContent):\n                print(f\"Resource content: {content_block.text}\")\n\n            # Call a tool (add tool from fastmcp_quickstart)\n            result = await session.call_tool(\"add\", arguments={\"a\": 5, \"b\": 3})\n            result_unstructured = result.content[0]\n            if isinstance(result_unstructured, types.TextContent):\n                print(f\"Tool result: {result_unstructured.text}\")\n            result_structured = result.structuredContent\n            print(f\"Structured tool result: {result_structured}\")\n\n\ndef main():\n    \"\"\"Entry point for the client script.\"\"\"\n    asyncio.run(run())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This fundamental example demonstrates:</p> <ul> <li>Creating <code>StdioServerParameters</code> for server connection</li> <li>Using <code>ClientSession</code> for MCP communication</li> <li>Listing and calling tools, reading resources, getting prompts</li> <li>Handling both structured and unstructured tool results</li> <li>Sampling callback implementation for LLM integration</li> </ul>"},{"location":"examples-clients/#streamable-http-client","title":"Streamable HTTP client","text":"<p>Connecting to HTTP-based MCP servers:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/clients/streamable_basic.py\n\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\n\n\nasync def main():\n    # Connect to a streamable HTTP server\n    async with streamablehttp_client(\"http://localhost:8000/mcp\") as (\n        read_stream,\n        write_stream,\n        _,\n    ):\n        # Create a session using the client streams\n        async with ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools = await session.list_tools()\n            print(f\"Available tools: {[tool.name for tool in tools.tools]}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This example shows:</p> <ul> <li>Using <code>streamablehttp_client</code> for HTTP connections</li> <li>Simpler connection setup for web-deployed servers</li> <li>Basic tool listing and execution over HTTP</li> </ul>"},{"location":"examples-clients/#display-utilities","title":"Display utilities","text":"<p>Helper utilities for client user interfaces:</p> <pre><code>\"\"\"\ncd to the `examples/snippets` directory and run:\n    uv run display-utilities-client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom mcp.shared.metadata_utils import get_display_name\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"fastmcp_quickstart\", \"stdio\"],\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\nasync def display_tools(session: ClientSession):\n    \"\"\"Display available tools with human-readable names\"\"\"\n    tools_response = await session.list_tools()\n\n    for tool in tools_response.tools:\n        # get_display_name() returns the title if available, otherwise the name\n        display_name = get_display_name(tool)\n        print(f\"Tool: {display_name}\")\n        if tool.description:\n            print(f\"   {tool.description}\")\n\n\nasync def display_resources(session: ClientSession):\n    \"\"\"Display available resources with human-readable names\"\"\"\n    resources_response = await session.list_resources()\n\n    for resource in resources_response.resources:\n        display_name = get_display_name(resource)\n        print(f\"Resource: {display_name} ({resource.uri})\")\n\n    templates_response = await session.list_resource_templates()\n    for template in templates_response.resourceTemplates:\n        display_name = get_display_name(template)\n        print(f\"Resource Template: {display_name}\")\n\n\nasync def run():\n    \"\"\"Run the display utilities example.\"\"\"\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            print(\"=== Available Tools ===\")\n            await display_tools(session)\n\n            print(\"\\n=== Available Resources ===\")\n            await display_resources(session)\n\n\ndef main():\n    \"\"\"Entry point for the display utilities client.\"\"\"\n    asyncio.run(run())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This practical example covers:</p> <ul> <li>Using <code>get_display_name()</code> for human-readable names</li> <li>Proper precedence rules for tool/resource titles</li> <li>Building user-friendly client interfaces</li> <li>Consistent naming across different MCP objects</li> </ul>"},{"location":"examples-clients/#oauth-authentication-client","title":"OAuth authentication client","text":"<p>Client-side OAuth 2.1 authentication flow:</p> <pre><code>\"\"\"\nBefore running, specify running MCP RS server URL.\nTo spin up RS server locally, see\n    examples/servers/simple-auth/README.md\n\ncd to the `examples/snippets` directory and run:\n    uv run oauth-client\n\"\"\"\n\nimport asyncio\nfrom urllib.parse import parse_qs, urlparse\n\nfrom pydantic import AnyUrl\n\nfrom mcp import ClientSession\nfrom mcp.client.auth import OAuthClientProvider, TokenStorage\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata, OAuthToken\n\n\nclass InMemoryTokenStorage(TokenStorage):\n    \"\"\"Demo In-memory token storage implementation.\"\"\"\n\n    def __init__(self):\n        self.tokens: OAuthToken | None = None\n        self.client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -&gt; OAuthToken | None:\n        \"\"\"Get stored tokens.\"\"\"\n        return self.tokens\n\n    async def set_tokens(self, tokens: OAuthToken) -&gt; None:\n        \"\"\"Store tokens.\"\"\"\n        self.tokens = tokens\n\n    async def get_client_info(self) -&gt; OAuthClientInformationFull | None:\n        \"\"\"Get stored client information.\"\"\"\n        return self.client_info\n\n    async def set_client_info(self, client_info: OAuthClientInformationFull) -&gt; None:\n        \"\"\"Store client information.\"\"\"\n        self.client_info = client_info\n\n\nasync def handle_redirect(auth_url: str) -&gt; None:\n    print(f\"Visit: {auth_url}\")\n\n\nasync def handle_callback() -&gt; tuple[str, str | None]:\n    callback_url = input(\"Paste callback URL: \")\n    params = parse_qs(urlparse(callback_url).query)\n    return params[\"code\"][0], params.get(\"state\", [None])[0]\n\n\nasync def main():\n    \"\"\"Run the OAuth client example.\"\"\"\n    oauth_auth = OAuthClientProvider(\n        server_url=\"http://localhost:8001\",\n        client_metadata=OAuthClientMetadata(\n            client_name=\"Example MCP Client\",\n            redirect_uris=[AnyUrl(\"http://localhost:3000/callback\")],\n            grant_types=[\"authorization_code\", \"refresh_token\"],\n            response_types=[\"code\"],\n            scope=\"user\",\n        ),\n        storage=InMemoryTokenStorage(),\n        redirect_handler=handle_redirect,\n        callback_handler=handle_callback,\n    )\n\n    async with streamablehttp_client(\"http://localhost:8001/mcp\", auth=oauth_auth) as (read, write, _):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            tools = await session.list_tools()\n            print(f\"Available tools: {[tool.name for tool in tools.tools]}\")\n\n            resources = await session.list_resources()\n            print(f\"Available resources: {[r.uri for r in resources.resources]}\")\n\n\ndef run():\n    asyncio.run(main())\n\n\nif __name__ == \"__main__\":\n    run()\n</code></pre> <p>This comprehensive example demonstrates:</p> <ul> <li><code>OAuthClientProvider</code> setup and configuration</li> <li>Token storage with custom <code>TokenStorage</code> implementation</li> <li>Authorization flow handling (redirect and callback)</li> <li>Authenticated requests to protected MCP servers</li> </ul>"},{"location":"examples-clients/#completion-client","title":"Completion client","text":"<p>Using completion suggestions for better user experience:</p> <pre><code>\"\"\"\ncd to the `examples/snippets` directory and run:\n    uv run completion-client\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\nfrom mcp.types import PromptReference, ResourceTemplateReference\n\n# Create server parameters for stdio connection\nserver_params = StdioServerParameters(\n    command=\"uv\",  # Using uv to run the server\n    args=[\"run\", \"server\", \"completion\", \"stdio\"],  # Server with completion support\n    env={\"UV_INDEX\": os.environ.get(\"UV_INDEX\", \"\")},\n)\n\n\nasync def run():\n    \"\"\"Run the completion client example.\"\"\"\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize the connection\n            await session.initialize()\n\n            # List available resource templates\n            templates = await session.list_resource_templates()\n            print(\"Available resource templates:\")\n            for template in templates.resourceTemplates:\n                print(f\"  - {template.uriTemplate}\")\n\n            # List available prompts\n            prompts = await session.list_prompts()\n            print(\"\\nAvailable prompts:\")\n            for prompt in prompts.prompts:\n                print(f\"  - {prompt.name}\")\n\n            # Complete resource template arguments\n            if templates.resourceTemplates:\n                template = templates.resourceTemplates[0]\n                print(f\"\\nCompleting arguments for resource template: {template.uriTemplate}\")\n\n                # Complete without context\n                result = await session.complete(\n                    ref=ResourceTemplateReference(type=\"ref/resource\", uri=template.uriTemplate),\n                    argument={\"name\": \"owner\", \"value\": \"model\"},\n                )\n                print(f\"Completions for 'owner' starting with 'model': {result.completion.values}\")\n\n                # Complete with context - repo suggestions based on owner\n                result = await session.complete(\n                    ref=ResourceTemplateReference(type=\"ref/resource\", uri=template.uriTemplate),\n                    argument={\"name\": \"repo\", \"value\": \"\"},\n                    context_arguments={\"owner\": \"modelcontextprotocol\"},\n                )\n                print(f\"Completions for 'repo' with owner='modelcontextprotocol': {result.completion.values}\")\n\n            # Complete prompt arguments\n            if prompts.prompts:\n                prompt_name = prompts.prompts[0].name\n                print(f\"\\nCompleting arguments for prompt: {prompt_name}\")\n\n                result = await session.complete(\n                    ref=PromptReference(type=\"ref/prompt\", name=prompt_name),\n                    argument={\"name\": \"style\", \"value\": \"\"},\n                )\n                print(f\"Completions for 'style' argument: {result.completion.values}\")\n\n\ndef main():\n    \"\"\"Entry point for the completion client.\"\"\"\n    asyncio.run(run())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This advanced example shows:</p> <ul> <li>Resource template argument completion</li> <li>Context-aware completions (e.g., repository suggestions based on owner)</li> <li>Prompt argument completion</li> <li>Dynamic suggestion generation</li> </ul>"},{"location":"examples-clients/#tool-result-parsing","title":"Tool result parsing","text":"<p>Understanding and processing tool results:</p> <pre><code>\"\"\"examples/snippets/clients/parsing_tool_results.py\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\n\n\nasync def parse_tool_results():\n    \"\"\"Demonstrates how to parse different types of content in CallToolResult.\"\"\"\n    server_params = StdioServerParameters(command=\"python\", args=[\"path/to/mcp_server.py\"])\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Example 1: Parsing text content\n            result = await session.call_tool(\"get_data\", {\"format\": \"text\"})\n            for content in result.content:\n                if isinstance(content, types.TextContent):\n                    print(f\"Text: {content.text}\")\n\n            # Example 2: Parsing structured content from JSON tools\n            result = await session.call_tool(\"get_user\", {\"id\": \"123\"})\n            if hasattr(result, \"structuredContent\") and result.structuredContent:\n                # Access structured data directly\n                user_data = result.structuredContent\n                print(f\"User: {user_data.get('name')}, Age: {user_data.get('age')}\")\n\n            # Example 3: Parsing embedded resources\n            result = await session.call_tool(\"read_config\", {})\n            for content in result.content:\n                if isinstance(content, types.EmbeddedResource):\n                    resource = content.resource\n                    if isinstance(resource, types.TextResourceContents):\n                        print(f\"Config from {resource.uri}: {resource.text}\")\n                    else:\n                        print(f\"Binary data from {resource.uri}\")\n\n            # Example 4: Parsing image content\n            result = await session.call_tool(\"generate_chart\", {\"data\": [1, 2, 3]})\n            for content in result.content:\n                if isinstance(content, types.ImageContent):\n                    print(f\"Image ({content.mimeType}): {len(content.data)} bytes\")\n\n            # Example 5: Handling errors\n            result = await session.call_tool(\"failing_tool\", {})\n            if result.isError:\n                print(\"Tool execution failed!\")\n                for content in result.content:\n                    if isinstance(content, types.TextContent):\n                        print(f\"Error: {content.text}\")\n\n\nasync def main():\n    await parse_tool_results()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This detailed example covers:</p> <ul> <li>Parsing different content types (<code>TextContent</code>, <code>ImageContent</code>, <code>EmbeddedResource</code>)</li> <li>Handling structured output data</li> <li>Processing embedded resources</li> <li>Error handling for failed tool executions</li> </ul>"},{"location":"examples-clients/#complete-chatbot-client","title":"Complete chatbot client","text":"<p>A full-featured chatbot that integrates with multiple MCP servers:</p> <pre><code>import asyncio\nimport json\nimport logging\nimport os\nimport shutil\nfrom contextlib import AsyncExitStack\nfrom typing import Any\n\nimport httpx\nfrom dotenv import load_dotenv\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n\n\nclass Configuration:\n    \"\"\"Manages configuration and environment variables for the MCP client.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize configuration with environment variables.\"\"\"\n        self.load_env()\n        self.api_key = os.getenv(\"LLM_API_KEY\")\n\n    @staticmethod\n    def load_env() -&gt; None:\n        \"\"\"Load environment variables from .env file.\"\"\"\n        load_dotenv()\n\n    @staticmethod\n    def load_config(file_path: str) -&gt; dict[str, Any]:\n        \"\"\"Load server configuration from JSON file.\n\n        Args:\n            file_path: Path to the JSON configuration file.\n\n        Returns:\n            Dict containing server configuration.\n\n        Raises:\n            FileNotFoundError: If configuration file doesn't exist.\n            JSONDecodeError: If configuration file is invalid JSON.\n        \"\"\"\n        with open(file_path, \"r\") as f:\n            return json.load(f)\n\n    @property\n    def llm_api_key(self) -&gt; str:\n        \"\"\"Get the LLM API key.\n\n        Returns:\n            The API key as a string.\n\n        Raises:\n            ValueError: If the API key is not found in environment variables.\n        \"\"\"\n        if not self.api_key:\n            raise ValueError(\"LLM_API_KEY not found in environment variables\")\n        return self.api_key\n\n\nclass Server:\n    \"\"\"Manages MCP server connections and tool execution.\"\"\"\n\n    def __init__(self, name: str, config: dict[str, Any]) -&gt; None:\n        self.name: str = name\n        self.config: dict[str, Any] = config\n        self.stdio_context: Any | None = None\n        self.session: ClientSession | None = None\n        self._cleanup_lock: asyncio.Lock = asyncio.Lock()\n        self.exit_stack: AsyncExitStack = AsyncExitStack()\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Initialize the server connection.\"\"\"\n        command = shutil.which(\"npx\") if self.config[\"command\"] == \"npx\" else self.config[\"command\"]\n        if command is None:\n            raise ValueError(\"The command must be a valid string and cannot be None.\")\n\n        server_params = StdioServerParameters(\n            command=command,\n            args=self.config[\"args\"],\n            env={**os.environ, **self.config[\"env\"]} if self.config.get(\"env\") else None,\n        )\n        try:\n            stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))\n            read, write = stdio_transport\n            session = await self.exit_stack.enter_async_context(ClientSession(read, write))\n            await session.initialize()\n            self.session = session\n        except Exception as e:\n            logging.error(f\"Error initializing server {self.name}: {e}\")\n            await self.cleanup()\n            raise\n\n    async def list_tools(self) -&gt; list[Any]:\n        \"\"\"List available tools from the server.\n\n        Returns:\n            A list of available tools.\n\n        Raises:\n            RuntimeError: If the server is not initialized.\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(f\"Server {self.name} not initialized\")\n\n        tools_response = await self.session.list_tools()\n        tools = []\n\n        for item in tools_response:\n            if isinstance(item, tuple) and item[0] == \"tools\":\n                tools.extend(Tool(tool.name, tool.description, tool.inputSchema, tool.title) for tool in item[1])\n\n        return tools\n\n    async def execute_tool(\n        self,\n        tool_name: str,\n        arguments: dict[str, Any],\n        retries: int = 2,\n        delay: float = 1.0,\n    ) -&gt; Any:\n        \"\"\"Execute a tool with retry mechanism.\n\n        Args:\n            tool_name: Name of the tool to execute.\n            arguments: Tool arguments.\n            retries: Number of retry attempts.\n            delay: Delay between retries in seconds.\n\n        Returns:\n            Tool execution result.\n\n        Raises:\n            RuntimeError: If server is not initialized.\n            Exception: If tool execution fails after all retries.\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(f\"Server {self.name} not initialized\")\n\n        attempt = 0\n        while attempt &lt; retries:\n            try:\n                logging.info(f\"Executing {tool_name}...\")\n                result = await self.session.call_tool(tool_name, arguments)\n\n                return result\n\n            except Exception as e:\n                attempt += 1\n                logging.warning(f\"Error executing tool: {e}. Attempt {attempt} of {retries}.\")\n                if attempt &lt; retries:\n                    logging.info(f\"Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                else:\n                    logging.error(\"Max retries reached. Failing.\")\n                    raise\n\n    async def cleanup(self) -&gt; None:\n        \"\"\"Clean up server resources.\"\"\"\n        async with self._cleanup_lock:\n            try:\n                await self.exit_stack.aclose()\n                self.session = None\n                self.stdio_context = None\n            except Exception as e:\n                logging.error(f\"Error during cleanup of server {self.name}: {e}\")\n\n\nclass Tool:\n    \"\"\"Represents a tool with its properties and formatting.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        input_schema: dict[str, Any],\n        title: str | None = None,\n    ) -&gt; None:\n        self.name: str = name\n        self.title: str | None = title\n        self.description: str = description\n        self.input_schema: dict[str, Any] = input_schema\n\n    def format_for_llm(self) -&gt; str:\n        \"\"\"Format tool information for LLM.\n\n        Returns:\n            A formatted string describing the tool.\n        \"\"\"\n        args_desc = []\n        if \"properties\" in self.input_schema:\n            for param_name, param_info in self.input_schema[\"properties\"].items():\n                arg_desc = f\"- {param_name}: {param_info.get('description', 'No description')}\"\n                if param_name in self.input_schema.get(\"required\", []):\n                    arg_desc += \" (required)\"\n                args_desc.append(arg_desc)\n\n        # Build the formatted output with title as a separate field\n        output = f\"Tool: {self.name}\\n\"\n\n        # Add human-readable title if available\n        if self.title:\n            output += f\"User-readable title: {self.title}\\n\"\n\n        output += f\"\"\"Description: {self.description}\nArguments:\n{chr(10).join(args_desc)}\n\"\"\"\n\n        return output\n\n\nclass LLMClient:\n    \"\"\"Manages communication with the LLM provider.\"\"\"\n\n    def __init__(self, api_key: str) -&gt; None:\n        self.api_key: str = api_key\n\n    def get_response(self, messages: list[dict[str, str]]) -&gt; str:\n        \"\"\"Get a response from the LLM.\n\n        Args:\n            messages: A list of message dictionaries.\n\n        Returns:\n            The LLM's response as a string.\n\n        Raises:\n            httpx.RequestError: If the request to the LLM fails.\n        \"\"\"\n        url = \"https://api.groq.com/openai/v1/chat/completions\"\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\",\n        }\n        payload = {\n            \"messages\": messages,\n            \"model\": \"meta-llama/llama-4-scout-17b-16e-instruct\",\n            \"temperature\": 0.7,\n            \"max_tokens\": 4096,\n            \"top_p\": 1,\n            \"stream\": False,\n            \"stop\": None,\n        }\n\n        try:\n            with httpx.Client() as client:\n                response = client.post(url, headers=headers, json=payload)\n                response.raise_for_status()\n                data = response.json()\n                return data[\"choices\"][0][\"message\"][\"content\"]\n\n        except httpx.RequestError as e:\n            error_message = f\"Error getting LLM response: {str(e)}\"\n            logging.error(error_message)\n\n            if isinstance(e, httpx.HTTPStatusError):\n                status_code = e.response.status_code\n                logging.error(f\"Status code: {status_code}\")\n                logging.error(f\"Response details: {e.response.text}\")\n\n            return f\"I encountered an error: {error_message}. Please try again or rephrase your request.\"\n\n\nclass ChatSession:\n    \"\"\"Orchestrates the interaction between user, LLM, and tools.\"\"\"\n\n    def __init__(self, servers: list[Server], llm_client: LLMClient) -&gt; None:\n        self.servers: list[Server] = servers\n        self.llm_client: LLMClient = llm_client\n\n    async def cleanup_servers(self) -&gt; None:\n        \"\"\"Clean up all servers properly.\"\"\"\n        for server in reversed(self.servers):\n            try:\n                await server.cleanup()\n            except Exception as e:\n                logging.warning(f\"Warning during final cleanup: {e}\")\n\n    async def process_llm_response(self, llm_response: str) -&gt; str:\n        \"\"\"Process the LLM response and execute tools if needed.\n\n        Args:\n            llm_response: The response from the LLM.\n\n        Returns:\n            The result of tool execution or the original response.\n        \"\"\"\n        import json\n\n        try:\n            tool_call = json.loads(llm_response)\n            if \"tool\" in tool_call and \"arguments\" in tool_call:\n                logging.info(f\"Executing tool: {tool_call['tool']}\")\n                logging.info(f\"With arguments: {tool_call['arguments']}\")\n\n                for server in self.servers:\n                    tools = await server.list_tools()\n                    if any(tool.name == tool_call[\"tool\"] for tool in tools):\n                        try:\n                            result = await server.execute_tool(tool_call[\"tool\"], tool_call[\"arguments\"])\n\n                            if isinstance(result, dict) and \"progress\" in result:\n                                progress = result[\"progress\"]\n                                total = result[\"total\"]\n                                percentage = (progress / total) * 100\n                                logging.info(f\"Progress: {progress}/{total} ({percentage:.1f}%)\")\n\n                            return f\"Tool execution result: {result}\"\n                        except Exception as e:\n                            error_msg = f\"Error executing tool: {str(e)}\"\n                            logging.error(error_msg)\n                            return error_msg\n\n                return f\"No server found with tool: {tool_call['tool']}\"\n            return llm_response\n        except json.JSONDecodeError:\n            return llm_response\n\n    async def start(self) -&gt; None:\n        \"\"\"Main chat session handler.\"\"\"\n        try:\n            for server in self.servers:\n                try:\n                    await server.initialize()\n                except Exception as e:\n                    logging.error(f\"Failed to initialize server: {e}\")\n                    await self.cleanup_servers()\n                    return\n\n            all_tools = []\n            for server in self.servers:\n                tools = await server.list_tools()\n                all_tools.extend(tools)\n\n            tools_description = \"\\n\".join([tool.format_for_llm() for tool in all_tools])\n\n            system_message = (\n                \"You are a helpful assistant with access to these tools:\\n\\n\"\n                f\"{tools_description}\\n\"\n                \"Choose the appropriate tool based on the user's question. \"\n                \"If no tool is needed, reply directly.\\n\\n\"\n                \"IMPORTANT: When you need to use a tool, you must ONLY respond with \"\n                \"the exact JSON object format below, nothing else:\\n\"\n                \"{\\n\"\n                '    \"tool\": \"tool-name\",\\n'\n                '    \"arguments\": {\\n'\n                '        \"argument-name\": \"value\"\\n'\n                \"    }\\n\"\n                \"}\\n\\n\"\n                \"After receiving a tool's response:\\n\"\n                \"1. Transform the raw data into a natural, conversational response\\n\"\n                \"2. Keep responses concise but informative\\n\"\n                \"3. Focus on the most relevant information\\n\"\n                \"4. Use appropriate context from the user's question\\n\"\n                \"5. Avoid simply repeating the raw data\\n\\n\"\n                \"Please use only the tools that are explicitly defined above.\"\n            )\n\n            messages = [{\"role\": \"system\", \"content\": system_message}]\n\n            while True:\n                try:\n                    user_input = input(\"You: \").strip().lower()\n                    if user_input in [\"quit\", \"exit\"]:\n                        logging.info(\"\\nExiting...\")\n                        break\n\n                    messages.append({\"role\": \"user\", \"content\": user_input})\n\n                    llm_response = self.llm_client.get_response(messages)\n                    logging.info(\"\\nAssistant: %s\", llm_response)\n\n                    result = await self.process_llm_response(llm_response)\n\n                    if result != llm_response:\n                        messages.append({\"role\": \"assistant\", \"content\": llm_response})\n                        messages.append({\"role\": \"system\", \"content\": result})\n\n                        final_response = self.llm_client.get_response(messages)\n                        logging.info(\"\\nFinal response: %s\", final_response)\n                        messages.append({\"role\": \"assistant\", \"content\": final_response})\n                    else:\n                        messages.append({\"role\": \"assistant\", \"content\": llm_response})\n\n                except KeyboardInterrupt:\n                    logging.info(\"\\nExiting...\")\n                    break\n\n        finally:\n            await self.cleanup_servers()\n\n\nasync def main() -&gt; None:\n    \"\"\"Initialize and run the chat session.\"\"\"\n    config = Configuration()\n    server_config = config.load_config(\"servers_config.json\")\n    servers = [Server(name, srv_config) for name, srv_config in server_config[\"mcpServers\"].items()]\n    llm_client = LLMClient(config.llm_api_key)\n    chat_session = ChatSession(servers, llm_client)\n    await chat_session.start()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This production-ready example includes:</p> <ul> <li>Multi-server management: Connect to multiple MCP servers simultaneously</li> <li>LLM integration: Use Groq API for natural language processing</li> <li>Tool orchestration: Automatic tool selection and execution</li> <li>Error handling: Retry mechanisms and graceful failure handling</li> <li>Configuration management: JSON-based server configuration</li> <li>Session management: Persistent conversation context</li> </ul>"},{"location":"examples-clients/#authentication-client","title":"Authentication client","text":"<p>Complete OAuth client implementation:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple MCP client example with OAuth authentication support.\n\nThis client connects to an MCP server using streamable HTTP transport with OAuth.\n\n\"\"\"\n\nimport asyncio\nimport os\nimport threading\nimport time\nimport webbrowser\nfrom datetime import timedelta\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom typing import Any\nfrom urllib.parse import parse_qs, urlparse\n\nfrom mcp.client.auth import OAuthClientProvider, TokenStorage\nfrom mcp.client.session import ClientSession\nfrom mcp.client.sse import sse_client\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata, OAuthToken\n\n\nclass InMemoryTokenStorage(TokenStorage):\n    \"\"\"Simple in-memory token storage implementation.\"\"\"\n\n    def __init__(self):\n        self._tokens: OAuthToken | None = None\n        self._client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -&gt; OAuthToken | None:\n        return self._tokens\n\n    async def set_tokens(self, tokens: OAuthToken) -&gt; None:\n        self._tokens = tokens\n\n    async def get_client_info(self) -&gt; OAuthClientInformationFull | None:\n        return self._client_info\n\n    async def set_client_info(self, client_info: OAuthClientInformationFull) -&gt; None:\n        self._client_info = client_info\n\n\nclass CallbackHandler(BaseHTTPRequestHandler):\n    \"\"\"Simple HTTP handler to capture OAuth callback.\"\"\"\n\n    def __init__(self, request, client_address, server, callback_data):\n        \"\"\"Initialize with callback data storage.\"\"\"\n        self.callback_data = callback_data\n        super().__init__(request, client_address, server)\n\n    def do_GET(self):\n        \"\"\"Handle GET request from OAuth redirect.\"\"\"\n        parsed = urlparse(self.path)\n        query_params = parse_qs(parsed.query)\n\n        if \"code\" in query_params:\n            self.callback_data[\"authorization_code\"] = query_params[\"code\"][0]\n            self.callback_data[\"state\"] = query_params.get(\"state\", [None])[0]\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(b\"\"\"\n            &lt;html&gt;\n            &lt;body&gt;\n                &lt;h1&gt;Authorization Successful!&lt;/h1&gt;\n                &lt;p&gt;You can close this window and return to the terminal.&lt;/p&gt;\n                &lt;script&gt;setTimeout(() =&gt; window.close(), 2000);&lt;/script&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\")\n        elif \"error\" in query_params:\n            self.callback_data[\"error\"] = query_params[\"error\"][0]\n            self.send_response(400)\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(\n                f\"\"\"\n            &lt;html&gt;\n            &lt;body&gt;\n                &lt;h1&gt;Authorization Failed&lt;/h1&gt;\n                &lt;p&gt;Error: {query_params[\"error\"][0]}&lt;/p&gt;\n                &lt;p&gt;You can close this window and return to the terminal.&lt;/p&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\".encode()\n            )\n        else:\n            self.send_response(404)\n            self.end_headers()\n\n    def log_message(self, format, *args):\n        \"\"\"Suppress default logging.\"\"\"\n        pass\n\n\nclass CallbackServer:\n    \"\"\"Simple server to handle OAuth callbacks.\"\"\"\n\n    def __init__(self, port=3000):\n        self.port = port\n        self.server = None\n        self.thread = None\n        self.callback_data = {\"authorization_code\": None, \"state\": None, \"error\": None}\n\n    def _create_handler_with_data(self):\n        \"\"\"Create a handler class with access to callback data.\"\"\"\n        callback_data = self.callback_data\n\n        class DataCallbackHandler(CallbackHandler):\n            def __init__(self, request, client_address, server):\n                super().__init__(request, client_address, server, callback_data)\n\n        return DataCallbackHandler\n\n    def start(self):\n        \"\"\"Start the callback server in a background thread.\"\"\"\n        handler_class = self._create_handler_with_data()\n        self.server = HTTPServer((\"localhost\", self.port), handler_class)\n        self.thread = threading.Thread(target=self.server.serve_forever, daemon=True)\n        self.thread.start()\n        print(f\"\ud83d\udda5\ufe0f  Started callback server on http://localhost:{self.port}\")\n\n    def stop(self):\n        \"\"\"Stop the callback server.\"\"\"\n        if self.server:\n            self.server.shutdown()\n            self.server.server_close()\n        if self.thread:\n            self.thread.join(timeout=1)\n\n    def wait_for_callback(self, timeout=300):\n        \"\"\"Wait for OAuth callback with timeout.\"\"\"\n        start_time = time.time()\n        while time.time() - start_time &lt; timeout:\n            if self.callback_data[\"authorization_code\"]:\n                return self.callback_data[\"authorization_code\"]\n            elif self.callback_data[\"error\"]:\n                raise Exception(f\"OAuth error: {self.callback_data['error']}\")\n            time.sleep(0.1)\n        raise Exception(\"Timeout waiting for OAuth callback\")\n\n    def get_state(self):\n        \"\"\"Get the received state parameter.\"\"\"\n        return self.callback_data[\"state\"]\n\n\nclass SimpleAuthClient:\n    \"\"\"Simple MCP client with auth support.\"\"\"\n\n    def __init__(self, server_url: str, transport_type: str = \"streamable_http\"):\n        self.server_url = server_url\n        self.transport_type = transport_type\n        self.session: ClientSession | None = None\n\n    async def connect(self):\n        \"\"\"Connect to the MCP server.\"\"\"\n        print(f\"\ud83d\udd17 Attempting to connect to {self.server_url}...\")\n\n        try:\n            callback_server = CallbackServer(port=3030)\n            callback_server.start()\n\n            async def callback_handler() -&gt; tuple[str, str | None]:\n                \"\"\"Wait for OAuth callback and return auth code and state.\"\"\"\n                print(\"\u23f3 Waiting for authorization callback...\")\n                try:\n                    auth_code = callback_server.wait_for_callback(timeout=300)\n                    return auth_code, callback_server.get_state()\n                finally:\n                    callback_server.stop()\n\n            client_metadata_dict = {\n                \"client_name\": \"Simple Auth Client\",\n                \"redirect_uris\": [\"http://localhost:3030/callback\"],\n                \"grant_types\": [\"authorization_code\", \"refresh_token\"],\n                \"response_types\": [\"code\"],\n                \"token_endpoint_auth_method\": \"client_secret_post\",\n            }\n\n            async def _default_redirect_handler(authorization_url: str) -&gt; None:\n                \"\"\"Default redirect handler that opens the URL in a browser.\"\"\"\n                print(f\"Opening browser for authorization: {authorization_url}\")\n                webbrowser.open(authorization_url)\n\n            # Create OAuth authentication handler using the new interface\n            oauth_auth = OAuthClientProvider(\n                server_url=self.server_url.replace(\"/mcp\", \"\"),\n                client_metadata=OAuthClientMetadata.model_validate(client_metadata_dict),\n                storage=InMemoryTokenStorage(),\n                redirect_handler=_default_redirect_handler,\n                callback_handler=callback_handler,\n            )\n\n            # Create transport with auth handler based on transport type\n            if self.transport_type == \"sse\":\n                print(\"\ud83d\udce1 Opening SSE transport connection with auth...\")\n                async with sse_client(\n                    url=self.server_url,\n                    auth=oauth_auth,\n                    timeout=60,\n                ) as (read_stream, write_stream):\n                    await self._run_session(read_stream, write_stream, None)\n            else:\n                print(\"\ud83d\udce1 Opening StreamableHTTP transport connection with auth...\")\n                async with streamablehttp_client(\n                    url=self.server_url,\n                    auth=oauth_auth,\n                    timeout=timedelta(seconds=60),\n                ) as (read_stream, write_stream, get_session_id):\n                    await self._run_session(read_stream, write_stream, get_session_id)\n\n        except Exception as e:\n            print(f\"\u274c Failed to connect: {e}\")\n            import traceback\n\n            traceback.print_exc()\n\n    async def _run_session(self, read_stream, write_stream, get_session_id):\n        \"\"\"Run the MCP session with the given streams.\"\"\"\n        print(\"\ud83e\udd1d Initializing MCP session...\")\n        async with ClientSession(read_stream, write_stream) as session:\n            self.session = session\n            print(\"\u26a1 Starting session initialization...\")\n            await session.initialize()\n            print(\"\u2728 Session initialization complete!\")\n\n            print(f\"\\n\u2705 Connected to MCP server at {self.server_url}\")\n            if get_session_id:\n                session_id = get_session_id()\n                if session_id:\n                    print(f\"Session ID: {session_id}\")\n\n            # Run interactive loop\n            await self.interactive_loop()\n\n    async def list_tools(self):\n        \"\"\"List available tools from the server.\"\"\"\n        if not self.session:\n            print(\"\u274c Not connected to server\")\n            return\n\n        try:\n            result = await self.session.list_tools()\n            if hasattr(result, \"tools\") and result.tools:\n                print(\"\\n\ud83d\udccb Available tools:\")\n                for i, tool in enumerate(result.tools, 1):\n                    print(f\"{i}. {tool.name}\")\n                    if tool.description:\n                        print(f\"   Description: {tool.description}\")\n                    print()\n            else:\n                print(\"No tools available\")\n        except Exception as e:\n            print(f\"\u274c Failed to list tools: {e}\")\n\n    async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None = None):\n        \"\"\"Call a specific tool.\"\"\"\n        if not self.session:\n            print(\"\u274c Not connected to server\")\n            return\n\n        try:\n            result = await self.session.call_tool(tool_name, arguments or {})\n            print(f\"\\n\ud83d\udd27 Tool '{tool_name}' result:\")\n            if hasattr(result, \"content\"):\n                for content in result.content:\n                    if content.type == \"text\":\n                        print(content.text)\n                    else:\n                        print(content)\n            else:\n                print(result)\n        except Exception as e:\n            print(f\"\u274c Failed to call tool '{tool_name}': {e}\")\n\n    async def interactive_loop(self):\n        \"\"\"Run interactive command loop.\"\"\"\n        print(\"\\n\ud83c\udfaf Interactive MCP Client\")\n        print(\"Commands:\")\n        print(\"  list - List available tools\")\n        print(\"  call &lt;tool_name&gt; [args] - Call a tool\")\n        print(\"  quit - Exit the client\")\n        print()\n\n        while True:\n            try:\n                command = input(\"mcp&gt; \").strip()\n\n                if not command:\n                    continue\n\n                if command == \"quit\":\n                    break\n\n                elif command == \"list\":\n                    await self.list_tools()\n\n                elif command.startswith(\"call \"):\n                    parts = command.split(maxsplit=2)\n                    tool_name = parts[1] if len(parts) &gt; 1 else \"\"\n\n                    if not tool_name:\n                        print(\"\u274c Please specify a tool name\")\n                        continue\n\n                    # Parse arguments (simple JSON-like format)\n                    arguments = {}\n                    if len(parts) &gt; 2:\n                        import json\n\n                        try:\n                            arguments = json.loads(parts[2])\n                        except json.JSONDecodeError:\n                            print(\"\u274c Invalid arguments format (expected JSON)\")\n                            continue\n\n                    await self.call_tool(tool_name, arguments)\n\n                else:\n                    print(\"\u274c Unknown command. Try 'list', 'call &lt;tool_name&gt;', or 'quit'\")\n\n            except KeyboardInterrupt:\n                print(\"\\n\\n\ud83d\udc4b Goodbye!\")\n                break\n            except EOFError:\n                break\n\n\nasync def main():\n    \"\"\"Main entry point.\"\"\"\n    # Default server URL - can be overridden with environment variable\n    # Most MCP streamable HTTP servers use /mcp as the endpoint\n    server_url = os.getenv(\"MCP_SERVER_PORT\", 8000)\n    transport_type = os.getenv(\"MCP_TRANSPORT_TYPE\", \"streamable_http\")\n    server_url = (\n        f\"http://localhost:{server_url}/mcp\"\n        if transport_type == \"streamable_http\"\n        else f\"http://localhost:{server_url}/sse\"\n    )\n\n    print(\"\ud83d\ude80 Simple MCP Auth Client\")\n    print(f\"Connecting to: {server_url}\")\n    print(f\"Transport type: {transport_type}\")\n\n    # Start connection flow - OAuth will be handled automatically\n    client = SimpleAuthClient(server_url, transport_type)\n    await client.connect()\n\n\ndef cli():\n    \"\"\"CLI entry point for uv script.\"\"\"\n    asyncio.run(main())\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Full OAuth 2.1 client implementation</li> <li>Token management and refresh</li> <li>Protected resource access</li> <li>Integration with authenticated MCP servers</li> </ul>"},{"location":"examples-echo-servers/","title":"Echo server examples","text":"<p>Echo servers provide a foundation for understanding MCP patterns before building more complex functionality.</p> <p>Echo servers are useful for:</p> <ul> <li>Testing client connections: Verify that your client can connect and call tools</li> <li>Understanding MCP basics: Learn the fundamental request/response patterns</li> <li>Development and debugging: Simple, predictable behavior for testing</li> <li>Protocol verification: Ensure transport layers work correctly</li> </ul> <p>The following servers are minimal examples that demonstrate basic MCP functionality by echoing input back to clients.</p>"},{"location":"examples-echo-servers/#simple-echo-server","title":"Simple echo server","text":"<p>The most basic echo implementation:</p> <pre><code>\"\"\"\nFastMCP Echo Server\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo(text: str) -&gt; str:\n    \"\"\"Echo the input text\"\"\"\n    return text\n</code></pre> <p>This minimal example shows:</p> <ul> <li>Single tool implementation with string input/output</li> <li>Basic parameter handling</li> <li>Simple string manipulation and return</li> </ul>"},{"location":"examples-echo-servers/#enhanced-echo-server","title":"Enhanced echo server","text":"<p>More sophisticated echo patterns:</p> <pre><code>\"\"\"\nFastMCP Echo Server\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Echo Server\")\n\n\n@mcp.tool()\ndef echo_tool(text: str) -&gt; str:\n    \"\"\"Echo the input text\"\"\"\n    return text\n\n\n@mcp.resource(\"echo://static\")\ndef echo_resource() -&gt; str:\n    return \"Echo!\"\n\n\n@mcp.resource(\"echo://{text}\")\ndef echo_template(text: str) -&gt; str:\n    \"\"\"Echo the input text\"\"\"\n    return f\"Echo: {text}\"\n\n\n@mcp.prompt(\"echo\")\ndef echo_prompt(text: str) -&gt; str:\n    return text\n</code></pre> <p>This enhanced version demonstrates:</p> <ul> <li>Multiple echo variants (basic echo, uppercase, reverse)</li> <li>Different parameter types and patterns</li> <li>Tool naming and description best practices</li> </ul>"},{"location":"examples-echo-servers/#usage","title":"Usage","text":"<p>These echo servers can be used to test different aspects of MCP:</p> <pre><code># Test with MCP Inspector\nuv run mcp dev echo.py\n\n# Test direct execution\npython echo.py\n\n# Test with custom clients\n# (Use the client examples to connect to these echo servers)\n</code></pre>"},{"location":"examples-echo-servers/#testing-tool-calls","title":"Testing tool calls","text":"<p>Example tool calls you can make to echo servers:</p> <pre><code>{\n  \"tool\": \"echo\",\n  \"arguments\": {\n    \"message\": \"Hello, MCP!\"\n  }\n}\n</code></pre> <p>Expected response:</p> <pre><code>{\n  \"result\": \"Echo: Hello, MCP!\"\n}\n</code></pre>"},{"location":"examples-lowlevel-servers/","title":"Low-level server examples","text":"<p>The low-level server API provides maximum control over MCP protocol implementation. Use these patterns when you need fine-grained control or when <code>FastMCP</code> doesn't meet your requirements.</p> <p>The low-level API provides the foundation that FastMCP is built upon, giving you access to all MCP protocol features with complete control over implementation details.</p>"},{"location":"examples-lowlevel-servers/#when-to-use-low-level-api","title":"When to use low-level API","text":"<p>Choose the low-level API when you need:</p> <ul> <li>Custom protocol message handling</li> <li>Complex initialization sequences</li> <li>Fine-grained control over capabilities</li> <li>Integration with existing server infrastructure</li> <li>Performance optimization at the protocol level</li> <li>Custom authentication or authorization logic</li> </ul> <p>Key differences between the low-level server API and FastMCP are:</p> Low-level API FastMCP Control Maximum control Convention over configuration Boilerplate More verbose Minimal setup Decorators Server method decorators Simple function decorators Schema Manual definition Automatic from type hints Lifecycle Manual management Automatic handling Best for Complex custom logic Rapid development"},{"location":"examples-lowlevel-servers/#basic-low-level-server","title":"Basic low-level server","text":"<p>Fundamental low-level server patterns:</p> <pre><code>\"\"\"\nRun from the repository root:\nuv run examples/snippets/servers/lowlevel/basic.py\n\"\"\"\n\nimport asyncio\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n# Create a server instance\nserver = Server(\"example-server\")\n\n\n@server.list_prompts()\nasync def handle_list_prompts() -&gt; list[types.Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        types.Prompt(\n            name=\"example-prompt\",\n            description=\"An example prompt template\",\n            arguments=[types.PromptArgument(name=\"arg1\", description=\"Example argument\", required=True)],\n        )\n    ]\n\n\n@server.get_prompt()\nasync def handle_get_prompt(name: str, arguments: dict[str, str] | None) -&gt; types.GetPromptResult:\n    \"\"\"Get a specific prompt by name.\"\"\"\n    if name != \"example-prompt\":\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n    arg1_value = (arguments or {}).get(\"arg1\", \"default\")\n\n    return types.GetPromptResult(\n        description=\"Example prompt\",\n        messages=[\n            types.PromptMessage(\n                role=\"user\",\n                content=types.TextContent(type=\"text\", text=f\"Example prompt text with argument: {arg1_value}\"),\n            )\n        ],\n    )\n\n\nasync def run():\n    \"\"\"Run the basic low-level server.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Creating a <code>Server</code> instance directly</li> <li>Manual handler registration with decorators</li> <li>Prompt management with <code>@server.list_prompts()</code> and <code>@server.get_prompt()</code></li> <li>Manual capability declaration</li> <li>Explicit initialization and connection handling</li> </ul>"},{"location":"examples-lowlevel-servers/#low-level-server-with-lifespan","title":"Low-level server with lifespan","text":"<p>Resource management and lifecycle control:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/lowlevel/lifespan.py\n\"\"\"\n\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n\n# Mock database class for example\nclass Database:\n    \"\"\"Mock database class for example.\"\"\"\n\n    @classmethod\n    async def connect(cls) -&gt; \"Database\":\n        \"\"\"Connect to database.\"\"\"\n        print(\"Database connected\")\n        return cls()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from database.\"\"\"\n        print(\"Database disconnected\")\n\n    async def query(self, query_str: str) -&gt; list[dict[str, str]]:\n        \"\"\"Execute a query.\"\"\"\n        # Simulate database query\n        return [{\"id\": \"1\", \"name\": \"Example\", \"query\": query_str}]\n\n\n@asynccontextmanager\nasync def server_lifespan(_server: Server) -&gt; AsyncIterator[dict[str, Any]]:\n    \"\"\"Manage server startup and shutdown lifecycle.\"\"\"\n    # Initialize resources on startup\n    db = await Database.connect()\n    try:\n        yield {\"db\": db}\n    finally:\n        # Clean up on shutdown\n        await db.disconnect()\n\n\n# Pass lifespan to server\nserver = Server(\"example-server\", lifespan=server_lifespan)\n\n\n@server.list_tools()\nasync def handle_list_tools() -&gt; list[types.Tool]:\n    \"\"\"List available tools.\"\"\"\n    return [\n        types.Tool(\n            name=\"query_db\",\n            description=\"Query the database\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"query\": {\"type\": \"string\", \"description\": \"SQL query to execute\"}},\n                \"required\": [\"query\"],\n            },\n        )\n    ]\n\n\n@server.call_tool()\nasync def query_db(name: str, arguments: dict[str, Any]) -&gt; list[types.TextContent]:\n    \"\"\"Handle database query tool call.\"\"\"\n    if name != \"query_db\":\n        raise ValueError(f\"Unknown tool: {name}\")\n\n    # Access lifespan context\n    ctx = server.request_context\n    db = ctx.lifespan_context[\"db\"]\n\n    # Execute query\n    results = await db.query(arguments[\"query\"])\n\n    return [types.TextContent(type=\"text\", text=f\"Query results: {results}\")]\n\n\nasync def run():\n    \"\"\"Run the server with lifespan management.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"example-server\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(run())\n</code></pre> <p>This advanced pattern shows:</p> <ul> <li>Custom lifespan context manager for resource initialization</li> <li>Database connection management example</li> <li>Accessing lifespan context through <code>server.request_context</code></li> <li>Tool implementation with resource access</li> <li>Proper cleanup and connection management</li> </ul>"},{"location":"examples-lowlevel-servers/#structured-output-with-low-level-api","title":"Structured output with low-level API","text":"<p>Manual structured output control:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/lowlevel/structured_output.py\n\"\"\"\n\nimport asyncio\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\nserver = Server(\"example-server\")\n\n\n@server.list_tools()\nasync def list_tools() -&gt; list[types.Tool]:\n    \"\"\"List available tools with structured output schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\", \"description\": \"Temperature in Celsius\"},\n                    \"condition\": {\"type\": \"string\", \"description\": \"Weather condition\"},\n                    \"humidity\": {\"type\": \"number\", \"description\": \"Humidity percentage\"},\n                    \"city\": {\"type\": \"string\", \"description\": \"City name\"},\n                },\n                \"required\": [\"temperature\", \"condition\", \"humidity\", \"city\"],\n            },\n        )\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Handle tool calls with structured output.\"\"\"\n    if name == \"get_weather\":\n        city = arguments[\"city\"]\n\n        # Simulated weather data - in production, call a weather API\n        weather_data = {\n            \"temperature\": 22.5,\n            \"condition\": \"partly cloudy\",\n            \"humidity\": 65,\n            \"city\": city,  # Include the requested city\n        }\n\n        # low-level server will validate structured output against the tool's\n        # output schema, and additionally serialize it into a TextContent block\n        # for backwards compatibility with pre-2025-06-18 clients.\n        return weather_data\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\n\nasync def run():\n    \"\"\"Run the structured output server.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"structured-output-example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n</code></pre> <p>And a standalone implementation:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nExample low-level MCP server demonstrating structured output support.\n\nThis example shows how to use the low-level server API to return\nstructured data from tools, with automatic validation against output\nschemas.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n# Create low-level server instance\nserver = Server(\"structured-output-lowlevel-example\")\n\n\n@server.list_tools()\nasync def list_tools() -&gt; list[types.Tool]:\n    \"\"\"List available tools with their schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get weather information (simulated)\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\"},\n                    \"conditions\": {\"type\": \"string\"},\n                    \"humidity\": {\"type\": \"integer\", \"minimum\": 0, \"maximum\": 100},\n                    \"wind_speed\": {\"type\": \"number\"},\n                    \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"},\n                },\n                \"required\": [\"temperature\", \"conditions\", \"humidity\", \"wind_speed\", \"timestamp\"],\n            },\n        ),\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Handle tool call with structured output.\n    \"\"\"\n\n    if name == \"get_weather\":\n        # city = arguments[\"city\"]  # Would be used with real weather API\n\n        # Simulate weather data (in production, call a real weather API)\n        import random\n\n        weather_conditions = [\"sunny\", \"cloudy\", \"rainy\", \"partly cloudy\", \"foggy\"]\n\n        weather_data = {\n            \"temperature\": round(random.uniform(0, 35), 1),\n            \"conditions\": random.choice(weather_conditions),\n            \"humidity\": random.randint(30, 90),\n            \"wind_speed\": round(random.uniform(0, 30), 1),\n            \"timestamp\": datetime.now().isoformat(),\n        }\n\n        # Return structured data only\n        # The low-level server will serialize this to JSON content automatically\n        return weather_data\n\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\n\nasync def run():\n    \"\"\"Run the low-level server using stdio transport.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"structured-output-lowlevel-example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n</code></pre> <p>These examples cover:</p> <ul> <li>Manual <code>outputSchema</code> definition in tool specifications</li> <li>Direct dictionary return for structured data</li> <li>Automatic validation against defined schemas</li> <li>Backward compatibility with text content</li> </ul>"},{"location":"examples-lowlevel-servers/#simple-tool-server","title":"Simple tool server","text":"<p>Complete low-level server focused on tools:</p> <pre><code>from typing import Any\n\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.shared._httpx_utils import create_mcp_http_client\nfrom starlette.requests import Request\n\n\nasync def fetch_website(\n    url: str,\n) -&gt; list[types.ContentBlock]:\n    headers = {\"User-Agent\": \"MCP Test Server (github.com/modelcontextprotocol/python-sdk)\"}\n    async with create_mcp_http_client(headers=headers) as client:\n        response = await client.get(url)\n        response.raise_for_status()\n        return [types.TextContent(type=\"text\", text=response.text)]\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -&gt; int:\n    app = Server(\"mcp-website-fetcher\")\n\n    @app.call_tool()\n    async def fetch_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n        if name != \"fetch\":\n            raise ValueError(f\"Unknown tool: {name}\")\n        if \"url\" not in arguments:\n            raise ValueError(\"Missing required argument 'url'\")\n        return await fetch_website(arguments[\"url\"])\n\n    @app.list_tools()\n    async def list_tools() -&gt; list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"fetch\",\n                title=\"Website Fetcher\",\n                description=\"Fetches a website and returns its content\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"url\"],\n                    \"properties\": {\n                        \"url\": {\n                            \"type\": \"string\",\n                            \"description\": \"URL to fetch\",\n                        }\n                    },\n                },\n            )\n        ]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0\n</code></pre> <p>This production-ready example includes:</p> <ul> <li>Full tool lifecycle management</li> <li>Input validation and error handling</li> <li>Proper MCP protocol compliance</li> <li>Tool execution with structured responses</li> </ul>"},{"location":"examples-quickstart/","title":"Getting started","text":"<p>This section provides quick and simple examples to get you started with the MCP Python SDK.</p> <p>These examples can be run directly with:</p> <pre><code>python server.py\n</code></pre> <p>Or test with the MCP Inspector:</p> <pre><code>uv run mcp dev server.py\n</code></pre>"},{"location":"examples-quickstart/#fastmcp-quickstart","title":"FastMCP quickstart","text":"<p>The easiest way to create an MCP server is with <code>FastMCP</code>. This example demonstrates the core concepts: tools, resources, and prompts.</p> <pre><code>\"\"\"\nFastMCP quickstart example.\n\ncd to the `examples/snippets/clients` directory and run:\n    uv run server fastmcp_quickstart stdio\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n\n# Add an addition tool\n@mcp.tool()\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n# Add a dynamic greeting resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n\n\n# Add a prompt\n@mcp.prompt()\ndef greet_user(name: str, style: str = \"friendly\") -&gt; str:\n    \"\"\"Generate a greeting prompt\"\"\"\n    styles = {\n        \"friendly\": \"Please write a warm, friendly greeting\",\n        \"formal\": \"Please write a formal, professional greeting\",\n        \"casual\": \"Please write a casual, relaxed greeting\",\n    }\n\n    return f\"{styles.get(style, styles['friendly'])} for someone named {name}.\"\n</code></pre> <p>This example shows how to:</p> <ul> <li>Create a FastMCP server instance</li> <li>Add a tool that performs computation (<code>add</code>)</li> <li>Add a dynamic resource that provides data (<code>greeting://</code>)</li> <li>Add a prompt template for LLM interactions (<code>greet_user</code>)</li> </ul>"},{"location":"examples-quickstart/#basic-server","title":"Basic server","text":"<p>An even simpler starting point:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n\n# Add an addition tool\n@mcp.tool()\ndef sum(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n# Add a dynamic greeting resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n</code></pre>"},{"location":"examples-quickstart/#direct-execution","title":"Direct execution","text":"<p>For the simplest possible server deployment:</p> <pre><code>\"\"\"Example showing direct execution of an MCP server.\n\nThis is the simplest way to run an MCP server directly.\ncd to the `examples/snippets` directory and run:\n    uv run direct-execution-server\n    or\n    python servers/direct_execution.py\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"My App\")\n\n\n@mcp.tool()\ndef hello(name: str = \"World\") -&gt; str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"\n\n\ndef main():\n    \"\"\"Entry point for the direct execution server.\"\"\"\n    mcp.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Minimal server setup with just a greeting tool</li> <li>Direct execution without additional configuration</li> <li>Entry point setup for standalone running</li> </ul>"},{"location":"examples-server-advanced/","title":"Advanced server examples","text":"<p>This section covers advanced server patterns including lifecycle management, context handling, and interactive capabilities.</p> <p>These advanced patterns enable rich, interactive server implementations that go beyond simple request-response workflows.</p>"},{"location":"examples-server-advanced/#lifespan-management","title":"Lifespan management","text":"<p>Managing server lifecycle with resource initialization and cleanup:</p> <pre><code>\"\"\"Example showing lifespan support for startup/shutdown with strong typing.\"\"\"\n\nfrom collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.session import ServerSession\n\n\n# Mock database class for example\nclass Database:\n    \"\"\"Mock database class for example.\"\"\"\n\n    @classmethod\n    async def connect(cls) -&gt; \"Database\":\n        \"\"\"Connect to database.\"\"\"\n        return cls()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from database.\"\"\"\n        pass\n\n    def query(self) -&gt; str:\n        \"\"\"Execute a query.\"\"\"\n        return \"Query result\"\n\n\n@dataclass\nclass AppContext:\n    \"\"\"Application context with typed dependencies.\"\"\"\n\n    db: Database\n\n\n@asynccontextmanager\nasync def app_lifespan(server: FastMCP) -&gt; AsyncIterator[AppContext]:\n    \"\"\"Manage application lifecycle with type-safe context.\"\"\"\n    # Initialize on startup\n    db = await Database.connect()\n    try:\n        yield AppContext(db=db)\n    finally:\n        # Cleanup on shutdown\n        await db.disconnect()\n\n\n# Pass lifespan to server\nmcp = FastMCP(\"My App\", lifespan=app_lifespan)\n\n\n# Access type-safe lifespan context in tools\n@mcp.tool()\ndef query_db(ctx: Context[ServerSession, AppContext]) -&gt; str:\n    \"\"\"Tool that uses initialized resources.\"\"\"\n    db = ctx.request_context.lifespan_context.db\n    return db.query()\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Type-safe lifespan context management</li> <li>Resource initialization on startup (database connections, etc.)</li> <li>Automatic cleanup on shutdown</li> <li>Accessing lifespan context from tools via <code>ctx.request_context.lifespan_context</code></li> </ul>"},{"location":"examples-server-advanced/#user-interaction-and-elicitation","title":"User interaction and elicitation","text":"<p>Tools that can request additional information from users:</p> <pre><code>from pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.session import ServerSession\n\nmcp = FastMCP(name=\"Elicitation Example\")\n\n\nclass BookingPreferences(BaseModel):\n    \"\"\"Schema for collecting user preferences.\"\"\"\n\n    checkAlternative: bool = Field(description=\"Would you like to check another date?\")\n    alternativeDate: str = Field(\n        default=\"2024-12-26\",\n        description=\"Alternative date (YYYY-MM-DD)\",\n    )\n\n\n@mcp.tool()\nasync def book_table(date: str, time: str, party_size: int, ctx: Context[ServerSession, None]) -&gt; str:\n    \"\"\"Book a table with date availability check.\"\"\"\n    # Check if date is available\n    if date == \"2024-12-25\":\n        # Date unavailable - ask user for alternative\n        result = await ctx.elicit(\n            message=(f\"No tables available for {party_size} on {date}. Would you like to try another date?\"),\n            schema=BookingPreferences,\n        )\n\n        if result.action == \"accept\" and result.data:\n            if result.data.checkAlternative:\n                return f\"[SUCCESS] Booked for {result.data.alternativeDate}\"\n            return \"[CANCELLED] No booking made\"\n        return \"[CANCELLED] Booking cancelled\"\n\n    # Date available\n    return f\"[SUCCESS] Booked for {date} at {time}\"\n</code></pre> <p>This example shows:</p> <ul> <li>Using <code>ctx.elicit()</code> to request user input</li> <li>Pydantic schemas for validating user responses</li> <li>Handling user acceptance, decline, or cancellation</li> <li>Interactive booking workflow patterns</li> </ul>"},{"location":"examples-server-advanced/#llm-sampling-and-integration","title":"LLM sampling and integration","text":"<p>Tools that interact with LLMs through sampling:</p> <pre><code>from mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.session import ServerSession\nfrom mcp.types import SamplingMessage, TextContent\n\nmcp = FastMCP(name=\"Sampling Example\")\n\n\n@mcp.tool()\nasync def generate_poem(topic: str, ctx: Context[ServerSession, None]) -&gt; str:\n    \"\"\"Generate a poem using LLM sampling.\"\"\"\n    prompt = f\"Write a short poem about {topic}\"\n\n    result = await ctx.session.create_message(\n        messages=[\n            SamplingMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=prompt),\n            )\n        ],\n        max_tokens=100,\n    )\n\n    if result.content.type == \"text\":\n        return result.content.text\n    return str(result.content)\n</code></pre> <p>This demonstrates:</p> <ul> <li>Using <code>ctx.session.create_message()</code> for LLM interaction</li> <li>Structured message creation with <code>SamplingMessage</code> and <code>TextContent</code></li> <li>Processing LLM responses within tools</li> <li>Chaining LLM interactions for complex workflows</li> </ul>"},{"location":"examples-server-advanced/#logging-and-notifications","title":"Logging and notifications","text":"<p>Advanced logging and client notification patterns:</p> <pre><code>from mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.session import ServerSession\n\nmcp = FastMCP(name=\"Notifications Example\")\n\n\n@mcp.tool()\nasync def process_data(data: str, ctx: Context[ServerSession, None]) -&gt; str:\n    \"\"\"Process data with logging.\"\"\"\n    # Different log levels\n    await ctx.debug(f\"Debug: Processing '{data}'\")\n    await ctx.info(\"Info: Starting processing\")\n    await ctx.warning(\"Warning: This is experimental\")\n    await ctx.error(\"Error: (This is just a demo)\")\n\n    # Notify about resource changes\n    await ctx.session.send_resource_list_changed()\n\n    return f\"Processed: {data}\"\n</code></pre> <p>This example covers:</p> <ul> <li>Multiple log levels (debug, info, warning, error)</li> <li>Resource change notifications via <code>ctx.session.send_resource_list_changed()</code></li> <li>Contextual logging within tool execution</li> <li>Client communication patterns</li> </ul>"},{"location":"examples-server-advanced/#image-handling","title":"Image handling","text":"<p>Working with images in MCP servers:</p> <pre><code>\"\"\"Example showing image handling with FastMCP.\"\"\"\n\nfrom PIL import Image as PILImage\n\nfrom mcp.server.fastmcp import FastMCP, Image\n\nmcp = FastMCP(\"Image Example\")\n\n\n@mcp.tool()\ndef create_thumbnail(image_path: str) -&gt; Image:\n    \"\"\"Create a thumbnail from an image\"\"\"\n    img = PILImage.open(image_path)\n    img.thumbnail((100, 100))\n    return Image(data=img.tobytes(), format=\"png\")\n</code></pre> <p>This shows:</p> <ul> <li>Using FastMCP's <code>Image</code> class for automatic image handling</li> <li>PIL integration for image processing with <code>PIL.Image.open()</code></li> <li>Returning images from tools</li> <li>Image format conversion and optimization</li> </ul>"},{"location":"examples-server-advanced/#completion-support","title":"Completion support","text":"<p>Providing argument completion for enhanced user experience:</p> <pre><code>from mcp.server.fastmcp import FastMCP\nfrom mcp.types import (\n    Completion,\n    CompletionArgument,\n    CompletionContext,\n    PromptReference,\n    ResourceTemplateReference,\n)\n\nmcp = FastMCP(name=\"Example\")\n\n\n@mcp.resource(\"github://repos/{owner}/{repo}\")\ndef github_repo(owner: str, repo: str) -&gt; str:\n    \"\"\"GitHub repository resource.\"\"\"\n    return f\"Repository: {owner}/{repo}\"\n\n\n@mcp.prompt(description=\"Code review prompt\")\ndef review_code(language: str, code: str) -&gt; str:\n    \"\"\"Generate a code review.\"\"\"\n    return f\"Review this {language} code:\\n{code}\"\n\n\n@mcp.completion()\nasync def handle_completion(\n    ref: PromptReference | ResourceTemplateReference,\n    argument: CompletionArgument,\n    context: CompletionContext | None,\n) -&gt; Completion | None:\n    \"\"\"Provide completions for prompts and resources.\"\"\"\n\n    # Complete programming languages for the prompt\n    if isinstance(ref, PromptReference):\n        if ref.name == \"review_code\" and argument.name == \"language\":\n            languages = [\"python\", \"javascript\", \"typescript\", \"go\", \"rust\"]\n            return Completion(\n                values=[lang for lang in languages if lang.startswith(argument.value)],\n                hasMore=False,\n            )\n\n    # Complete repository names for GitHub resources\n    if isinstance(ref, ResourceTemplateReference):\n        if ref.uri == \"github://repos/{owner}/{repo}\" and argument.name == \"repo\":\n            if context and context.arguments and context.arguments.get(\"owner\") == \"modelcontextprotocol\":\n                repos = [\"python-sdk\", \"typescript-sdk\", \"specification\"]\n                return Completion(values=repos, hasMore=False)\n\n    return None\n</code></pre> <p>This advanced pattern demonstrates:</p> <ul> <li>Dynamic completion based on partial input</li> <li>Context-aware suggestions (repository suggestions based on owner)</li> <li>Resource template parameter completion</li> <li>Prompt argument completion</li> </ul>"},{"location":"examples-server-prompts/","title":"Server prompts examples","text":"<p>Prompts are reusable templates that help structure LLM interactions. They provide a way to define consistent interaction patterns that users can invoke.</p> <p>Prompts are user-controlled primitives and are particularly useful for:</p> <ul> <li>Code review templates</li> <li>Debugging assistance workflows</li> <li>Content generation patterns</li> <li>Structured analysis requests</li> </ul> <p>Unlike tools (which are model-controlled) and resources (which are application-controlled), prompts are invoked directly by users to initiate specific types of interactions with the LLM.</p>"},{"location":"examples-server-prompts/#basic-prompts","title":"Basic prompts","text":"<p>Simple prompt templates for common scenarios:</p> <pre><code>from mcp.server.fastmcp import FastMCP\nfrom mcp.server.fastmcp.prompts import base\n\nmcp = FastMCP(name=\"Prompt Example\")\n\n\n@mcp.prompt(title=\"Code Review\")\ndef review_code(code: str) -&gt; str:\n    return f\"Please review this code:\\n\\n{code}\"\n\n\n@mcp.prompt(title=\"Debug Assistant\")\ndef debug_error(error: str) -&gt; list[base.Message]:\n    return [\n        base.UserMessage(\"I'm seeing this error:\"),\n        base.UserMessage(error),\n        base.AssistantMessage(\"I'll help debug that. What have you tried so far?\"),\n    ]\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Simple string prompts (<code>review_code</code>)</li> <li>Multi-message prompt conversations (<code>debug_error</code>)</li> <li>Using different message types (User and Assistant messages)</li> <li>Prompt titles for better user experience</li> </ul>"},{"location":"examples-server-prompts/#simple-prompt-server","title":"Simple prompt server","text":"<p>A complete server focused on prompt management:</p> <pre><code>import anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom starlette.requests import Request\n\n\ndef create_messages(context: str | None = None, topic: str | None = None) -&gt; list[types.PromptMessage]:\n    \"\"\"Create the messages for the prompt.\"\"\"\n    messages: list[types.PromptMessage] = []\n\n    # Add context if provided\n    if context:\n        messages.append(\n            types.PromptMessage(\n                role=\"user\",\n                content=types.TextContent(type=\"text\", text=f\"Here is some relevant context: {context}\"),\n            )\n        )\n\n    # Add the main prompt\n    prompt = \"Please help me with \"\n    if topic:\n        prompt += f\"the following topic: {topic}\"\n    else:\n        prompt += \"whatever questions I may have.\"\n\n    messages.append(types.PromptMessage(role=\"user\", content=types.TextContent(type=\"text\", text=prompt)))\n\n    return messages\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -&gt; int:\n    app = Server(\"mcp-simple-prompt\")\n\n    @app.list_prompts()\n    async def list_prompts() -&gt; list[types.Prompt]:\n        return [\n            types.Prompt(\n                name=\"simple\",\n                title=\"Simple Assistant Prompt\",\n                description=\"A simple prompt that can take optional context and topic arguments\",\n                arguments=[\n                    types.PromptArgument(\n                        name=\"context\",\n                        description=\"Additional context to consider\",\n                        required=False,\n                    ),\n                    types.PromptArgument(\n                        name=\"topic\",\n                        description=\"Specific topic to focus on\",\n                        required=False,\n                    ),\n                ],\n            )\n        ]\n\n    @app.get_prompt()\n    async def get_prompt(name: str, arguments: dict[str, str] | None = None) -&gt; types.GetPromptResult:\n        if name != \"simple\":\n            raise ValueError(f\"Unknown prompt: {name}\")\n\n        if arguments is None:\n            arguments = {}\n\n        return types.GetPromptResult(\n            messages=create_messages(context=arguments.get(\"context\"), topic=arguments.get(\"topic\")),\n            description=\"A simple prompt with optional context and topic arguments\",\n        )\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0\n</code></pre> <p>This low-level server example shows:</p> <ul> <li>Prompt listing and retrieval</li> <li>Argument handling and validation</li> <li>Dynamic prompt generation based on parameters</li> <li>Production-ready prompt patterns using the low-level API</li> </ul>"},{"location":"examples-server-resources/","title":"Server resources examples","text":"<p>Resources provide data to LLMs without side effects. They're similar to GET endpoints in REST APIs and should be used for exposing information rather than performing actions.</p> <p>Resources are essential for providing contextual information to LLMs, whether it's configuration data, file contents, or dynamic information that changes over time.</p>"},{"location":"examples-server-resources/#basic-resources","title":"Basic resources","text":"<p>Simple resource patterns for exposing data:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(name=\"Resource Example\")\n\n\n@mcp.resource(\"file://documents/{name}\")\ndef read_document(name: str) -&gt; str:\n    \"\"\"Read a document by name.\"\"\"\n    # This would normally read from disk\n    return f\"Content of {name}\"\n\n\n@mcp.resource(\"config://settings\")\ndef get_settings() -&gt; str:\n    \"\"\"Get application settings.\"\"\"\n    return \"\"\"{\n  \"theme\": \"dark\",\n  \"language\": \"en\",\n  \"debug\": false\n}\"\"\"\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Static resources with fixed URIs (<code>config://settings</code>)</li> <li>Dynamic resources with URI templates (<code>file://documents/{name}</code>)</li> <li>Simple string data return</li> <li>JSON configuration data</li> </ul>"},{"location":"examples-server-resources/#simple-resource-server","title":"Simple resource server","text":"<p>A complete server focused on resource management:</p> <pre><code>import anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom pydantic import AnyUrl, FileUrl\nfrom starlette.requests import Request\n\nSAMPLE_RESOURCES = {\n    \"greeting\": {\n        \"content\": \"Hello! This is a sample text resource.\",\n        \"title\": \"Welcome Message\",\n    },\n    \"help\": {\n        \"content\": \"This server provides a few sample text resources for testing.\",\n        \"title\": \"Help Documentation\",\n    },\n    \"about\": {\n        \"content\": \"This is the simple-resource MCP server implementation.\",\n        \"title\": \"About This Server\",\n    },\n}\n\n\n@click.command()\n@click.option(\"--port\", default=8000, help=\"Port to listen on for SSE\")\n@click.option(\n    \"--transport\",\n    type=click.Choice([\"stdio\", \"sse\"]),\n    default=\"stdio\",\n    help=\"Transport type\",\n)\ndef main(port: int, transport: str) -&gt; int:\n    app = Server(\"mcp-simple-resource\")\n\n    @app.list_resources()\n    async def list_resources() -&gt; list[types.Resource]:\n        return [\n            types.Resource(\n                uri=FileUrl(f\"file:///{name}.txt\"),\n                name=name,\n                title=SAMPLE_RESOURCES[name][\"title\"],\n                description=f\"A sample text resource named {name}\",\n                mimeType=\"text/plain\",\n            )\n            for name in SAMPLE_RESOURCES.keys()\n        ]\n\n    @app.read_resource()\n    async def read_resource(uri: AnyUrl) -&gt; str | bytes:\n        if uri.path is None:\n            raise ValueError(f\"Invalid resource path: {uri}\")\n        name = uri.path.replace(\".txt\", \"\").lstrip(\"/\")\n\n        if name not in SAMPLE_RESOURCES:\n            raise ValueError(f\"Unknown resource: {uri}\")\n\n        return SAMPLE_RESOURCES[name][\"content\"]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0\n</code></pre> <p>This is an example of a low-level server that:</p> <ul> <li>Uses the low-level server API for maximum control</li> <li>Implements resource listing and reading</li> <li>Handles URI templates and parameter extraction</li> <li>Demonstrates production-ready resource patterns</li> </ul>"},{"location":"examples-server-resources/#memory-and-state-management","title":"Memory and state management","text":"<p>Resources that manage server memory and state:</p> <pre><code># /// script\n# dependencies = [\"pydantic-ai-slim[openai]\", \"asyncpg\", \"numpy\", \"pgvector\"]\n# ///\n\n# uv pip install 'pydantic-ai-slim[openai]' asyncpg numpy pgvector\n\n\"\"\"\nRecursive memory system inspired by the human brain's clustering of memories.\nUses OpenAI's 'text-embedding-3-small' model and pgvector for efficient\nsimilarity search.\n\"\"\"\n\nimport asyncio\nimport math\nimport os\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Annotated, Self, TypeVar\n\nimport asyncpg\nimport numpy as np\nfrom openai import AsyncOpenAI\nfrom pgvector.asyncpg import register_vector  # Import register_vector\nfrom pydantic import BaseModel, Field\nfrom pydantic_ai import Agent\n\nfrom mcp.server.fastmcp import FastMCP\n\nMAX_DEPTH = 5\nSIMILARITY_THRESHOLD = 0.7\nDECAY_FACTOR = 0.99\nREINFORCEMENT_FACTOR = 1.1\n\nDEFAULT_LLM_MODEL = \"openai:gpt-4o\"\nDEFAULT_EMBEDDING_MODEL = \"text-embedding-3-small\"\n\nT = TypeVar(\"T\")\n\nmcp = FastMCP(\n    \"memory\",\n    dependencies=[\n        \"pydantic-ai-slim[openai]\",\n        \"asyncpg\",\n        \"numpy\",\n        \"pgvector\",\n    ],\n)\n\nDB_DSN = \"postgresql://postgres:postgres@localhost:54320/memory_db\"\n# reset memory with rm ~/.fastmcp/{USER}/memory/*\nPROFILE_DIR = (Path.home() / \".fastmcp\" / os.environ.get(\"USER\", \"anon\") / \"memory\").resolve()\nPROFILE_DIR.mkdir(parents=True, exist_ok=True)\n\n\ndef cosine_similarity(a: list[float], b: list[float]) -&gt; float:\n    a_array = np.array(a, dtype=np.float64)\n    b_array = np.array(b, dtype=np.float64)\n    return np.dot(a_array, b_array) / (np.linalg.norm(a_array) * np.linalg.norm(b_array))\n\n\nasync def do_ai(\n    user_prompt: str,\n    system_prompt: str,\n    result_type: type[T] | Annotated,\n    deps=None,\n) -&gt; T:\n    agent = Agent(\n        DEFAULT_LLM_MODEL,\n        system_prompt=system_prompt,\n        result_type=result_type,\n    )\n    result = await agent.run(user_prompt, deps=deps)\n    return result.data\n\n\n@dataclass\nclass Deps:\n    openai: AsyncOpenAI\n    pool: asyncpg.Pool\n\n\nasync def get_db_pool() -&gt; asyncpg.Pool:\n    async def init(conn):\n        await conn.execute(\"CREATE EXTENSION IF NOT EXISTS vector;\")\n        await register_vector(conn)\n\n    pool = await asyncpg.create_pool(DB_DSN, init=init)\n    return pool\n\n\nclass MemoryNode(BaseModel):\n    id: int | None = None\n    content: str\n    summary: str = \"\"\n    importance: float = 1.0\n    access_count: int = 0\n    timestamp: float = Field(default_factory=lambda: datetime.now(timezone.utc).timestamp())\n    embedding: list[float]\n\n    @classmethod\n    async def from_content(cls, content: str, deps: Deps):\n        embedding = await get_embedding(content, deps)\n        return cls(content=content, embedding=embedding)\n\n    async def save(self, deps: Deps):\n        async with deps.pool.acquire() as conn:\n            if self.id is None:\n                result = await conn.fetchrow(\n                    \"\"\"\n                    INSERT INTO memories (content, summary, importance, access_count,\n                        timestamp, embedding)\n                    VALUES ($1, $2, $3, $4, $5, $6)\n                    RETURNING id\n                    \"\"\",\n                    self.content,\n                    self.summary,\n                    self.importance,\n                    self.access_count,\n                    self.timestamp,\n                    self.embedding,\n                )\n                self.id = result[\"id\"]\n            else:\n                await conn.execute(\n                    \"\"\"\n                    UPDATE memories\n                    SET content = $1, summary = $2, importance = $3,\n                        access_count = $4, timestamp = $5, embedding = $6\n                    WHERE id = $7\n                    \"\"\",\n                    self.content,\n                    self.summary,\n                    self.importance,\n                    self.access_count,\n                    self.timestamp,\n                    self.embedding,\n                    self.id,\n                )\n\n    async def merge_with(self, other: Self, deps: Deps):\n        self.content = await do_ai(\n            f\"{self.content}\\n\\n{other.content}\",\n            \"Combine the following two texts into a single, coherent text.\",\n            str,\n            deps,\n        )\n        self.importance += other.importance\n        self.access_count += other.access_count\n        self.embedding = [(a + b) / 2 for a, b in zip(self.embedding, other.embedding)]\n        self.summary = await do_ai(self.content, \"Summarize the following text concisely.\", str, deps)\n        await self.save(deps)\n        # Delete the merged node from the database\n        if other.id is not None:\n            await delete_memory(other.id, deps)\n\n    def get_effective_importance(self):\n        return self.importance * (1 + math.log(self.access_count + 1))\n\n\nasync def get_embedding(text: str, deps: Deps) -&gt; list[float]:\n    embedding_response = await deps.openai.embeddings.create(\n        input=text,\n        model=DEFAULT_EMBEDDING_MODEL,\n    )\n    return embedding_response.data[0].embedding\n\n\nasync def delete_memory(memory_id: int, deps: Deps):\n    async with deps.pool.acquire() as conn:\n        await conn.execute(\"DELETE FROM memories WHERE id = $1\", memory_id)\n\n\nasync def add_memory(content: str, deps: Deps):\n    new_memory = await MemoryNode.from_content(content, deps)\n    await new_memory.save(deps)\n\n    similar_memories = await find_similar_memories(new_memory.embedding, deps)\n    for memory in similar_memories:\n        if memory.id != new_memory.id:\n            await new_memory.merge_with(memory, deps)\n\n    await update_importance(new_memory.embedding, deps)\n\n    await prune_memories(deps)\n\n    return f\"Remembered: {content}\"\n\n\nasync def find_similar_memories(embedding: list[float], deps: Deps) -&gt; list[MemoryNode]:\n    async with deps.pool.acquire() as conn:\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT id, content, summary, importance, access_count, timestamp, embedding\n            FROM memories\n            ORDER BY embedding &lt;-&gt; $1\n            LIMIT 5\n            \"\"\",\n            embedding,\n        )\n    memories = [\n        MemoryNode(\n            id=row[\"id\"],\n            content=row[\"content\"],\n            summary=row[\"summary\"],\n            importance=row[\"importance\"],\n            access_count=row[\"access_count\"],\n            timestamp=row[\"timestamp\"],\n            embedding=row[\"embedding\"],\n        )\n        for row in rows\n    ]\n    return memories\n\n\nasync def update_importance(user_embedding: list[float], deps: Deps):\n    async with deps.pool.acquire() as conn:\n        rows = await conn.fetch(\"SELECT id, importance, access_count, embedding FROM memories\")\n        for row in rows:\n            memory_embedding = row[\"embedding\"]\n            similarity = cosine_similarity(user_embedding, memory_embedding)\n            if similarity &gt; SIMILARITY_THRESHOLD:\n                new_importance = row[\"importance\"] * REINFORCEMENT_FACTOR\n                new_access_count = row[\"access_count\"] + 1\n            else:\n                new_importance = row[\"importance\"] * DECAY_FACTOR\n                new_access_count = row[\"access_count\"]\n            await conn.execute(\n                \"\"\"\n                UPDATE memories\n                SET importance = $1, access_count = $2\n                WHERE id = $3\n                \"\"\",\n                new_importance,\n                new_access_count,\n                row[\"id\"],\n            )\n\n\nasync def prune_memories(deps: Deps):\n    async with deps.pool.acquire() as conn:\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT id, importance, access_count\n            FROM memories\n            ORDER BY importance DESC\n            OFFSET $1\n            \"\"\",\n            MAX_DEPTH,\n        )\n        for row in rows:\n            await conn.execute(\"DELETE FROM memories WHERE id = $1\", row[\"id\"])\n\n\nasync def display_memory_tree(deps: Deps) -&gt; str:\n    async with deps.pool.acquire() as conn:\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT content, summary, importance, access_count\n            FROM memories\n            ORDER BY importance DESC\n            LIMIT $1\n            \"\"\",\n            MAX_DEPTH,\n        )\n    result = \"\"\n    for row in rows:\n        effective_importance = row[\"importance\"] * (1 + math.log(row[\"access_count\"] + 1))\n        summary = row[\"summary\"] or row[\"content\"]\n        result += f\"- {summary} (Importance: {effective_importance:.2f})\\n\"\n    return result\n\n\n@mcp.tool()\nasync def remember(\n    contents: list[str] = Field(description=\"List of observations or memories to store\"),\n):\n    deps = Deps(openai=AsyncOpenAI(), pool=await get_db_pool())\n    try:\n        return \"\\n\".join(await asyncio.gather(*[add_memory(content, deps) for content in contents]))\n    finally:\n        await deps.pool.close()\n\n\n@mcp.tool()\nasync def read_profile() -&gt; str:\n    deps = Deps(openai=AsyncOpenAI(), pool=await get_db_pool())\n    profile = await display_memory_tree(deps)\n    await deps.pool.close()\n    return profile\n\n\nasync def initialize_database():\n    pool = await asyncpg.create_pool(\"postgresql://postgres:postgres@localhost:54320/postgres\")\n    try:\n        async with pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                SELECT pg_terminate_backend(pg_stat_activity.pid)\n                FROM pg_stat_activity\n                WHERE pg_stat_activity.datname = 'memory_db'\n                AND pid &lt;&gt; pg_backend_pid();\n            \"\"\")\n            await conn.execute(\"DROP DATABASE IF EXISTS memory_db;\")\n            await conn.execute(\"CREATE DATABASE memory_db;\")\n    finally:\n        await pool.close()\n\n    pool = await asyncpg.create_pool(DB_DSN)\n    try:\n        async with pool.acquire() as conn:\n            await conn.execute(\"CREATE EXTENSION IF NOT EXISTS vector;\")\n\n            await register_vector(conn)\n\n            await conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS memories (\n                    id SERIAL PRIMARY KEY,\n                    content TEXT NOT NULL,\n                    summary TEXT,\n                    importance REAL NOT NULL,\n                    access_count INT NOT NULL,\n                    timestamp DOUBLE PRECISION NOT NULL,\n                    embedding vector(1536) NOT NULL\n                );\n                CREATE INDEX IF NOT EXISTS idx_memories_embedding ON memories\n                    USING hnsw (embedding vector_l2_ops);\n            \"\"\")\n    finally:\n        await pool.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(initialize_database())\n</code></pre> <p>This example shows how to:</p> <ul> <li>Implement persistent memory across requests</li> <li>Store and retrieve conversational context</li> <li>Handle memory cleanup and management</li> <li>Provide memory resources to LLMs</li> </ul>"},{"location":"examples-server-tools/","title":"Server tools examples","text":"<p>Tools are functions that LLMs can call to perform actions or computations. This section demonstrates various tool patterns and capabilities.</p>"},{"location":"examples-server-tools/#basic-tools","title":"Basic tools","text":"<p>Simple tools that perform computations and return results:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(name=\"Tool Example\")\n\n\n@mcp.tool()\ndef sum(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n\n@mcp.tool()\ndef get_weather(city: str, unit: str = \"celsius\") -&gt; str:\n    \"\"\"Get weather for a city.\"\"\"\n    # This would normally call a weather API\n    return f\"Weather in {city}: 22degrees{unit[0].upper()}\"\n</code></pre>"},{"location":"examples-server-tools/#tools-with-context-and-progress-reporting","title":"Tools with context and progress reporting","text":"<p>Tools can access MCP context for logging, progress reporting, and other capabilities:</p> <pre><code>from mcp.server.fastmcp import Context, FastMCP\nfrom mcp.server.session import ServerSession\n\nmcp = FastMCP(name=\"Progress Example\")\n\n\n@mcp.tool()\nasync def long_running_task(task_name: str, ctx: Context[ServerSession, None], steps: int = 5) -&gt; str:\n    \"\"\"Execute a task with progress updates.\"\"\"\n    await ctx.info(f\"Starting: {task_name}\")\n\n    for i in range(steps):\n        progress = (i + 1) / steps\n        await ctx.report_progress(\n            progress=progress,\n            total=1.0,\n            message=f\"Step {i + 1}/{steps}\",\n        )\n        await ctx.debug(f\"Completed step {i + 1}\")\n\n    return f\"Task '{task_name}' completed\"\n</code></pre> <p>This example shows:</p> <ul> <li>Using the <code>Context</code> parameter for MCP capabilities</li> <li>Progress reporting during long-running operations</li> <li>Structured logging at different levels</li> <li>Async tool functions</li> </ul>"},{"location":"examples-server-tools/#complex-input-handling","title":"Complex input handling","text":"<p>Tools can handle complex data structures and validation:</p> <pre><code>\"\"\"\nFastMCP Complex inputs Example\n\nDemonstrates validation via pydantic with complex models.\n\"\"\"\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"Shrimp Tank\")\n\n\nclass ShrimpTank(BaseModel):\n    class Shrimp(BaseModel):\n        name: Annotated[str, Field(max_length=10)]\n\n    shrimp: list[Shrimp]\n\n\n@mcp.tool()\ndef name_shrimp(\n    tank: ShrimpTank,\n    # You can use pydantic Field in function signatures for validation.\n    extra_names: Annotated[list[str], Field(max_length=10)],\n) -&gt; list[str]:\n    \"\"\"List all shrimp names in the tank\"\"\"\n    return [shrimp.name for shrimp in tank.shrimp] + extra_names\n</code></pre>"},{"location":"examples-server-tools/#parameter-descriptions","title":"Parameter descriptions","text":"<p>Tools with detailed parameter descriptions and validation:</p> <pre><code>\"\"\"\nFastMCP Example showing parameter descriptions\n\"\"\"\n\nfrom pydantic import Field\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Parameter Descriptions Server\")\n\n\n@mcp.tool()\ndef greet_user(\n    name: str = Field(description=\"The name of the person to greet\"),\n    title: str = Field(description=\"Optional title like Mr/Ms/Dr\", default=\"\"),\n    times: int = Field(description=\"Number of times to repeat the greeting\", default=1),\n) -&gt; str:\n    \"\"\"Greet a user with optional title and repetition\"\"\"\n    greeting = f\"Hello {title + ' ' if title else ''}{name}!\"\n    return \"\\n\".join([greeting] * times)\n</code></pre>"},{"location":"examples-server-tools/#unicode-and-internationalization","title":"Unicode and internationalization","text":"<p>Handling Unicode and international text in tools:</p> <pre><code>\"\"\"\nExample FastMCP server that uses Unicode characters in various places to help test\nUnicode handling in tools and inspectors.\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP()\n\n\n@mcp.tool(description=\"\ud83c\udf1f A tool that uses various Unicode characters in its description: \u00e1 \u00e9 \u00ed \u00f3 \u00fa \u00f1 \u6f22\u5b57 \ud83c\udf89\")\ndef hello_unicode(name: str = \"\u4e16\u754c\", greeting: str = \"\u00a1Hola\") -&gt; str:\n    \"\"\"\n    A simple tool that demonstrates Unicode handling in:\n    - Tool description (emojis, accents, CJK characters)\n    - Parameter defaults (CJK characters)\n    - Return values (Spanish punctuation, emojis)\n    \"\"\"\n    return f\"{greeting}, {name}! \ud83d\udc4b\"\n\n\n@mcp.tool(description=\"\ud83c\udfa8 Tool that returns a list of emoji categories\")\ndef list_emoji_categories() -&gt; list[str]:\n    \"\"\"Returns a list of emoji categories with emoji examples.\"\"\"\n    return [\n        \"\ud83d\ude00 Smileys &amp; Emotion\",\n        \"\ud83d\udc4b People &amp; Body\",\n        \"\ud83d\udc36 Animals &amp; Nature\",\n        \"\ud83c\udf4e Food &amp; Drink\",\n        \"\u26bd Activities\",\n        \"\ud83c\udf0d Travel &amp; Places\",\n        \"\ud83d\udca1 Objects\",\n        \"\u2764\ufe0f Symbols\",\n        \"\ud83d\udea9 Flags\",\n    ]\n\n\n@mcp.tool(description=\"\ud83d\udd24 Tool that returns text in different scripts\")\ndef multilingual_hello() -&gt; str:\n    \"\"\"Returns hello in different scripts and writing systems.\"\"\"\n    return \"\\n\".join(\n        [\n            \"English: Hello!\",\n            \"Spanish: \u00a1Hola!\",\n            \"French: Bonjour!\",\n            \"German: Gr\u00fc\u00df Gott!\",\n            \"Russian: \u041f\u0440\u0438\u0432\u0435\u0442!\",\n            \"Greek: \u0393\u03b5\u03b9\u03b1 \u03c3\u03b1\u03c2!\",\n            \"Hebrew: !\u05e9\u05b8\u05c1\u05dc\u05d5\u05b9\u05dd\",\n            \"Arabic: !\u0645\u0631\u062d\u0628\u0627\",\n            \"Hindi: \u0928\u092e\u0938\u094d\u0924\u0947!\",\n            \"Chinese: \u4f60\u597d!\",\n            \"Japanese: \u3053\u3093\u306b\u3061\u306f!\",\n            \"Korean: \uc548\ub155\ud558\uc138\uc694!\",\n            \"Thai: \u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35!\",\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"examples-server-tools/#desktop-integration","title":"Desktop integration","text":"<p>Tools that interact with the desktop environment:</p> <pre><code>\"\"\"\nFastMCP Desktop Example\n\nA simple example that exposes the desktop directory as a resource.\n\"\"\"\n\nfrom pathlib import Path\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create server\nmcp = FastMCP(\"Demo\")\n\n\n@mcp.resource(\"dir://desktop\")\ndef desktop() -&gt; list[str]:\n    \"\"\"List the files in the user's desktop\"\"\"\n    desktop = Path.home() / \"Desktop\"\n    return [str(f) for f in desktop.iterdir()]\n\n\n@mcp.tool()\ndef sum(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n</code></pre>"},{"location":"examples-server-tools/#screenshot-tools","title":"Screenshot tools","text":"<p>Tools for taking and processing screenshots:</p> <pre><code>\"\"\"\nFastMCP Screenshot Example\n\nGive Claude a tool to capture and view screenshots.\n\"\"\"\n\nimport io\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.server.fastmcp.utilities.types import Image\n\n# Create server\nmcp = FastMCP(\"Screenshot Demo\", dependencies=[\"pyautogui\", \"Pillow\"])\n\n\n@mcp.tool()\ndef take_screenshot() -&gt; Image:\n    \"\"\"\n    Take a screenshot of the user's screen and return it as an image. Use\n    this tool anytime the user wants you to look at something they're doing.\n    \"\"\"\n    import pyautogui\n\n    buffer = io.BytesIO()\n\n    # if the file exceeds ~1MB, it will be rejected by Claude\n    screenshot = pyautogui.screenshot()\n    screenshot.convert(\"RGB\").save(buffer, format=\"JPEG\", quality=60, optimize=True)\n    return Image(data=buffer.getvalue(), format=\"jpeg\")\n</code></pre>"},{"location":"examples-server-tools/#text-messaging-tool","title":"Text messaging tool","text":"<p>Tool to send a text message.</p> <pre><code># /// script\n# dependencies = []\n# ///\n\n\"\"\"\nFastMCP Text Me Server\n--------------------------------\nThis defines a simple FastMCP server that sends a text message to a phone number via https://surgemsg.com/.\n\nTo run this example, create a `.env` file with the following values:\n\nSURGE_API_KEY=...\nSURGE_ACCOUNT_ID=...\nSURGE_MY_PHONE_NUMBER=...\nSURGE_MY_FIRST_NAME=...\nSURGE_MY_LAST_NAME=...\n\nVisit https://surgemsg.com/ and click \"Get Started\" to obtain these values.\n\"\"\"\n\nfrom typing import Annotated\n\nimport httpx\nfrom pydantic import BeforeValidator\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nfrom mcp.server.fastmcp import FastMCP\n\n\nclass SurgeSettings(BaseSettings):\n    model_config: SettingsConfigDict = SettingsConfigDict(env_prefix=\"SURGE_\", env_file=\".env\")\n\n    api_key: str\n    account_id: str\n    my_phone_number: Annotated[str, BeforeValidator(lambda v: \"+\" + v if not v.startswith(\"+\") else v)]\n    my_first_name: str\n    my_last_name: str\n\n\n# Create server\nmcp = FastMCP(\"Text me\")\nsurge_settings = SurgeSettings()  # type: ignore\n\n\n@mcp.tool(name=\"textme\", description=\"Send a text message to me\")\ndef text_me(text_content: str) -&gt; str:\n    \"\"\"Send a text message to a phone number via https://surgemsg.com/\"\"\"\n    with httpx.Client() as client:\n        response = client.post(\n            \"https://api.surgemsg.com/messages\",\n            headers={\n                \"Authorization\": f\"Bearer {surge_settings.api_key}\",\n                \"Surge-Account\": surge_settings.account_id,\n                \"Content-Type\": \"application/json\",\n            },\n            json={\n                \"body\": text_content,\n                \"conversation\": {\n                    \"contact\": {\n                        \"first_name\": surge_settings.my_first_name,\n                        \"last_name\": surge_settings.my_last_name,\n                        \"phone_number\": surge_settings.my_phone_number,\n                    }\n                },\n            },\n        )\n        response.raise_for_status()\n        return f\"Message sent: {text_content}\"\n</code></pre>"},{"location":"examples-structured-output/","title":"Structured output examples","text":"<p>Structured output allows tools to return well-typed, validated data that clients can easily process. This section covers various approaches to structured data.</p> <p>Structured output provides several advantages:</p> <ul> <li>Type Safety: Automatic validation ensures data integrity</li> <li>Documentation: Schemas serve as API documentation</li> <li>Client Integration: Easier processing by client applications</li> <li>Backward Compatibility: Still provides unstructured text content</li> <li>IDE Support: Better development experience with type hints</li> </ul> <p>Choose structured output when you need reliable, processable data from your tools.</p>"},{"location":"examples-structured-output/#fastmcp-structured-output","title":"FastMCP structured output","text":"<p>Using FastMCP's automatic structured output capabilities:</p> <pre><code>\"\"\"Example showing structured output with tools.\"\"\"\n\nfrom typing import TypedDict\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"Structured Output Example\")\n\n\n# Using Pydantic models for rich structured data\nclass WeatherData(BaseModel):\n    \"\"\"Weather information structure.\"\"\"\n\n    temperature: float = Field(description=\"Temperature in Celsius\")\n    humidity: float = Field(description=\"Humidity percentage\")\n    condition: str\n    wind_speed: float\n\n\n@mcp.tool()\ndef get_weather(city: str) -&gt; WeatherData:\n    \"\"\"Get weather for a city - returns structured data.\"\"\"\n    # Simulated weather data\n    return WeatherData(\n        temperature=72.5,\n        humidity=45.0,\n        condition=\"sunny\",\n        wind_speed=5.2,\n    )\n\n\n# Using TypedDict for simpler structures\nclass LocationInfo(TypedDict):\n    latitude: float\n    longitude: float\n    name: str\n\n\n@mcp.tool()\ndef get_location(address: str) -&gt; LocationInfo:\n    \"\"\"Get location coordinates\"\"\"\n    return LocationInfo(latitude=51.5074, longitude=-0.1278, name=\"London, UK\")\n\n\n# Using dict[str, Any] for flexible schemas\n@mcp.tool()\ndef get_statistics(data_type: str) -&gt; dict[str, float]:\n    \"\"\"Get various statistics\"\"\"\n    return {\"mean\": 42.5, \"median\": 40.0, \"std_dev\": 5.2}\n\n\n# Ordinary classes with type hints work for structured output\nclass UserProfile:\n    name: str\n    age: int\n    email: str | None = None\n\n    def __init__(self, name: str, age: int, email: str | None = None):\n        self.name = name\n        self.age = age\n        self.email = email\n\n\n@mcp.tool()\ndef get_user(user_id: str) -&gt; UserProfile:\n    \"\"\"Get user profile - returns structured data\"\"\"\n    return UserProfile(name=\"Alice\", age=30, email=\"alice@example.com\")\n\n\n# Classes WITHOUT type hints cannot be used for structured output\nclass UntypedConfig:\n    def __init__(self, setting1, setting2):  # type: ignore[reportMissingParameterType]\n        self.setting1 = setting1\n        self.setting2 = setting2\n\n\n@mcp.tool()\ndef get_config() -&gt; UntypedConfig:\n    \"\"\"This returns unstructured output - no schema generated\"\"\"\n    return UntypedConfig(\"value1\", \"value2\")\n\n\n# Lists and other types are wrapped automatically\n@mcp.tool()\ndef list_cities() -&gt; list[str]:\n    \"\"\"Get a list of cities\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]\n    # Returns: {\"result\": [\"London\", \"Paris\", \"Tokyo\"]}\n\n\n@mcp.tool()\ndef get_temperature(city: str) -&gt; float:\n    \"\"\"Get temperature as a simple float\"\"\"\n    return 22.5\n    # Returns: {\"result\": 22.5}\n</code></pre> <p>This comprehensive example demonstrates:</p> <ul> <li>Pydantic models: Rich validation and documentation (<code>WeatherData</code>)</li> <li>TypedDict: Simpler structures (<code>LocationInfo</code>)</li> <li>Dictionary types: Flexible schemas (<code>dict[str, float]</code>)</li> <li>Regular classes: With type hints for structured output (<code>UserProfile</code>)</li> <li>Untyped classes: Fall back to unstructured output (<code>UntypedConfig</code>)</li> <li>Primitive wrapping: Simple types wrapped in <code>{\"result\": value}</code></li> </ul>"},{"location":"examples-structured-output/#weather-service-with-structured-output","title":"Weather service with structured output","text":"<p>A complete weather service demonstrating real-world structured output patterns:</p> <pre><code>\"\"\"\nFastMCP Weather Example with Structured Output\n\nDemonstrates how to use structured output with tools to return\nwell-typed, validated data that clients can easily process.\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import TypedDict\n\nfrom pydantic import BaseModel, Field\n\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import create_connected_server_and_client_session as client_session\n\n# Create server\nmcp = FastMCP(\"Weather Service\")\n\n\n# Example 1: Using a Pydantic model for structured output\nclass WeatherData(BaseModel):\n    \"\"\"Structured weather data response\"\"\"\n\n    temperature: float = Field(description=\"Temperature in Celsius\")\n    humidity: float = Field(description=\"Humidity percentage (0-100)\")\n    condition: str = Field(description=\"Weather condition (sunny, cloudy, rainy, etc.)\")\n    wind_speed: float = Field(description=\"Wind speed in km/h\")\n    location: str = Field(description=\"Location name\")\n    timestamp: datetime = Field(default_factory=datetime.now, description=\"Observation time\")\n\n\n@mcp.tool()\ndef get_weather(city: str) -&gt; WeatherData:\n    \"\"\"Get current weather for a city with full structured data\"\"\"\n    # In a real implementation, this would fetch from a weather API\n    return WeatherData(temperature=22.5, humidity=65.0, condition=\"partly cloudy\", wind_speed=12.3, location=city)\n\n\n# Example 2: Using TypedDict for a simpler structure\nclass WeatherSummary(TypedDict):\n    \"\"\"Simple weather summary\"\"\"\n\n    city: str\n    temp_c: float\n    description: str\n\n\n@mcp.tool()\ndef get_weather_summary(city: str) -&gt; WeatherSummary:\n    \"\"\"Get a brief weather summary for a city\"\"\"\n    return WeatherSummary(city=city, temp_c=22.5, description=\"Partly cloudy with light breeze\")\n\n\n# Example 3: Using dict[str, Any] for flexible schemas\n@mcp.tool()\ndef get_weather_metrics(cities: list[str]) -&gt; dict[str, dict[str, float]]:\n    \"\"\"Get weather metrics for multiple cities\n\n    Returns a dictionary mapping city names to their metrics\n    \"\"\"\n    # Returns nested dictionaries with weather metrics\n    return {\n        city: {\"temperature\": 20.0 + i * 2, \"humidity\": 60.0 + i * 5, \"pressure\": 1013.0 + i * 0.5}\n        for i, city in enumerate(cities)\n    }\n\n\n# Example 4: Using dataclass for weather alerts\n@dataclass\nclass WeatherAlert:\n    \"\"\"Weather alert information\"\"\"\n\n    severity: str  # \"low\", \"medium\", \"high\"\n    title: str\n    description: str\n    affected_areas: list[str]\n    valid_until: datetime\n\n\n@mcp.tool()\ndef get_weather_alerts(region: str) -&gt; list[WeatherAlert]:\n    \"\"\"Get active weather alerts for a region\"\"\"\n    # In production, this would fetch real alerts\n    if region.lower() == \"california\":\n        return [\n            WeatherAlert(\n                severity=\"high\",\n                title=\"Heat Wave Warning\",\n                description=\"Temperatures expected to exceed 40 degrees\",\n                affected_areas=[\"Los Angeles\", \"San Diego\", \"Riverside\"],\n                valid_until=datetime(2024, 7, 15, 18, 0),\n            ),\n            WeatherAlert(\n                severity=\"medium\",\n                title=\"Air Quality Advisory\",\n                description=\"Poor air quality due to wildfire smoke\",\n                affected_areas=[\"San Francisco Bay Area\"],\n                valid_until=datetime(2024, 7, 14, 12, 0),\n            ),\n        ]\n    return []\n\n\n# Example 5: Returning primitives with structured output\n@mcp.tool()\ndef get_temperature(city: str, unit: str = \"celsius\") -&gt; float:\n    \"\"\"Get just the temperature for a city\n\n    When returning primitives as structured output,\n    the result is wrapped in {\"result\": value}\n    \"\"\"\n    base_temp = 22.5\n    if unit.lower() == \"fahrenheit\":\n        return base_temp * 9 / 5 + 32\n    return base_temp\n\n\n# Example 6: Weather statistics with nested models\nclass DailyStats(BaseModel):\n    \"\"\"Statistics for a single day\"\"\"\n\n    high: float\n    low: float\n    mean: float\n\n\nclass WeatherStats(BaseModel):\n    \"\"\"Weather statistics over a period\"\"\"\n\n    location: str\n    period_days: int\n    temperature: DailyStats\n    humidity: DailyStats\n    precipitation_mm: float = Field(description=\"Total precipitation in millimeters\")\n\n\n@mcp.tool()\ndef get_weather_stats(city: str, days: int = 7) -&gt; WeatherStats:\n    \"\"\"Get weather statistics for the past N days\"\"\"\n    return WeatherStats(\n        location=city,\n        period_days=days,\n        temperature=DailyStats(high=28.5, low=15.2, mean=21.8),\n        humidity=DailyStats(high=85.0, low=45.0, mean=65.0),\n        precipitation_mm=12.4,\n    )\n\n\nif __name__ == \"__main__\":\n\n    async def test() -&gt; None:\n        \"\"\"Test the tools by calling them through the server as a client would\"\"\"\n        print(\"Testing Weather Service Tools (via MCP protocol)\\n\")\n        print(\"=\" * 80)\n\n        async with client_session(mcp._mcp_server) as client:\n            # Test get_weather\n            result = await client.call_tool(\"get_weather\", {\"city\": \"London\"})\n            print(\"\\nWeather in London:\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Test get_weather_summary\n            result = await client.call_tool(\"get_weather_summary\", {\"city\": \"Paris\"})\n            print(\"\\nWeather summary for Paris:\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Test get_weather_metrics\n            result = await client.call_tool(\"get_weather_metrics\", {\"cities\": [\"Tokyo\", \"Sydney\", \"Mumbai\"]})\n            print(\"\\nWeather metrics:\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Test get_weather_alerts\n            result = await client.call_tool(\"get_weather_alerts\", {\"region\": \"California\"})\n            print(\"\\nWeather alerts for California:\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Test get_temperature\n            result = await client.call_tool(\"get_temperature\", {\"city\": \"Berlin\", \"unit\": \"fahrenheit\"})\n            print(\"\\nTemperature in Berlin:\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Test get_weather_stats\n            result = await client.call_tool(\"get_weather_stats\", {\"city\": \"Seattle\", \"days\": 30})\n            print(\"\\nWeather stats for Seattle (30 days):\")\n            print(json.dumps(result.structuredContent, indent=2))\n\n            # Also show the text content for comparison\n            print(\"\\nText content for last result:\")\n            for content in result.content:\n                if content.type == \"text\":\n                    print(content.text)\n\n    async def print_schemas() -&gt; None:\n        \"\"\"Print all tool schemas\"\"\"\n        print(\"Tool Schemas for Weather Service\\n\")\n        print(\"=\" * 80)\n\n        tools = await mcp.list_tools()\n        for tool in tools:\n            print(f\"\\nTool: {tool.name}\")\n            print(f\"Description: {tool.description}\")\n            print(\"Input Schema:\")\n            print(json.dumps(tool.inputSchema, indent=2))\n\n            if tool.outputSchema:\n                print(\"Output Schema:\")\n                print(json.dumps(tool.outputSchema, indent=2))\n            else:\n                print(\"Output Schema: None (returns unstructured content)\")\n\n            print(\"-\" * 80)\n\n    # Check command line arguments\n    if len(sys.argv) &gt; 1 and sys.argv[1] == \"--schemas\":\n        asyncio.run(print_schemas())\n    else:\n        print(\"Usage:\")\n        print(\"  python weather_structured.py          # Run tool tests\")\n        print(\"  python weather_structured.py --schemas # Print tool schemas\")\n        print()\n        asyncio.run(test())\n</code></pre> <p>This extensive example shows:</p> <ul> <li>Nested Pydantic models: Complex data structures with validation</li> <li>Multiple output formats: Different approaches for different use cases</li> <li>Dataclass support: Using dataclasses for structured output</li> <li>Production patterns: Realistic data structures for weather APIs</li> <li>Testing integration: Built-in testing via MCP protocol</li> </ul>"},{"location":"examples-structured-output/#low-level-structured-output","title":"Low-level structured output","text":"<p>Using the low-level server API for maximum control:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/lowlevel/structured_output.py\n\"\"\"\n\nimport asyncio\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\nserver = Server(\"example-server\")\n\n\n@server.list_tools()\nasync def list_tools() -&gt; list[types.Tool]:\n    \"\"\"List available tools with structured output schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\", \"description\": \"Temperature in Celsius\"},\n                    \"condition\": {\"type\": \"string\", \"description\": \"Weather condition\"},\n                    \"humidity\": {\"type\": \"number\", \"description\": \"Humidity percentage\"},\n                    \"city\": {\"type\": \"string\", \"description\": \"City name\"},\n                },\n                \"required\": [\"temperature\", \"condition\", \"humidity\", \"city\"],\n            },\n        )\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Handle tool calls with structured output.\"\"\"\n    if name == \"get_weather\":\n        city = arguments[\"city\"]\n\n        # Simulated weather data - in production, call a weather API\n        weather_data = {\n            \"temperature\": 22.5,\n            \"condition\": \"partly cloudy\",\n            \"humidity\": 65,\n            \"city\": city,  # Include the requested city\n        }\n\n        # low-level server will validate structured output against the tool's\n        # output schema, and additionally serialize it into a TextContent block\n        # for backwards compatibility with pre-2025-06-18 clients.\n        return weather_data\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\n\nasync def run():\n    \"\"\"Run the structured output server.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"structured-output-example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n</code></pre> <p>And a standalone low-level example:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nExample low-level MCP server demonstrating structured output support.\n\nThis example shows how to use the low-level server API to return\nstructured data from tools, with automatic validation against output\nschemas.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\n\nimport mcp.server.stdio\nimport mcp.types as types\nfrom mcp.server.lowlevel import NotificationOptions, Server\nfrom mcp.server.models import InitializationOptions\n\n# Create low-level server instance\nserver = Server(\"structured-output-lowlevel-example\")\n\n\n@server.list_tools()\nasync def list_tools() -&gt; list[types.Tool]:\n    \"\"\"List available tools with their schemas.\"\"\"\n    return [\n        types.Tool(\n            name=\"get_weather\",\n            description=\"Get weather information (simulated)\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\"city\": {\"type\": \"string\", \"description\": \"City name\"}},\n                \"required\": [\"city\"],\n            },\n            outputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"temperature\": {\"type\": \"number\"},\n                    \"conditions\": {\"type\": \"string\"},\n                    \"humidity\": {\"type\": \"integer\", \"minimum\": 0, \"maximum\": 100},\n                    \"wind_speed\": {\"type\": \"number\"},\n                    \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"},\n                },\n                \"required\": [\"temperature\", \"conditions\", \"humidity\", \"wind_speed\", \"timestamp\"],\n            },\n        ),\n    ]\n\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Handle tool call with structured output.\n    \"\"\"\n\n    if name == \"get_weather\":\n        # city = arguments[\"city\"]  # Would be used with real weather API\n\n        # Simulate weather data (in production, call a real weather API)\n        import random\n\n        weather_conditions = [\"sunny\", \"cloudy\", \"rainy\", \"partly cloudy\", \"foggy\"]\n\n        weather_data = {\n            \"temperature\": round(random.uniform(0, 35), 1),\n            \"conditions\": random.choice(weather_conditions),\n            \"humidity\": random.randint(30, 90),\n            \"wind_speed\": round(random.uniform(0, 30), 1),\n            \"timestamp\": datetime.now().isoformat(),\n        }\n\n        # Return structured data only\n        # The low-level server will serialize this to JSON content automatically\n        return weather_data\n\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\n\nasync def run():\n    \"\"\"Run the low-level server using stdio transport.\"\"\"\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"structured-output-lowlevel-example\",\n                server_version=\"0.1.0\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n</code></pre> <p>These examples demonstrate:</p> <ul> <li>Manual schema definition with <code>outputSchema</code></li> <li>Validation against defined schemas</li> <li>Returning structured data directly from tools</li> <li>Backward compatibility with unstructured content</li> </ul>"},{"location":"examples-transport-http/","title":"HTTP transport examples","text":"<p>HTTP transports enable web-based MCP server deployment with support for multiple clients and scalable architectures.</p> <p>Choose HTTP transports for production deployments that need to serve multiple clients or integrate with web infrastructure.</p>"},{"location":"examples-transport-http/#transport-comparison","title":"Transport comparison","text":"Feature Streamable HTTP SSE stdio Resumability \u2705 With event store \u274c \u274c Scalability \u2705 Multi-client \u2705 Multi-client \u274c Single process State Configurable Session-based Process-based Deployment Web servers Web servers Local execution Best for Production APIs Real-time updates Development/CLI"},{"location":"examples-transport-http/#streamable-http-configuration","title":"Streamable HTTP configuration","text":"<p>Basic streamable HTTP server setup with different configurations:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uv run examples/snippets/servers/streamable_config.py\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Stateful server (maintains session state)\nmcp = FastMCP(\"StatefulServer\")\n\n# Other configuration options:\n# Stateless server (no session persistence)\n# mcp = FastMCP(\"StatelessServer\", stateless_http=True)\n\n# Stateless server (no session persistence, no sse stream with supported client)\n# mcp = FastMCP(\"StatelessServer\", stateless_http=True, json_response=True)\n\n\n# Add a simple tool to demonstrate the server\n@mcp.tool()\ndef greet(name: str = \"World\") -&gt; str:\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"\n\n\n# Run server with streamable_http transport\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Stateful servers: Maintain session state (default)</li> <li>Stateless servers: No session persistence (<code>stateless_http=True</code>)</li> <li>JSON responses: Disable SSE streaming (<code>json_response=True</code>)</li> <li>Transport selection at runtime</li> </ul>"},{"location":"examples-transport-http/#mounting-multiple-servers","title":"Mounting multiple servers","text":"<p>Deploying multiple MCP servers in a single Starlette application:</p> <pre><code>\"\"\"\nRun from the repository root:\n    uvicorn examples.snippets.servers.streamable_starlette_mount:app --reload\n\"\"\"\n\nimport contextlib\n\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create the Echo server\necho_mcp = FastMCP(name=\"EchoServer\", stateless_http=True)\n\n\n@echo_mcp.tool()\ndef echo(message: str) -&gt; str:\n    \"\"\"A simple echo tool\"\"\"\n    return f\"Echo: {message}\"\n\n\n# Create the Math server\nmath_mcp = FastMCP(name=\"MathServer\", stateless_http=True)\n\n\n@math_mcp.tool()\ndef add_two(n: int) -&gt; int:\n    \"\"\"Tool to add two to the input\"\"\"\n    return n + 2\n\n\n# Create a combined lifespan to manage both session managers\n@contextlib.asynccontextmanager\nasync def lifespan(app: Starlette):\n    async with contextlib.AsyncExitStack() as stack:\n        await stack.enter_async_context(echo_mcp.session_manager.run())\n        await stack.enter_async_context(math_mcp.session_manager.run())\n        yield\n\n\n# Create the Starlette app and mount the MCP servers\napp = Starlette(\n    routes=[\n        Mount(\"/echo\", echo_mcp.streamable_http_app()),\n        Mount(\"/math\", math_mcp.streamable_http_app()),\n    ],\n    lifespan=lifespan,\n)\n</code></pre> <p>This pattern shows:</p> <ul> <li>Creating multiple FastMCP server instances</li> <li>Mounting servers at different paths (<code>/echo</code>, <code>/math</code>)</li> <li>Shared lifespan management across servers</li> <li>Combined session manager lifecycle</li> </ul>"},{"location":"examples-transport-http/#stateful-http-server","title":"Stateful HTTP server","text":"<p>Full low-level implementation of a stateful HTTP server:</p> <pre><code>import contextlib\nimport logging\nfrom collections.abc import AsyncIterator\nfrom typing import Any\n\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom pydantic import AnyUrl\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.types import Receive, Scope, Send\n\nfrom .event_store import InMemoryEventStore\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\n@click.command()\n@click.option(\"--port\", default=3000, help=\"Port to listen on for HTTP\")\n@click.option(\n    \"--log-level\",\n    default=\"INFO\",\n    help=\"Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n)\n@click.option(\n    \"--json-response\",\n    is_flag=True,\n    default=False,\n    help=\"Enable JSON responses instead of SSE streams\",\n)\ndef main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -&gt; int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            # Include more detailed message for resumability demonstration\n            notification_msg = f\"[{i + 1}/{count}] Event from '{caller}' - Use Last-Event-ID to resume if disconnected\"\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=notification_msg,\n                logger=\"notification_stream\",\n                # Associates this notification with the original request\n                # Ensures notifications are sent to the correct response stream\n                # Without this, notifications will either go to:\n                # - a standalone SSE stream (if GET request is supported)\n                # - nowhere (if GET request isn't supported)\n                related_request_id=ctx.request_id,\n            )\n            logger.debug(f\"Sent notification {i + 1}/{count} for caller: {caller}\")\n            if i &lt; count - 1:  # Don't wait after the last notification\n                await anyio.sleep(interval)\n\n        # This will send a resource notificaiton though standalone SSE\n        # established by GET request\n        await ctx.session.send_resource_updated(uri=AnyUrl(\"http:///test_resource\"))\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=(f\"Sent {count} notifications with {interval}s interval for caller: {caller}\"),\n            )\n        ]\n\n    @app.list_tools()\n    async def list_tools() -&gt; list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"start-notification-stream\",\n                description=(\"Sends a stream of notifications with configurable count and interval\"),\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"interval\", \"count\", \"caller\"],\n                    \"properties\": {\n                        \"interval\": {\n                            \"type\": \"number\",\n                            \"description\": \"Interval between notifications in seconds\",\n                        },\n                        \"count\": {\n                            \"type\": \"number\",\n                            \"description\": \"Number of notifications to send\",\n                        },\n                        \"caller\": {\n                            \"type\": \"string\",\n                            \"description\": (\"Identifier of the caller to include in notifications\"),\n                        },\n                    },\n                },\n            )\n        ]\n\n    # Create event store for resumability\n    # The InMemoryEventStore enables resumability support for StreamableHTTP transport.\n    # It stores SSE events with unique IDs, allowing clients to:\n    #   1. Receive event IDs for each SSE message\n    #   2. Resume streams by sending Last-Event-ID in GET requests\n    #   3. Replay missed events after reconnection\n    # Note: This in-memory implementation is for demonstration ONLY.\n    # For production, use a persistent storage solution.\n    event_store = InMemoryEventStore()\n\n    # Create the session manager with our app and event store\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        event_store=event_store,  # Enable resumability\n        json_response=json_response,\n    )\n\n    # ASGI handler for streamable HTTP connections\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        await session_manager.handle_request(scope, receive, send)\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -&gt; AsyncIterator[None]:\n        \"\"\"Context manager for managing session manager lifecycle.\"\"\"\n        async with session_manager.run():\n            logger.info(\"Application started with StreamableHTTP session manager!\")\n            try:\n                yield\n            finally:\n                logger.info(\"Application shutting down...\")\n\n    # Create an ASGI application using the transport\n    starlette_app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=handle_streamable_http),\n        ],\n        lifespan=lifespan,\n    )\n\n    import uvicorn\n\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n\n    return 0\n</code></pre> <p>This comprehensive example includes:</p> <ul> <li>Event store for resumability (reconnection support)</li> <li>Progress notifications and logging</li> <li>Resource change notifications</li> <li>Streaming tool execution with progress updates</li> <li>Production-ready ASGI integration</li> </ul>"},{"location":"examples-transport-http/#stateless-http-server","title":"Stateless HTTP server","text":"<p>Low-level stateless server for high-scale deployments:</p> <pre><code>import contextlib\nimport logging\nfrom collections.abc import AsyncIterator\nfrom typing import Any\n\nimport anyio\nimport click\nimport mcp.types as types\nfrom mcp.server.lowlevel import Server\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.types import Receive, Scope, Send\n\nlogger = logging.getLogger(__name__)\n\n\n@click.command()\n@click.option(\"--port\", default=3000, help=\"Port to listen on for HTTP\")\n@click.option(\n    \"--log-level\",\n    default=\"INFO\",\n    help=\"Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n)\n@click.option(\n    \"--json-response\",\n    is_flag=True,\n    default=False,\n    help=\"Enable JSON responses instead of SSE streams\",\n)\ndef main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -&gt; int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-stateless-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=f\"Notification {i + 1}/{count} from caller: {caller}\",\n                logger=\"notification_stream\",\n                related_request_id=ctx.request_id,\n            )\n            if i &lt; count - 1:  # Don't wait after the last notification\n                await anyio.sleep(interval)\n\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=(f\"Sent {count} notifications with {interval}s interval for caller: {caller}\"),\n            )\n        ]\n\n    @app.list_tools()\n    async def list_tools() -&gt; list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"start-notification-stream\",\n                description=(\"Sends a stream of notifications with configurable count and interval\"),\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"interval\", \"count\", \"caller\"],\n                    \"properties\": {\n                        \"interval\": {\n                            \"type\": \"number\",\n                            \"description\": \"Interval between notifications in seconds\",\n                        },\n                        \"count\": {\n                            \"type\": \"number\",\n                            \"description\": \"Number of notifications to send\",\n                        },\n                        \"caller\": {\n                            \"type\": \"string\",\n                            \"description\": (\"Identifier of the caller to include in notifications\"),\n                        },\n                    },\n                },\n            )\n        ]\n\n    # Create the session manager with true stateless mode\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        event_store=None,\n        json_response=json_response,\n        stateless=True,\n    )\n\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        await session_manager.handle_request(scope, receive, send)\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -&gt; AsyncIterator[None]:\n        \"\"\"Context manager for session manager.\"\"\"\n        async with session_manager.run():\n            logger.info(\"Application started with StreamableHTTP session manager!\")\n            try:\n                yield\n            finally:\n                logger.info(\"Application shutting down...\")\n\n    # Create an ASGI application using the transport\n    starlette_app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=handle_streamable_http),\n        ],\n        lifespan=lifespan,\n    )\n\n    import uvicorn\n\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n\n    return 0\n</code></pre> <p>Features of stateless design:</p> <ul> <li>No session state persistence</li> <li>Simplified architecture for load balancing</li> <li>Better horizontal scaling capabilities</li> <li>Each request is independent</li> </ul>"},{"location":"examples-transport-http/#event-store-implementation","title":"Event store implementation","text":"<p>Supporting resumable connections with event storage:</p> <pre><code>\"\"\"\nIn-memory event store for demonstrating resumability functionality.\n\nThis is a simple implementation intended for examples and testing,\nnot for production use where a persistent storage solution would be more appropriate.\n\"\"\"\n\nimport logging\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom uuid import uuid4\n\nfrom mcp.server.streamable_http import EventCallback, EventId, EventMessage, EventStore, StreamId\nfrom mcp.types import JSONRPCMessage\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass EventEntry:\n    \"\"\"\n    Represents an event entry in the event store.\n    \"\"\"\n\n    event_id: EventId\n    stream_id: StreamId\n    message: JSONRPCMessage\n\n\nclass InMemoryEventStore(EventStore):\n    \"\"\"\n    Simple in-memory implementation of the EventStore interface for resumability.\n    This is primarily intended for examples and testing, not for production use\n    where a persistent storage solution would be more appropriate.\n\n    This implementation keeps only the last N events per stream for memory efficiency.\n    \"\"\"\n\n    def __init__(self, max_events_per_stream: int = 100):\n        \"\"\"Initialize the event store.\n\n        Args:\n            max_events_per_stream: Maximum number of events to keep per stream\n        \"\"\"\n        self.max_events_per_stream = max_events_per_stream\n        # for maintaining last N events per stream\n        self.streams: dict[StreamId, deque[EventEntry]] = {}\n        # event_id -&gt; EventEntry for quick lookup\n        self.event_index: dict[EventId, EventEntry] = {}\n\n    async def store_event(self, stream_id: StreamId, message: JSONRPCMessage) -&gt; EventId:\n        \"\"\"Stores an event with a generated event ID.\"\"\"\n        event_id = str(uuid4())\n        event_entry = EventEntry(event_id=event_id, stream_id=stream_id, message=message)\n\n        # Get or create deque for this stream\n        if stream_id not in self.streams:\n            self.streams[stream_id] = deque(maxlen=self.max_events_per_stream)\n\n        # If deque is full, the oldest event will be automatically removed\n        # We need to remove it from the event_index as well\n        if len(self.streams[stream_id]) == self.max_events_per_stream:\n            oldest_event = self.streams[stream_id][0]\n            self.event_index.pop(oldest_event.event_id, None)\n\n        # Add new event\n        self.streams[stream_id].append(event_entry)\n        self.event_index[event_id] = event_entry\n\n        return event_id\n\n    async def replay_events_after(\n        self,\n        last_event_id: EventId,\n        send_callback: EventCallback,\n    ) -&gt; StreamId | None:\n        \"\"\"Replays events that occurred after the specified event ID.\"\"\"\n        if last_event_id not in self.event_index:\n            logger.warning(f\"Event ID {last_event_id} not found in store\")\n            return None\n\n        # Get the stream and find events after the last one\n        last_event = self.event_index[last_event_id]\n        stream_id = last_event.stream_id\n        stream_events = self.streams.get(last_event.stream_id, deque())\n\n        # Events in deque are already in chronological order\n        found_last = False\n        for event in stream_events:\n            if found_last:\n                await send_callback(EventMessage(event.message, event.event_id))\n            elif event.event_id == last_event_id:\n                found_last = True\n\n        return stream_id\n</code></pre> <p>This component enables:</p> <ul> <li>Client reconnection with <code>Last-Event-ID</code> headers</li> <li>Event replay for missed messages</li> <li>Persistent streaming across connection interruptions</li> <li>Production-ready resumability patterns</li> </ul>"},{"location":"reference/mcp/","title":"mcp","text":"<p>An implementation of the Model Context Protocol (MCP) specification in Python.</p> <p>Use the MCP Python SDK to:</p> <ul> <li>Build MCP clients that can connect to any MCP server</li> <li>Build MCP servers that expose resources, prompts, and tools</li> <li>Use standard transports like stdio, SSE, and Streamable HTTP</li> <li>Handle MCP protocol messages and lifecycle events</li> </ul>"},{"location":"reference/mcp/#mcp--example-create-a-fastmcp-server","title":"Example - create a <code>FastMCP</code> server","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"Demo\")\n\n@mcp.tool()\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"reference/mcp/#mcp--example-create-a-client","title":"Example - create a client","text":"<pre><code>from mcp import ClientSession, StdioServerParameters, stdio_client\n\nserver_params = StdioServerParameters(\n    command=\"python\", args=[\"server.py\"]\n)\n\nasync with stdio_client(server_params) as (read, write):\n    async with ClientSession(read, write) as session:\n        await session.initialize()\n        tools = await session.list_tools()\n        result = await session.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n</code></pre>"},{"location":"reference/mcp/#mcp.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p>"},{"location":"reference/mcp/#mcp.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p>"},{"location":"reference/mcp/#mcp.ClientCapabilities.elicitation","title":"elicitation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elicitation: ElicitationCapability | None = None\n</code></pre> <p>Present if the client supports elicitation from the user.</p>"},{"location":"reference/mcp/#mcp.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"reference/mcp/#mcp.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"reference/mcp/#mcp.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM.</p>"},{"location":"reference/mcp/#mcp.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> <p>A client session for communicating with an MCP server.</p> <p>This class provides a high-level interface for MCP client operations, including tool calling, resource management, prompt handling, and protocol initialization. It manages the bidirectional communication channel with an MCP server and handles protocol-level concerns like message validation and capability negotiation.</p> <p>The session supports various MCP capabilities:</p> <ul> <li>Tool execution with structured output validation</li> <li>Resource access and subscription management</li> <li>Prompt template retrieval and completion</li> <li>Progress notifications and logging</li> <li>Custom sampling, elicitation, and root listing callbacks</li> </ul> <p>Parameters:</p> Name Type Description Default <code>read_stream</code> <code>MemoryObjectReceiveStream[SessionMessage | Exception]</code> <p>Stream for receiving messages from the server.</p> required <code>write_stream</code> <code>MemoryObjectSendStream[SessionMessage]</code> <p>Stream for sending messages to the server.</p> required <code>read_timeout_seconds</code> <code>timedelta | None</code> <p>Optional timeout for read operations.</p> <code>None</code> <code>sampling_callback</code> <code>SamplingFnT | None</code> <p>Optional callback for handling sampling requests from the server.</p> <code>None</code> <code>elicitation_callback</code> <code>ElicitationFnT | None</code> <p>Optional callback for handling elicitation requests from the server.</p> <code>None</code> <code>list_roots_callback</code> <code>ListRootsFnT | None</code> <p>Optional callback for handling root listing requests from the server.</p> <code>None</code> <code>logging_callback</code> <code>LoggingFnT | None</code> <p>Optional callback for handling log messages from the server.</p> <code>None</code> <code>message_handler</code> <code>MessageHandlerFnT | None</code> <p>Optional custom handler for incoming messages and exceptions.</p> <code>None</code> <code>client_info</code> <code>Implementation | None</code> <p>Optional client implementation information.</p> <code>None</code> Example <pre><code>async with create_client_session() as session:\n    # Initialize the session\n    await session.initialize()\n\n    # List available tools\n    tools = await session.list_tools()\n\n    # Call a tool\n    result = await session.call_tool(\"my_tool\", {\"arg\": \"value\"})\n</code></pre>"},{"location":"reference/mcp/#mcp.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; CallToolResult\n</code></pre> <p>Execute a tool on the connected MCP server.</p> <p>This method sends a tools/call request to execute a specific tool with provided arguments. The server will validate the arguments against the tool's input schema and return structured or unstructured content based on the tool's configuration.</p> <p>For tools that return structured output, the result will be automatically validated against the tool's output schema if one is defined. Tools may also return various content types including text, images, and embedded resources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool to execute. Must match a tool exposed by the server.</p> required <code>arguments</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of arguments to pass to the tool. The structure must match the tool's input schema. Defaults to None for tools that don't require arguments.</p> <code>None</code> <code>read_timeout_seconds</code> <code>timedelta | None</code> <p>Optional timeout for the tool execution. If not specified, uses the session's default read timeout. Useful for long-running tools.</p> <code>None</code> <code>progress_callback</code> <code>ProgressFnT | None</code> <p>Optional callback function to receive progress updates during tool execution. The callback receives progress notifications as they're sent by the server.</p> <code>None</code> <p>Returns:</p> Type Description <code>CallToolResult</code> <p>CallToolResult containing the tool's response. The result includes:</p> <code>CallToolResult</code> <ul> <li>content: List of content blocks (text, images, embedded resources)</li> </ul> <code>CallToolResult</code> <ul> <li>structuredContent: Validated structured data if the tool has an output schema</li> </ul> <code>CallToolResult</code> <ul> <li>isError: Boolean indicating if the tool execution failed</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the tool returns structured content that doesn't match its output schema, or if the tool name is not found on the server.</p> <code>ValidationError</code> <p>If the provided arguments don't match the tool's input schema.</p> <code>TimeoutError</code> <p>If the tool execution exceeds the specified timeout.</p> Example <pre><code># Simple tool call without arguments\nresult = await session.call_tool(\"ping\")\n\n# Tool call with arguments\nresult = await session.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n\n# Access text content\nfor content in result.content:\n    if isinstance(content, types.TextContent):\n        print(content.text)\n\n# Access structured output (if available)\nif result.structuredContent:\n    user_data = result.structuredContent\n    print(f\"Result: {user_data}\")\n\n# Handle tool execution errors\nif result.isError:\n    print(\"Tool execution failed\")\n\n# Long-running tool with progress tracking\ndef on_progress(progress_token, progress, total, message):\n    percent = (progress / total) * 100 if total else 0\n    print(f\"Progress: {percent:.1f}% - {message}\")\n\nresult = await session.call_tool(\n    \"long_task\",\n    {\"steps\": 10},\n    read_timeout_seconds=timedelta(minutes=5),\n    progress_callback=on_progress\n)\n</code></pre> Note <p>Tools may return different content types: - TextContent: Plain text responses - ImageContent: Generated images with MIME type and binary data - EmbeddedResource: File contents or external resources - Structured data via structuredContent when output schema is defined</p>"},{"location":"reference/mcp/#mcp.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceTemplateReference | PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; InitializeResult\n</code></pre> <p>Initialize the MCP session with the server.</p> <p>Sends an initialization request to establish capabilities and protocol version. This must be called before any other operations can be performed.</p> <p>Returns:</p> Type Description <code>InitializeResult</code> <p>Server's initialization response containing capabilities and metadata</p> <p>Raises:</p> Type Description <code>McpError</code> <p>If initialization fails or protocol version is unsupported</p>"},{"location":"reference/mcp/#mcp.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(\n    cursor: str | None = None,\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None = None,\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(\n    cursor: str | None = None,\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None = None) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p>"},{"location":"reference/mcp/#mcp.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p>"},{"location":"reference/mcp/#mcp.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p>"},{"location":"reference/mcp/#mcp.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> <p>Example Usage:</p> <pre><code>name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\"\nasync with ClientSessionGroup(component_name_hook=name_fn) as group:\n    for server_params in server_params:\n        await group.connect_to_server(server_param)\n    # ...\n</code></pre>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, args: dict[str, Any]\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"reference/mcp/#mcp.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"reference/mcp/#mcp.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p>"},{"location":"reference/mcp/#mcp.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p>"},{"location":"reference/mcp/#mcp.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p>"},{"location":"reference/mcp/#mcp.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"reference/mcp/#mcp.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"reference/mcp/#mcp.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p>"},{"location":"reference/mcp/#mcp.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"reference/mcp/#mcp.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"reference/mcp/#mcp.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"reference/mcp/#mcp.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p>"},{"location":"reference/mcp/#mcp.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p>"},{"location":"reference/mcp/#mcp.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"reference/mcp/#mcp.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Describes the name and version of an MCP implementation.</p>"},{"location":"reference/mcp/#mcp.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p>"},{"location":"reference/mcp/#mcp.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p>"},{"location":"reference/mcp/#mcp.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"reference/mcp/#mcp.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"reference/mcp/#mcp.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p>"},{"location":"reference/mcp/#mcp.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p>"},{"location":"reference/mcp/#mcp.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p>"},{"location":"reference/mcp/#mcp.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p>"},{"location":"reference/mcp/#mcp.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p>"},{"location":"reference/mcp/#mcp.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p>"},{"location":"reference/mcp/#mcp.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p>"},{"location":"reference/mcp/#mcp.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p>"},{"location":"reference/mcp/#mcp.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p>"},{"location":"reference/mcp/#mcp.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p>"},{"location":"reference/mcp/#mcp.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an MCP protocol error is received from a peer.</p> <p>This exception is raised when the remote MCP peer returns an error response instead of a successful result. It wraps the ErrorData received from the peer and provides access to the error code, message, and any additional data.</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>ErrorData</code> <p>The ErrorData object received from the MCP peer containing    error code, message, and optional additional data</p>"},{"location":"reference/mcp/#mcp.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError with error data from the MCP peer.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>ErrorData</code> <p>ErrorData object containing the error details from the peer</p> required"},{"location":"reference/mcp/#mcp.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p>"},{"location":"reference/mcp/#mcp.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p>"},{"location":"reference/mcp/#mcp.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p>"},{"location":"reference/mcp/#mcp.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p>"},{"location":"reference/mcp/#mcp.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"reference/mcp/#mcp.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p>"},{"location":"reference/mcp/#mcp.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p>"},{"location":"reference/mcp/#mcp.Resource","title":"Resource","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A known resource that the server is capable of reading.</p>"},{"location":"reference/mcp/#mcp.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"reference/mcp/#mcp.Resource.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/#mcp.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"reference/mcp/#mcp.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"reference/mcp/#mcp.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"reference/mcp/#mcp.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p>"},{"location":"reference/mcp/#mcp.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p>"},{"location":"reference/mcp/#mcp.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"reference/mcp/#mcp.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"reference/mcp/#mcp.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p>"},{"location":"reference/mcp/#mcp.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"reference/mcp/#mcp.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a message in an LLM conversation for sampling/generation requests.</p> <p>SamplingMessage is used to structure conversation history when requesting LLM text generation through the MCP sampling protocol. Each message represents a single turn in the conversation with a specific role and content.</p> <p>This class is primarily used with <code>ServerSession.create_message</code> to send conversation context to LLMs via MCP clients. The message format follows standard LLM conversation patterns with distinct roles for users and assistants.</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>Role</code> <p>The speaker role, either \"user\" for human input or \"assistant\" for AI responses.</p> <code>content</code> <code>TextContent | ImageContent | AudioContent</code> <p>The message content, which can be <code>TextContent</code>,  <code>ImageContent</code>, or <code>AudioContent</code>.</p> <p>Examples:</p> <p>Creating a simple text message:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nuser_msg = SamplingMessage(\n    role=\"user\",\n    content=TextContent(type=\"text\", text=\"Hello, how are you?\")\n)\n</code></pre> <p>Creating an assistant response:</p> <pre><code>assistant_msg = SamplingMessage(\n    role=\"assistant\",\n    content=TextContent(type=\"text\", text=\"I'm doing well, thank you!\")\n)\n</code></pre> <p>Creating a message with image content:</p> <pre><code>import base64\n\n# Assuming you have image_bytes containing image data\nimage_data = base64.b64encode(image_bytes).decode()\n\nimage_msg = SamplingMessage(\n    role=\"user\",\n    content=ImageContent(\n        type=\"image\",\n        data=image_data,\n        mimeType=\"image/jpeg\"\n    )\n)\n</code></pre> <p>Building a conversation history:</p> <pre><code>conversation = [\n    SamplingMessage(\n        role=\"user\",\n        content=TextContent(type=\"text\", text=\"What's 2+2?\")\n    ),\n    SamplingMessage(\n        role=\"assistant\",\n        content=TextContent(type=\"text\", text=\"2+2 equals 4.\")\n    ),\n    SamplingMessage(\n        role=\"user\", \n        content=TextContent(type=\"text\", text=\"Now what's 4+4?\")\n    )\n]\n\n# Use in create_message call  \nresult = await session.create_message(\n    messages=conversation,\n    max_tokens=50\n)\n</code></pre> Note <p>The role field is constrained to \"user\" or \"assistant\" only. The content supports multiple media types, but actual support depends on the LLM provider and client implementation.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.completions","title":"completions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completions: CompletionsCapability | None = None\n</code></pre> <p>Present if the server offers autocompletion suggestions for prompts and resources.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"reference/mcp/#mcp.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"reference/mcp/#mcp.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p>"},{"location":"reference/mcp/#mcp.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports specific capabilities before using advanced MCP features.</p> <p>This method allows MCP servers to verify that the connected client supports required capabilities before calling methods that depend on them. It performs an AND operation - the client must support ALL capabilities specified in the request, not just some of them.</p> <p>You typically access this method through the session available in your request context via <code>app.request_context.session</code>  within handler functions. Always check capabilities before using features like sampling, elicitation, or experimental functionality.</p> <p>Parameters:</p> Name Type Description Default <code>capability</code> <code>ClientCapabilities</code> <p>A <code>types.ClientCapabilities</code> object specifying which capabilities to check. Can include:</p> <ul> <li><code>roots</code>: Check if client supports root listing operations</li> <li><code>sampling</code>: Check if client supports LLM sampling via <code>create_message</code> </li> <li><code>elicitation</code>: Check if client supports user interaction via <code>elicit</code></li> <li><code>experimental</code>: Check for non-standard experimental capabilities</li> </ul> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the client supports ALL requested capabilities, <code>False</code> if the client hasn't been initialized yet or lacks any of the requested capabilities.</p> <p>Examples:</p> <p>Check sampling capability before creating LLM messages:</p> <pre><code>from typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n\n    # Check if client supports LLM sampling\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Safe to use create_message\n        response = await ctx.session.create_message(\n            messages=[types.SamplingMessage(\n                role=\"user\", \n                content=types.TextContent(type=\"text\", text=\"Help me analyze this data\")\n            )],\n            max_tokens=100\n        )\n        return [types.TextContent(type=\"text\", text=response.content.text)]\n    else:\n        return [types.TextContent(type=\"text\", text=\"Client doesn't support LLM sampling\")]\n</code></pre> <p>Check experimental capabilities:</p> <pre><code>@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n\n    # Check for experimental advanced tools capability\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(experimental={\"advanced_tools\": {}})\n    ):\n        # Use experimental features\n        return await use_advanced_tool_features(arguments)\n    else:\n        # Fall back to basic functionality\n        return await use_basic_tool_features(arguments)\n</code></pre> <p>Check multiple capabilities at once:</p> <pre><code># Client must support BOTH sampling AND elicitation\nif ctx.session.check_client_capability(\n    types.ClientCapabilities(\n        sampling=types.SamplingCapability(),\n        elicitation=types.ElicitationCapability()\n    )\n):\n    # Safe to use both features\n    user_input = await ctx.session.elicit(\"What would you like to analyze?\", schema)\n    llm_response = await ctx.session.create_message(messages, max_tokens=100)\n</code></pre> Note <p>This method returns <code>False</code> if the session hasn't been initialized yet (before the client sends the initialization request). It also returns <code>False</code> if the client lacks ANY of the requested capabilities - all specified capabilities must be supported for this method to return <code>True</code>.</p>"},{"location":"reference/mcp/#mcp.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre> <p>Send a message to an LLM through the MCP client for processing.</p> <p>This method enables MCP servers to request LLM sampling from the connected client. The client forwards the request to its configured LLM provider (OpenAI, Anthropic, etc.) and returns the generated response. This is useful for tools that need LLM assistance to process user requests or generate content.</p> <p>The client must support the sampling capability for this method to work. Check client capabilities using <code>check_client_capability</code> before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[SamplingMessage]</code> <p>List of <code>SamplingMessage</code> objects representing the conversation history. Each message has a role (\"user\" or \"assistant\") and content (text, image, or audio).</p> required <code>max_tokens</code> <code>int</code> <p>Maximum number of tokens the LLM should generate in the response.</p> required <code>system_prompt</code> <code>str | None</code> <p>Optional system message to set the LLM's behavior and context.</p> <code>None</code> <code>include_context</code> <code>IncludeContext | None</code> <p>Optional context inclusion preferences for the LLM request.</p> <code>None</code> <code>temperature</code> <code>float | None</code> <p>Optional sampling temperature (0.0-1.0) controlling response randomness. Lower values make responses more deterministic.</p> <code>None</code> <code>stop_sequences</code> <code>list[str] | None</code> <p>Optional list of strings that will cause the LLM to stop generating when encountered in the response.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Optional arbitrary metadata to include with the request.</p> <code>None</code> <code>model_preferences</code> <code>ModelPreferences | None</code> <p>Optional preferences for which model the client should use.</p> <code>None</code> <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID linking this request to a parent request for tracing.</p> <code>None</code> <p>Returns:</p> Type Description <code>CreateMessageResult</code> <p>CreateMessageResult containing the LLM's response with role, content, model name, and stop reason information.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on client implementation and LLM provider errors.</p> <p>Examples:</p> <p>Basic text generation:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nresult = await session.create_message(\n    messages=[\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"Explain quantum computing\")\n        )\n    ],\n    max_tokens=150\n)\nprint(result.content.text)  # Generated explanation\n</code></pre> <p>Multi-turn conversation with system prompt:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nresult = await session.create_message(\n    messages=[\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"What's the weather like?\")\n        ),\n        SamplingMessage(\n            role=\"assistant\",\n            content=TextContent(type=\"text\", text=\"I don't have access to weather data.\")\n        ),\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"Then help me write a poem about rain\")\n        )\n    ],\n    max_tokens=100,\n    system_prompt=\"You are a helpful poetry assistant.\",\n    temperature=0.8\n)\n</code></pre> Note <p>This method requires the client to have sampling capability enabled. Most modern MCP clients support this, but always check capabilities before use in production code.</p>"},{"location":"reference/mcp/#mcp.ServerSession.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str,\n    requestedSchema: ElicitRequestedSchema,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send an elicitation request to collect structured information from the client.</p> <p>This is the low-level method for client elicitation. For most use cases, prefer the higher-level <code>Context.elicit</code> method which provides automatic Pydantic validation and a more convenient interface.</p> <p>You typically access this method through the session available in your request context via <code>app.request_context.session</code>  within handler functions. Always check that the client supports elicitation using <code>check_client_capability</code>  before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt or question to present to the user.</p> required <code>requestedSchema</code> <code>ElicitRequestedSchema</code> <p>A <code>types.ElicitRequestedSchema</code>  defining the expected response structure according to JSON Schema.</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional <code>types.RequestId</code> linking  this elicitation to a specific client request for tracing.</p> <code>None</code> <p>Returns:</p> Type Description <code>ElicitResult</code> <p><code>types.ElicitResult</code> containing the client's response</p> <code>ElicitResult</code> <p>and action taken (accept, decline, or cancel).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on client implementation and user interaction.</p> Note <p>Most developers should use <code>Context.elicit</code>  instead, which provides Pydantic model validation and better error handling.</p>"},{"location":"reference/mcp/#mcp.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification from the server to the client.</p> <p>This method allows MCP servers to send log messages to the connected client for debugging, monitoring, and error reporting purposes. The client can filter these messages based on the logging level it has configured via the logging/setLevel request. Check client capabilities using <code>check_client_capability</code> if you need to verify logging support.</p> <p>You typically access this method through the session available in your request context. When using the low-level SDK, access it via  <code>app.request_context.session</code> within handler functions. With FastMCP, use the convenience logging methods on the  <code>Context</code> object instead, like <code>ctx.info()</code> or  <code>ctx.error()</code>.</p> <p>Log messages are one-way notifications and do not expect a response from the client. They are useful for providing visibility into server operations, debugging issues, and tracking the flow of request processing.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LoggingLevel</code> <p>The severity level of the log message as a <code>types.LoggingLevel</code>. Must be one of:</p> <ul> <li><code>debug</code>: Detailed information for debugging</li> <li><code>info</code>: General informational messages</li> <li><code>notice</code>: Normal but significant conditions</li> <li><code>warning</code>: Warning conditions that should be addressed</li> <li><code>error</code>: Error conditions that don't prevent operation</li> <li><code>critical</code>: Critical conditions requiring immediate attention</li> <li><code>alert</code>: Action must be taken immediately</li> <li><code>emergency</code>: System is unusable</li> </ul> required <code>data</code> <code>Any</code> <p>The data to log. Can be any JSON-serializable value including:</p> <ul> <li>Simple strings for text messages</li> <li>Objects/dictionaries for structured logging</li> <li>Lists for multiple related items</li> <li>Numbers, booleans, or null values</li> </ul> required <code>logger</code> <code>str | None</code> <p>Optional name to identify the source of the log message. Useful for categorizing logs from different components or modules within your server (e.g., \"database\", \"auth\", \"tool_handler\").</p> <code>None</code> <code>related_request_id</code> <code>RequestId | None</code> <p>Optional <code>types.RequestId</code> linking this log to a specific client request. Use this to associate log messages with the request they relate to, making it easier to trace request processing and debug issues.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on serialization or transport errors.</p> <p>Examples:</p> <p>In a tool handler using the low-level SDK:</p> <pre><code>from typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    # Access the request context to get the session\n    ctx = app.request_context\n\n    # Log the start of processing\n    await ctx.session.send_log_message(\n        level=\"info\",\n        data=f\"Processing tool call: {name}\",\n        logger=\"tool_handler\",\n        related_request_id=ctx.request_id\n    )\n\n    # Process and log any issues\n    try:\n        result = perform_operation(arguments)\n    except Exception as e:\n        await ctx.session.send_log_message(\n            level=\"error\",\n            data={\"error\": str(e), \"tool\": name, \"args\": arguments},\n            logger=\"tool_handler\",\n            related_request_id=ctx.request_id\n        )\n        raise\n\n    return [types.TextContent(type=\"text\", text=str(result))]\n</code></pre> <p>Using FastMCP's <code>Context</code> helper for cleaner logging:</p> <pre><code>from mcp.server.fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"example-server\")\n\n@mcp.tool()\nasync def fetch_data(url: str, ctx: Context) -&gt; str:\n    # FastMCP's Context provides convenience methods that internally\n    # call send_log_message with the appropriate parameters\n    await ctx.info(f\"Fetching data from {url}\")\n    await ctx.debug(\"Starting request\")\n\n    try:\n        data = await fetch(url)\n        await ctx.info(\"Data fetched successfully\")\n        return data\n    except Exception as e:\n        await ctx.error(f\"Failed to fetch: {e}\")\n        raise\n</code></pre> <p>Streaming notifications with progress updates:</p> <pre><code>import anyio\nfrom typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    count = arguments.get(\"count\", 5)\n\n    for i in range(count):\n        # Send progress updates to the client\n        await ctx.session.send_log_message(\n            level=\"info\",\n            data=f\"[{i + 1}/{count}] Processing item\",\n            logger=\"progress_stream\",\n            related_request_id=ctx.request_id\n        )\n        if i &lt; count - 1:\n            await anyio.sleep(1)\n\n    return [types.TextContent(type=\"text\", text=\"Operation complete\")]\n</code></pre> Note <p>Log messages are only delivered to the client if the client's configured logging level permits it. For example, if the client has set its level to \"warning\", it will not receive \"debug\" or \"info\" messages. Consider this when deciding what level to use for your log messages. This method internally uses <code>send_notification</code> to deliver the log message to the client.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p>"},{"location":"reference/mcp/#mcp.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p>"},{"location":"reference/mcp/#mcp.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"reference/mcp/#mcp.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"reference/mcp/#mcp.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p>"},{"location":"reference/mcp/#mcp.Tool","title":"Tool","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Definition for a tool the client can call.</p>"},{"location":"reference/mcp/#mcp.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"reference/mcp/#mcp.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"reference/mcp/#mcp.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"reference/mcp/#mcp.Tool.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/#mcp.Tool.outputSchema","title":"outputSchema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputSchema: dict[str, Any] | None = None\n</code></pre> <p>An optional JSON Schema object defining the structure of the tool's output returned in the structuredContent field of a CallToolResult.</p>"},{"location":"reference/mcp/#mcp.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p>"},{"location":"reference/mcp/#mcp.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"reference/mcp/#mcp.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p>"},{"location":"reference/mcp/#mcp.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p>"},{"location":"reference/mcp/#mcp.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p>"},{"location":"reference/mcp/cli/","title":"mcp.cli","text":"<p>FastMCP CLI package.</p>"},{"location":"reference/mcp/cli/claude/","title":"mcp.cli.claude","text":"<p>Claude app integration utilities.</p>"},{"location":"reference/mcp/cli/claude/#mcp.cli.claude.get_claude_config_path","title":"get_claude_config_path","text":"<pre><code>get_claude_config_path() -&gt; Path | None\n</code></pre> <p>Get the Claude config directory based on platform.</p>"},{"location":"reference/mcp/cli/claude/#mcp.cli.claude.get_uv_path","title":"get_uv_path","text":"<pre><code>get_uv_path() -&gt; str\n</code></pre> <p>Get the full path to the uv executable.</p>"},{"location":"reference/mcp/cli/claude/#mcp.cli.claude.update_claude_config","title":"update_claude_config","text":"<pre><code>update_claude_config(\n    file_spec: str,\n    server_name: str,\n    *,\n    with_editable: Path | None = None,\n    with_packages: list[str] | None = None,\n    env_vars: dict[str, str] | None = None\n) -&gt; bool\n</code></pre> <p>Add or update a FastMCP server in Claude's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>file_spec</code> <code>str</code> <p>Path to the server file, optionally with :object suffix</p> required <code>server_name</code> <code>str</code> <p>Name for the server in Claude's config</p> required <code>with_editable</code> <code>Path | None</code> <p>Optional directory to install in editable mode</p> <code>None</code> <code>with_packages</code> <code>list[str] | None</code> <p>Optional list of additional packages to install</p> <code>None</code> <code>env_vars</code> <code>dict[str, str] | None</code> <p>Optional dictionary of environment variables. These are merged with any existing variables, with new values taking precedence.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If Claude Desktop's config directory is not found, indicating Claude Desktop may not be installed or properly set up.</p>"},{"location":"reference/mcp/cli/cli/","title":"mcp.cli.cli","text":"<p>MCP CLI tools.</p>"},{"location":"reference/mcp/cli/cli/#mcp.cli.cli.dev","title":"dev","text":"<pre><code>dev(\n    file_spec: str = Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    with_editable: Annotated[\n        Path | None,\n        Option(\n            \"--with-editable\",\n            -e,\n            help=\"Directory containing pyproject.toml to install in editable mode\",\n            exists=True,\n            file_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n    with_packages: Annotated[\n        list[str],\n        Option(\n            \"--with\", help=\"Additional packages to install\"\n        ),\n    ] = [],\n) -&gt; None\n</code></pre> <p>Run a MCP server with the MCP Inspector.</p>"},{"location":"reference/mcp/cli/cli/#mcp.cli.cli.install","title":"install","text":"<pre><code>install(\n    file_spec: str = Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    server_name: Annotated[\n        str | None,\n        Option(\n            --name,\n            -n,\n            help=\"Custom name for the server (defaults to server's name attribute or file name)\",\n        ),\n    ] = None,\n    with_editable: Annotated[\n        Path | None,\n        Option(\n            \"--with-editable\",\n            -e,\n            help=\"Directory containing pyproject.toml to install in editable mode\",\n            exists=True,\n            file_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n    with_packages: Annotated[\n        list[str],\n        Option(\n            \"--with\", help=\"Additional packages to install\"\n        ),\n    ] = [],\n    env_vars: Annotated[\n        list[str],\n        Option(\n            --env - var,\n            -v,\n            help=\"Environment variables in KEY=VALUE format\",\n        ),\n    ] = [],\n    env_file: Annotated[\n        Path | None,\n        Option(\n            --env - file,\n            -f,\n            help=\"Load environment variables from a .env file\",\n            exists=True,\n            file_okay=True,\n            dir_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Install a MCP server in the Claude desktop app.</p> <p>Environment variables are preserved once added and only updated if new values are explicitly provided.</p>"},{"location":"reference/mcp/cli/cli/#mcp.cli.cli.run","title":"run","text":"<pre><code>run(\n    file_spec: str = Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    transport: Annotated[\n        str | None,\n        Option(\n            --transport,\n            -t,\n            help=\"Transport protocol to use (stdio or sse)\",\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Run a MCP server.</p> <p>The server can be specified in two ways:</p> <ol> <li> <p>Module approach: server.py - runs the module directly, expecting a server.run() call.</p> </li> <li> <p>Import approach: server.py:app - imports and runs the specified server object.</p> </li> </ol> <p>Note: This command runs the server directly. You are responsible for ensuring all dependencies are available.</p> <p>For dependency management, use <code>mcp install</code> or <code>mcp dev</code> instead.</p>"},{"location":"reference/mcp/cli/cli/#mcp.cli.cli.version","title":"version","text":"<pre><code>version() -&gt; None\n</code></pre> <p>Show the MCP version.</p>"},{"location":"reference/mcp/client/","title":"mcp.client","text":""},{"location":"reference/mcp/client/auth/","title":"mcp.client.auth","text":"<p>OAuth2 Authentication implementation for HTTPX.</p> <p>Implements authorization code flow with PKCE and automatic token refresh.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthClientProvider","title":"OAuthClientProvider","text":"<p>               Bases: <code>Auth</code></p> <p>OAuth2 authentication for httpx. Handles OAuth flow with automatic client registration and token storage.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthClientProvider.__init__","title":"__init__","text":"<pre><code>__init__(\n    server_url: str,\n    client_metadata: OAuthClientMetadata,\n    storage: TokenStorage,\n    redirect_handler: Callable[[str], Awaitable[None]],\n    callback_handler: Callable[\n        [], Awaitable[tuple[str, str | None]]\n    ],\n    timeout: float = 300.0,\n)\n</code></pre> <p>Initialize OAuth2 authentication.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthClientProvider.async_auth_flow","title":"async_auth_flow  <code>async</code>","text":"<pre><code>async_auth_flow(\n    request: Request,\n) -&gt; AsyncGenerator[Request, Response]\n</code></pre> <p>HTTPX auth flow integration.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext","title":"OAuthContext  <code>dataclass</code>","text":"<p>OAuth flow context.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.can_refresh_token","title":"can_refresh_token","text":"<pre><code>can_refresh_token() -&gt; bool\n</code></pre> <p>Check if token can be refreshed.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.clear_tokens","title":"clear_tokens","text":"<pre><code>clear_tokens() -&gt; None\n</code></pre> <p>Clear current tokens.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.get_authorization_base_url","title":"get_authorization_base_url","text":"<pre><code>get_authorization_base_url(server_url: str) -&gt; str\n</code></pre> <p>Extract base URL by removing path component.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.get_resource_url","title":"get_resource_url","text":"<pre><code>get_resource_url() -&gt; str\n</code></pre> <p>Get resource URL for RFC 8707.</p> <p>Uses PRM resource if it's a valid parent, otherwise uses canonical server URL.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.is_token_valid","title":"is_token_valid","text":"<pre><code>is_token_valid() -&gt; bool\n</code></pre> <p>Check if current token is valid.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.should_include_resource_param","title":"should_include_resource_param","text":"<pre><code>should_include_resource_param(\n    protocol_version: str | None = None,\n) -&gt; bool\n</code></pre> <p>Determine if the resource parameter should be included in OAuth requests.</p> <p>Returns True if: - Protected resource metadata is available, OR - MCP-Protocol-Version header is 2025-06-18 or later</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthContext.update_token_expiry","title":"update_token_expiry","text":"<pre><code>update_token_expiry(token: OAuthToken) -&gt; None\n</code></pre> <p>Update token expiry time.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthFlowError","title":"OAuthFlowError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for OAuth flow errors.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthRegistrationError","title":"OAuthRegistrationError","text":"<p>               Bases: <code>OAuthFlowError</code></p> <p>Raised when client registration fails.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.OAuthTokenError","title":"OAuthTokenError","text":"<p>               Bases: <code>OAuthFlowError</code></p> <p>Raised when token operations fail.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.PKCEParameters","title":"PKCEParameters","text":"<p>               Bases: <code>BaseModel</code></p> <p>PKCE (Proof Key for Code Exchange) parameters.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.PKCEParameters.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate() -&gt; PKCEParameters\n</code></pre> <p>Generate new PKCE parameters.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.TokenStorage","title":"TokenStorage","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for token storage implementations.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.TokenStorage.get_client_info","title":"get_client_info  <code>async</code>","text":"<pre><code>get_client_info() -&gt; OAuthClientInformationFull | None\n</code></pre> <p>Get stored client information.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.TokenStorage.get_tokens","title":"get_tokens  <code>async</code>","text":"<pre><code>get_tokens() -&gt; OAuthToken | None\n</code></pre> <p>Get stored tokens.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.TokenStorage.set_client_info","title":"set_client_info  <code>async</code>","text":"<pre><code>set_client_info(\n    client_info: OAuthClientInformationFull,\n) -&gt; None\n</code></pre> <p>Store client information.</p>"},{"location":"reference/mcp/client/auth/#mcp.client.auth.TokenStorage.set_tokens","title":"set_tokens  <code>async</code>","text":"<pre><code>set_tokens(tokens: OAuthToken) -&gt; None\n</code></pre> <p>Store tokens.</p>"},{"location":"reference/mcp/client/session/","title":"mcp.client.session","text":""},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> <p>A client session for communicating with an MCP server.</p> <p>This class provides a high-level interface for MCP client operations, including tool calling, resource management, prompt handling, and protocol initialization. It manages the bidirectional communication channel with an MCP server and handles protocol-level concerns like message validation and capability negotiation.</p> <p>The session supports various MCP capabilities:</p> <ul> <li>Tool execution with structured output validation</li> <li>Resource access and subscription management</li> <li>Prompt template retrieval and completion</li> <li>Progress notifications and logging</li> <li>Custom sampling, elicitation, and root listing callbacks</li> </ul> <p>Parameters:</p> Name Type Description Default <code>read_stream</code> <code>MemoryObjectReceiveStream[SessionMessage | Exception]</code> <p>Stream for receiving messages from the server.</p> required <code>write_stream</code> <code>MemoryObjectSendStream[SessionMessage]</code> <p>Stream for sending messages to the server.</p> required <code>read_timeout_seconds</code> <code>timedelta | None</code> <p>Optional timeout for read operations.</p> <code>None</code> <code>sampling_callback</code> <code>SamplingFnT | None</code> <p>Optional callback for handling sampling requests from the server.</p> <code>None</code> <code>elicitation_callback</code> <code>ElicitationFnT | None</code> <p>Optional callback for handling elicitation requests from the server.</p> <code>None</code> <code>list_roots_callback</code> <code>ListRootsFnT | None</code> <p>Optional callback for handling root listing requests from the server.</p> <code>None</code> <code>logging_callback</code> <code>LoggingFnT | None</code> <p>Optional callback for handling log messages from the server.</p> <code>None</code> <code>message_handler</code> <code>MessageHandlerFnT | None</code> <p>Optional custom handler for incoming messages and exceptions.</p> <code>None</code> <code>client_info</code> <code>Implementation | None</code> <p>Optional client implementation information.</p> <code>None</code> Example <pre><code>async with create_client_session() as session:\n    # Initialize the session\n    await session.initialize()\n\n    # List available tools\n    tools = await session.list_tools()\n\n    # Call a tool\n    result = await session.call_tool(\"my_tool\", {\"arg\": \"value\"})\n</code></pre>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; CallToolResult\n</code></pre> <p>Execute a tool on the connected MCP server.</p> <p>This method sends a tools/call request to execute a specific tool with provided arguments. The server will validate the arguments against the tool's input schema and return structured or unstructured content based on the tool's configuration.</p> <p>For tools that return structured output, the result will be automatically validated against the tool's output schema if one is defined. Tools may also return various content types including text, images, and embedded resources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool to execute. Must match a tool exposed by the server.</p> required <code>arguments</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of arguments to pass to the tool. The structure must match the tool's input schema. Defaults to None for tools that don't require arguments.</p> <code>None</code> <code>read_timeout_seconds</code> <code>timedelta | None</code> <p>Optional timeout for the tool execution. If not specified, uses the session's default read timeout. Useful for long-running tools.</p> <code>None</code> <code>progress_callback</code> <code>ProgressFnT | None</code> <p>Optional callback function to receive progress updates during tool execution. The callback receives progress notifications as they're sent by the server.</p> <code>None</code> <p>Returns:</p> Type Description <code>CallToolResult</code> <p>CallToolResult containing the tool's response. The result includes:</p> <code>CallToolResult</code> <ul> <li>content: List of content blocks (text, images, embedded resources)</li> </ul> <code>CallToolResult</code> <ul> <li>structuredContent: Validated structured data if the tool has an output schema</li> </ul> <code>CallToolResult</code> <ul> <li>isError: Boolean indicating if the tool execution failed</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the tool returns structured content that doesn't match its output schema, or if the tool name is not found on the server.</p> <code>ValidationError</code> <p>If the provided arguments don't match the tool's input schema.</p> <code>TimeoutError</code> <p>If the tool execution exceeds the specified timeout.</p> Example <pre><code># Simple tool call without arguments\nresult = await session.call_tool(\"ping\")\n\n# Tool call with arguments\nresult = await session.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n\n# Access text content\nfor content in result.content:\n    if isinstance(content, types.TextContent):\n        print(content.text)\n\n# Access structured output (if available)\nif result.structuredContent:\n    user_data = result.structuredContent\n    print(f\"Result: {user_data}\")\n\n# Handle tool execution errors\nif result.isError:\n    print(\"Tool execution failed\")\n\n# Long-running tool with progress tracking\ndef on_progress(progress_token, progress, total, message):\n    percent = (progress / total) * 100 if total else 0\n    print(f\"Progress: {percent:.1f}% - {message}\")\n\nresult = await session.call_tool(\n    \"long_task\",\n    {\"steps\": 10},\n    read_timeout_seconds=timedelta(minutes=5),\n    progress_callback=on_progress\n)\n</code></pre> Note <p>Tools may return different content types: - TextContent: Plain text responses - ImageContent: Generated images with MIME type and binary data - EmbeddedResource: File contents or external resources - Structured data via structuredContent when output schema is defined</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceTemplateReference | PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; InitializeResult\n</code></pre> <p>Initialize the MCP session with the server.</p> <p>Sends an initialization request to establish capabilities and protocol version. This must be called before any other operations can be performed.</p> <p>Returns:</p> Type Description <code>InitializeResult</code> <p>Server's initialization response containing capabilities and metadata</p> <p>Raises:</p> Type Description <code>McpError</code> <p>If initialization fails or protocol version is unsupported</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(\n    cursor: str | None = None,\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None = None,\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(\n    cursor: str | None = None,\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None = None) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p>"},{"location":"reference/mcp/client/session/#mcp.client.session.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p>"},{"location":"reference/mcp/client/session_group/","title":"mcp.client.session_group","text":"<p>SessionGroup concurrently manages multiple MCP session connections.</p> <p>Tools, resources, and prompts are aggregated across servers. Servers may be connected to or disconnected from at any point after initialization.</p> <p>This abstractions can handle naming collisions using a custom user-provided hook.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> <p>Example Usage:</p> <pre><code>name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\"\nasync with ClientSessionGroup(component_name_hook=name_fn) as group:\n    for server_params in server_params:\n        await group.connect_to_server(server_param)\n    # ...\n</code></pre>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, args: dict[str, Any]\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.SseServerParameters","title":"SseServerParameters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for intializing a sse_client.</p>"},{"location":"reference/mcp/client/session_group/#mcp.client.session_group.StreamableHttpParameters","title":"StreamableHttpParameters","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for intializing a streamablehttp_client.</p>"},{"location":"reference/mcp/client/sse/","title":"mcp.client.sse","text":""},{"location":"reference/mcp/client/sse/#mcp.client.sse.sse_client","title":"sse_client  <code>async</code>","text":"<pre><code>sse_client(\n    url: str,\n    headers: dict[str, Any] | None = None,\n    timeout: float = 5,\n    sse_read_timeout: float = 60 * 5,\n    httpx_client_factory: McpHttpClientFactory = create_mcp_http_client,\n    auth: Auth | None = None,\n)\n</code></pre> <p>Client transport for SSE.</p> <p><code>sse_read_timeout</code> determines how long (in seconds) the client will wait for a new event before disconnecting. All other HTTP operations are controlled by <code>timeout</code>.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The SSE endpoint URL.</p> required <code>headers</code> <code>dict[str, Any] | None</code> <p>Optional headers to include in requests.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>HTTP timeout for regular operations.</p> <code>5</code> <code>sse_read_timeout</code> <code>float</code> <p>Timeout for SSE read operations.</p> <code>60 * 5</code> <code>auth</code> <code>Auth | None</code> <p>Optional HTTPX authentication handler.</p> <code>None</code>"},{"location":"reference/mcp/client/stdio/","title":"mcp.client.stdio","text":""},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.get_default_environment","title":"get_default_environment","text":"<pre><code>get_default_environment() -&gt; dict[str, str]\n</code></pre> <p>Returns a default environment object including only environment variables deemed safe to inherit.</p>"},{"location":"reference/mcp/client/stdio/#mcp.client.stdio.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p>"},{"location":"reference/mcp/client/streamable_http/","title":"mcp.client.streamable_http","text":"<p>StreamableHTTP Client Transport Module</p> <p>This module implements the StreamableHTTP transport for MCP clients, providing support for HTTP POST requests with optional SSE streaming responses and session management.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.RequestContext","title":"RequestContext  <code>dataclass</code>","text":"<p>Context for a request operation.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.ResumptionError","title":"ResumptionError","text":"<p>               Bases: <code>StreamableHTTPError</code></p> <p>Raised when resumption request is invalid.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPError","title":"StreamableHTTPError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for StreamableHTTP transport errors.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport","title":"StreamableHTTPTransport","text":"<p>StreamableHTTP client transport implementation.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: str,\n    headers: dict[str, str] | None = None,\n    timeout: float | timedelta = 30,\n    sse_read_timeout: float | timedelta = 60 * 5,\n    auth: Auth | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the StreamableHTTP transport.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The endpoint URL.</p> required <code>headers</code> <code>dict[str, str] | None</code> <p>Optional headers to include in requests.</p> <code>None</code> <code>timeout</code> <code>float | timedelta</code> <p>HTTP timeout for regular operations.</p> <code>30</code> <code>sse_read_timeout</code> <code>float | timedelta</code> <p>Timeout for SSE read operations.</p> <code>60 * 5</code> <code>auth</code> <code>Auth | None</code> <p>Optional HTTPX authentication handler.</p> <code>None</code>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport.get_session_id","title":"get_session_id","text":"<pre><code>get_session_id() -&gt; str | None\n</code></pre> <p>Get the current session ID.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport.handle_get_stream","title":"handle_get_stream  <code>async</code>","text":"<pre><code>handle_get_stream(\n    client: AsyncClient, read_stream_writer: StreamWriter\n) -&gt; None\n</code></pre> <p>Handle GET stream for server-initiated messages.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport.post_writer","title":"post_writer  <code>async</code>","text":"<pre><code>post_writer(\n    client: AsyncClient,\n    write_stream_reader: StreamReader,\n    read_stream_writer: StreamWriter,\n    write_stream: MemoryObjectSendStream[SessionMessage],\n    start_get_stream: Callable[[], None],\n    tg: TaskGroup,\n) -&gt; None\n</code></pre> <p>Handle writing requests to the server.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.StreamableHTTPTransport.terminate_session","title":"terminate_session  <code>async</code>","text":"<pre><code>terminate_session(client: AsyncClient) -&gt; None\n</code></pre> <p>Terminate the session by sending a DELETE request.</p>"},{"location":"reference/mcp/client/streamable_http/#mcp.client.streamable_http.streamablehttp_client","title":"streamablehttp_client  <code>async</code>","text":"<pre><code>streamablehttp_client(\n    url: str,\n    headers: dict[str, str] | None = None,\n    timeout: float | timedelta = 30,\n    sse_read_timeout: float | timedelta = 60 * 5,\n    terminate_on_close: bool = True,\n    httpx_client_factory: McpHttpClientFactory = create_mcp_http_client,\n    auth: Auth | None = None,\n) -&gt; AsyncGenerator[\n    tuple[\n        MemoryObjectReceiveStream[\n            SessionMessage | Exception\n        ],\n        MemoryObjectSendStream[SessionMessage],\n        GetSessionIdCallback,\n    ],\n    None,\n]\n</code></pre> <p>Client transport for StreamableHTTP.</p> <p><code>sse_read_timeout</code> determines how long (in seconds) the client will wait for a new event before disconnecting. All other HTTP operations are controlled by <code>timeout</code>.</p> <p>Yields:</p> Type Description <code>AsyncGenerator[tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage], GetSessionIdCallback], None]</code> <p>Tuple containing: - read_stream: Stream for reading messages from the server - write_stream: Stream for sending messages to the server - get_session_id_callback: Function to retrieve the current session ID</p>"},{"location":"reference/mcp/client/websocket/","title":"mcp.client.websocket","text":""},{"location":"reference/mcp/client/websocket/#mcp.client.websocket.websocket_client","title":"websocket_client  <code>async</code>","text":"<pre><code>websocket_client(\n    url: str,\n) -&gt; AsyncGenerator[\n    tuple[\n        MemoryObjectReceiveStream[\n            SessionMessage | Exception\n        ],\n        MemoryObjectSendStream[SessionMessage],\n    ],\n    None,\n]\n</code></pre> <p>WebSocket client transport for MCP, symmetrical to the server version.</p> <p>Connects to 'url' using the 'mcp' subprotocol, then yields:     (read_stream, write_stream)</p> <ul> <li>read_stream: As you read from this stream, you'll receive either valid   JSONRPCMessage objects or Exception objects (when validation fails).</li> <li>write_stream: Write JSONRPCMessage objects to this stream to send them   over the WebSocket to the server.</li> </ul>"},{"location":"reference/mcp/os/","title":"mcp.os","text":"<p>Platform-specific utilities for MCP.</p>"},{"location":"reference/mcp/os/posix/","title":"mcp.os.posix","text":"<p>POSIX-specific utilities for MCP.</p>"},{"location":"reference/mcp/os/posix/utilities/","title":"mcp.os.posix.utilities","text":"<p>POSIX-specific functionality for stdio client operations.</p>"},{"location":"reference/mcp/os/posix/utilities/#mcp.os.posix.utilities.terminate_posix_process_tree","title":"terminate_posix_process_tree  <code>async</code>","text":"<pre><code>terminate_posix_process_tree(\n    process: Process, timeout_seconds: float = 2.0\n) -&gt; None\n</code></pre> <p>Terminate a process and all its children on POSIX systems.</p> <p>Uses os.killpg() for atomic process group termination.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> <p>The process to terminate</p> required <code>timeout_seconds</code> <code>float</code> <p>Timeout in seconds before force killing (default: 2.0)</p> <code>2.0</code>"},{"location":"reference/mcp/os/win32/","title":"mcp.os.win32","text":"<p>Windows-specific utilities for MCP.</p>"},{"location":"reference/mcp/os/win32/utilities/","title":"mcp.os.win32.utilities","text":"<p>Windows-specific functionality for stdio client operations.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess","title":"FallbackProcess","text":"<p>A fallback process wrapper for Windows to handle async I/O when using subprocess.Popen, which provides sync-only FileIO objects.</p> <p>This wraps stdin and stdout into async-compatible streams (FileReadStream, FileWriteStream), so that MCP clients expecting async streams can work properly.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Support async context manager entry.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: BaseException | None,\n    exc_val: BaseException | None,\n    exc_tb: object | None,\n) -&gt; None\n</code></pre> <p>Terminate and wait on process exit inside a thread.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.kill","title":"kill","text":"<pre><code>kill() -&gt; None\n</code></pre> <p>Kill the subprocess immediately (alias for terminate).</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.pid","title":"pid  <code>property</code>","text":"<pre><code>pid: int\n</code></pre> <p>Return the process ID.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.terminate","title":"terminate","text":"<pre><code>terminate()\n</code></pre> <p>Terminate the subprocess immediately.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.FallbackProcess.wait","title":"wait  <code>async</code>","text":"<pre><code>wait()\n</code></pre> <p>Async wait for process completion.</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.create_windows_process","title":"create_windows_process  <code>async</code>","text":"<pre><code>create_windows_process(\n    command: str,\n    args: list[str],\n    env: dict[str, str] | None = None,\n    errlog: TextIO | None = stderr,\n    cwd: Path | str | None = None,\n) -&gt; Process | FallbackProcess\n</code></pre> <p>Creates a subprocess in a Windows-compatible way with Job Object support.</p> <p>Attempt to use anyio's open_process for async subprocess creation. In some cases this will throw NotImplementedError on Windows, e.g. when using the SelectorEventLoop which does not support async subprocesses. In that case, we fall back to using subprocess.Popen.</p> <p>The process is automatically added to a Job Object to ensure all child processes are terminated when the parent is terminated.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The executable to run</p> required <code>args</code> <code>list[str]</code> <p>List of command line arguments</p> required <code>env</code> <code>dict[str, str] | None</code> <p>Environment variables</p> <code>None</code> <code>errlog</code> <code>TextIO | None</code> <p>Where to send stderr output (defaults to sys.stderr)</p> <code>stderr</code> <code>cwd</code> <code>Path | str | None</code> <p>Working directory for the subprocess</p> <code>None</code> <p>Returns:</p> Type Description <code>Process | FallbackProcess</code> <p>Process | FallbackProcess: Async-compatible subprocess with stdin and stdout streams</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.get_windows_executable_command","title":"get_windows_executable_command","text":"<pre><code>get_windows_executable_command(command: str) -&gt; str\n</code></pre> <p>Get the correct executable command normalized for Windows.</p> <p>On Windows, commands might exist with specific extensions (.exe, .cmd, etc.) that need to be located for proper execution.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Base command (e.g., 'uvx', 'npx')</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Windows-appropriate command path</p>"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.terminate_windows_process","title":"terminate_windows_process  <code>async</code>","text":"<pre><code>terminate_windows_process(\n    process: Process | FallbackProcess,\n)\n</code></pre> <p>Terminate a Windows process.</p> <p>Note: On Windows, terminating a process with process.terminate() doesn't always guarantee immediate process termination. So we give it 2s to exit, or we call process.kill() which sends a SIGKILL equivalent signal.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process | FallbackProcess</code> <p>The process to terminate</p> required"},{"location":"reference/mcp/os/win32/utilities/#mcp.os.win32.utilities.terminate_windows_process_tree","title":"terminate_windows_process_tree  <code>async</code>","text":"<pre><code>terminate_windows_process_tree(\n    process: Process | FallbackProcess,\n    timeout_seconds: float = 2.0,\n) -&gt; None\n</code></pre> <p>Terminate a process and all its children on Windows.</p> <p>If the process has an associated job object, it will be terminated. Otherwise, falls back to basic process termination.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process | FallbackProcess</code> <p>The process to terminate</p> required <code>timeout_seconds</code> <code>float</code> <p>Timeout in seconds before force killing (default: 2.0)</p> <code>2.0</code>"},{"location":"reference/mcp/server/","title":"mcp.server","text":""},{"location":"reference/mcp/server/#mcp.server.FastMCP","title":"FastMCP","text":"<p>               Bases: <code>Generic[LifespanResultT]</code></p> <p>A high-level ergonomic interface for creating MCP servers.</p> <p>FastMCP provides a decorator-based API for building MCP servers with automatic parameter validation, structured output support, and built-in transport handling. It supports stdio, SSE, and Streamable HTTP transports out of the box.</p> <p>Features include automatic validation using Pydantic, structured output conversion, context injection for MCP capabilities, lifespan management, multiple transport support, and built-in OAuth 2.1 authentication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Human-readable name for the server. If None, defaults to \"FastMCP\"</p> <code>None</code> <code>instructions</code> <code>str | None</code> <p>Optional instructions/description for the server</p> <code>None</code> <code>auth_server_provider</code> <code>OAuthAuthorizationServerProvider[Any, Any, Any] | None</code> <p>OAuth authorization server provider for authentication</p> <code>None</code> <code>token_verifier</code> <code>TokenVerifier | None</code> <p>Token verifier for validating OAuth tokens</p> <code>None</code> <code>event_store</code> <code>EventStore | None</code> <p>Event store for Streamable HTTP transport persistence</p> <code>None</code> <code>tools</code> <code>list[Tool] | None</code> <p>Pre-configured tools to register with the server</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode for additional logging</p> <code>False</code> <code>log_level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'INFO'</code> <code>host</code> <code>str</code> <p>Host address for HTTP transports</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port number for HTTP transports</p> <code>8000</code> <code>mount_path</code> <code>str</code> <p>Base mount path for SSE transport</p> <code>'/'</code> <code>sse_path</code> <code>str</code> <p>Path for SSE endpoint</p> <code>'/sse'</code> <code>message_path</code> <code>str</code> <p>Path for message endpoint</p> <code>'/messages/'</code> <code>streamable_http_path</code> <code>str</code> <p>Path for Streamable HTTP endpoint</p> <code>'/mcp'</code> <code>json_response</code> <code>bool</code> <p>Whether to use JSON responses instead of SSE for Streamable HTTP</p> <code>False</code> <code>stateless_http</code> <code>bool</code> <p>Whether to operate in stateless mode for Streamable HTTP</p> <code>False</code> <code>warn_on_duplicate_resources</code> <code>bool</code> <p>Whether to warn when duplicate resources are registered</p> <code>True</code> <code>warn_on_duplicate_tools</code> <code>bool</code> <p>Whether to warn when duplicate tools are registered</p> <code>True</code> <code>warn_on_duplicate_prompts</code> <code>bool</code> <p>Whether to warn when duplicate prompts are registered</p> <code>True</code> <code>dependencies</code> <code>Collection[str]</code> <p>List of package dependencies (currently unused)</p> <code>()</code> <code>lifespan</code> <code>Callable[[FastMCP[LifespanResultT]], AbstractAsyncContextManager[LifespanResultT]] | None</code> <p>Async context manager for server startup/shutdown lifecycle</p> <code>None</code> <code>auth</code> <code>AuthSettings | None</code> <p>Authentication settings for OAuth 2.1 support</p> <code>None</code> <code>transport_security</code> <code>TransportSecuritySettings | None</code> <p>Transport security settings</p> <code>None</code> <p>Examples:</p> <p>Basic server creation:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create a server\nmcp = FastMCP(\"My Server\")\n\n# Add a tool\n@mcp.tool()\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n# Add a resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\n# Run the server\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre> <p>Server with authentication:</p> <pre><code>from mcp.server.auth.settings import AuthSettings\nfrom pydantic import AnyHttpUrl\n\nmcp = FastMCP(\n    \"Protected Server\",\n    auth=AuthSettings(\n        issuer_url=AnyHttpUrl(\"https://auth.example.com\"),\n        resource_server_url=AnyHttpUrl(\"http://localhost:8000\"),\n        required_scopes=[\"read\", \"write\"]\n    )\n)\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.add_prompt","title":"add_prompt","text":"<pre><code>add_prompt(prompt: Prompt) -&gt; None\n</code></pre> <p>Add a prompt to the server.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>A Prompt instance to add</p> required"},{"location":"reference/mcp/server/#mcp.server.FastMCP.add_resource","title":"add_resource","text":"<pre><code>add_resource(resource: Resource) -&gt; None\n</code></pre> <p>Add a resource to the server.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>A Resource instance to add</p> required"},{"location":"reference/mcp/server/#mcp.server.FastMCP.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: AnyFunction,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; None\n</code></pre> <p>Add a tool to the server.</p> <p>The tool function can optionally request a Context object by adding a parameter with the Context type annotation. See the @tool decorator for examples.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>AnyFunction</code> <p>The function to register as a tool</p> required <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, arguments: dict[str, Any]\n) -&gt; Sequence[ContentBlock] | dict[str, Any]\n</code></pre> <p>Call a registered tool by name with the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool to call</p> required <code>arguments</code> <code>dict[str, Any]</code> <p>Dictionary of arguments to pass to the tool</p> required <p>Returns:</p> Type Description <code>Sequence[ContentBlock] | dict[str, Any]</code> <p>Tool execution result, either as content blocks or structured data</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If the tool is not found or execution fails</p> <code>ValidationError</code> <p>If the arguments don't match the tool's schema</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Decorator to register a completion handler.</p> <p>The completion handler receives: - ref: PromptReference or ResourceTemplateReference - argument: CompletionArgument with name and partial value - context: Optional CompletionContext with previously resolved arguments</p> <p>Example:</p> <pre><code>@mcp.completion()\nasync def handle_completion(ref, argument, context):\n    if isinstance(ref, ResourceTemplateReference):\n        # Return completions based on ref, argument, and context\n        return Completion(values=[\"option1\", \"option2\"])\n    return None\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.custom_route","title":"custom_route","text":"<pre><code>custom_route(\n    path: str,\n    methods: list[str],\n    name: str | None = None,\n    include_in_schema: bool = True,\n)\n</code></pre> <p>Decorator to register a custom HTTP route on the FastMCP server.</p> <p>Allows adding arbitrary HTTP endpoints outside the standard MCP protocol, which can be useful for OAuth callbacks, health checks, or admin APIs. The handler function must be an async function that accepts a Starlette Request and returns a Response.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL path for the route (e.g., \"/oauth/callback\")</p> required <code>methods</code> <code>list[str]</code> <p>List of HTTP methods to support (e.g., [\"GET\", \"POST\"])</p> required <code>name</code> <code>str | None</code> <p>Optional name for the route (to reference this route with   Starlette's reverse URL lookup feature)</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include in OpenAPI schema, defaults to True</p> <code>True</code> <p>Example:</p> <pre><code>@server.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -&gt; Response:\n    return JSONResponse({\"status\": \"ok\"})\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.get_context","title":"get_context","text":"<pre><code>get_context() -&gt; (\n    Context[ServerSession, LifespanResultT, Request]\n)\n</code></pre> <p>Get the current request context when automatic injection isn't available.</p> <p>This method provides access to the current <code>Context</code> object when you can't rely on FastMCP's automatic parameter injection. It's primarily useful in helper functions, callbacks, or other scenarios where the context isn't automatically provided via function parameters.</p> <p>In most cases, you should prefer automatic context injection by declaring a Context parameter in your tool/resource functions. Use this method only when you need context access from code that isn't directly called by FastMCP.</p> <p>You might call this method directly in:</p> <ul> <li> <p>Helper functions</p> <pre><code>mcp = FastMCP(name=\"example\")\n\nasync def log_operation(operation: str):\n    # Get context when it's not injected\n    ctx = mcp.get_context()\n    await ctx.info(f\"Performing operation: {operation}\")\n\n@mcp.tool()\nasync def main_tool(data: str) -&gt; str:\n    await log_operation(\"data_processing\")  # Helper needs context\n    return process_data(data)\n</code></pre> </li> <li> <p>Callbacks and event handlers when context is needed in async callbacks</p> <pre><code>async def progress_callback(current: int, total: int):\n    ctx = mcp.get_context()  # Access context in callback\n    await ctx.report_progress(current, total)\n\n@mcp.tool()\nasync def long_operation(data: str) -&gt; str:\n    return await process_with_callback(data, progress_callback)\n</code></pre> </li> <li> <p>Class methods when context is needed in class-based code</p> <pre><code>class DataProcessor:\n    def __init__(self, mcp_server: FastMCP):\n        self.mcp = mcp_server\n\n    async def process_chunk(self, chunk: str) -&gt; str:\n        ctx = self.mcp.get_context()  # Get context in method\n        await ctx.debug(f\"Processing chunk of size {len(chunk)}\")\n        return processed_chunk\n\nprocessor = DataProcessor(mcp)\n\n@mcp.tool()\nasync def process_data(data: str) -&gt; str:\n    return await processor.process_chunk(data)\n</code></pre> </li> </ul> <p>Returns:</p> Type Description <code>Context[ServerSession, LifespanResultT, Request]</code> <p><code>Context</code> object for the current request</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>with access to all MCP capabilities including logging, progress reporting,</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>user interaction, and session access.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>Prefer automatic injection: In most cases, declare a Context parameter in your function signature instead of calling this method:</p> <pre><code># Preferred approach\n@mcp.tool()\nasync def my_tool(data: str, ctx: Context) -&gt; str:\n    await ctx.info(\"Processing data\")\n    return result\n\n# Only use get_context() when injection isn't available\nasync def helper_function():\n    ctx = mcp.get_context()\n    await ctx.info(\"Helper called\")\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, Any] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Get a prompt by name with arguments.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts() -&gt; list[Prompt]\n</code></pre> <p>List all available prompts.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates() -&gt; list[ResourceTemplate]\n</code></pre> <p>List all available resource templates registered with this server.</p> <p>Resource templates define URI patterns that can be dynamically resolved with different parameters to access multiple related resources.</p> <p>Returns:</p> Type Description <code>list[ResourceTemplate]</code> <p>List of MCP ResourceTemplate objects containing URI templates, names,</p> <code>list[ResourceTemplate]</code> <p>and descriptions for each registered resource template.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources() -&gt; list[Resource]\n</code></pre> <p>List all available resources registered with this server.</p> <p>Returns:</p> Type Description <code>list[Resource]</code> <p>List of MCP Resource objects containing URI, name, description, and MIME type</p> <code>list[Resource]</code> <p>information for each registered resource.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools() -&gt; list[Tool]\n</code></pre> <p>List all available tools.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.prompt","title":"prompt","text":"<pre><code>prompt(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a prompt.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the prompt (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the prompt</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the prompt does</p> <code>None</code> <p>Examples:</p> <pre><code>@server.prompt()\ndef analyze_table(table_name: str) -&gt; list[Message]:\n    schema = read_table_schema(table_name)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": f\"Analyze this schema: {schema}\"\n        }\n    ]\n\n@server.prompt()\nasync def analyze_file(path: str) -&gt; list[Message]:\n    content = await read_file(path)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": {\n                \"type\": \"resource\",\n                \"resource\": {\n                    \"uri\": f\"file://{path}\",\n                    \"text\": content\n                }\n            }\n        }\n    ]\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(\n    uri: AnyUrl | str,\n) -&gt; Iterable[ReadResourceContents]\n</code></pre> <p>Read the contents of a resource by its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>AnyUrl | str</code> <p>The URI of the resource to read</p> required <p>Returns:</p> Type Description <code>Iterable[ReadResourceContents]</code> <p>Iterable of ReadResourceContents containing the resource data</p> <p>Raises:</p> Type Description <code>ResourceError</code> <p>If the resource is not found or cannot be read</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.resource","title":"resource","text":"<pre><code>resource(\n    uri: str,\n    *,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a function as a resource.</p> <p>The function will be called when the resource is read to generate its content. The function can return: - str for text content - bytes for binary content - other types will be converted to JSON</p> <p>If the URI contains parameters (e.g. \"resource://{param}\") or the function has parameters, it will be registered as a template resource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>URI for the resource (e.g. \"resource://my-resource\" or \"resource://{param}\")</p> required <code>name</code> <code>str | None</code> <p>Optional name for the resource</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the resource</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of the resource</p> <code>None</code> <code>mime_type</code> <code>str | None</code> <p>Optional MIME type for the resource</p> <code>None</code> <p>Example:</p> <pre><code>@server.resource(\"resource://my-resource\")\ndef get_data() -&gt; str:\n    return \"Hello, world!\"\n\n@server.resource(\"resource://my-resource\")\nasync get_data() -&gt; str:\n    data = await fetch_data()\n    return f\"Hello, world! {data}\"\n\n@server.resource(\"resource://{city}/weather\")\ndef get_weather(city: str) -&gt; str:\n    return f\"Weather for {city}\"\n\n@server.resource(\"resource://{city}/weather\")\nasync def get_weather(city: str) -&gt; str:\n    data = await fetch_weather(city)\n    return f\"Weather for {city}: {data}\"\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.run","title":"run","text":"<pre><code>run(\n    transport: Literal[\n        \"stdio\", \"sse\", \"streamable-http\"\n    ] = \"stdio\",\n    mount_path: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the FastMCP server. This is a synchronous function.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Literal['stdio', 'sse', 'streamable-http']</code> <p>Transport protocol to use (\"stdio\", \"sse\", or \"streamable-http\")</p> <code>'stdio'</code> <code>mount_path</code> <code>str | None</code> <p>Optional mount path for SSE transport</p> <code>None</code>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.run_sse_async","title":"run_sse_async  <code>async</code>","text":"<pre><code>run_sse_async(mount_path: str | None = None) -&gt; None\n</code></pre> <p>Run the server using SSE transport.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.run_stdio_async","title":"run_stdio_async  <code>async</code>","text":"<pre><code>run_stdio_async() -&gt; None\n</code></pre> <p>Run the server using stdio transport.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.run_streamable_http_async","title":"run_streamable_http_async  <code>async</code>","text":"<pre><code>run_streamable_http_async() -&gt; None\n</code></pre> <p>Run the server using StreamableHTTP transport.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.session_manager","title":"session_manager  <code>property</code>","text":"<pre><code>session_manager: StreamableHTTPSessionManager\n</code></pre> <p>Get the StreamableHTTP session manager.</p> <p>This is exposed to enable advanced use cases like mounting multiple FastMCP servers in a single FastAPI application.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before streamable_http_app() has been called.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.sse_app","title":"sse_app","text":"<pre><code>sse_app(mount_path: str | None = None) -&gt; Starlette\n</code></pre> <p>Return an instance of the SSE server app.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.streamable_http_app","title":"streamable_http_app","text":"<pre><code>streamable_http_app() -&gt; Starlette\n</code></pre> <p>Return an instance of the StreamableHTTP server app.</p>"},{"location":"reference/mcp/server/#mcp.server.FastMCP.tool","title":"tool","text":"<pre><code>tool(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a tool.</p> <p>Tools can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and resource access.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code> <p>Example:</p> <pre><code>@server.tool()\ndef my_tool(x: int) -&gt; str:\n    return str(x)\n\n@server.tool()\ndef tool_with_context(x: int, ctx: Context) -&gt; str:\n    ctx.info(f\"Processing {x}\")\n    return str(x)\n\n@server.tool()\nasync def async_tool(x: int, context: Context) -&gt; str:\n    await context.report_progress(50, 100)\n    return str(x)\n</code></pre>"},{"location":"reference/mcp/server/#mcp.server.Server","title":"Server","text":"<p>               Bases: <code>Generic[LifespanResultT, RequestT]</code></p>"},{"location":"reference/mcp/server/#mcp.server.Server.call_tool","title":"call_tool","text":"<pre><code>call_tool(*, validate_input: bool = True)\n</code></pre> <p>Register a tool call handler.</p> <p>Parameters:</p> Name Type Description Default <code>validate_input</code> <code>bool</code> <p>If True, validates input against inputSchema. Default is True.</p> <code>True</code> <p>The handler validates input against inputSchema (if validate_input=True), calls the tool function, and builds a CallToolResult with the results:</p> <ul> <li>Unstructured content (iterable of ContentBlock): returned in content</li> <li>Structured content (dict): returned in structuredContent, serialized JSON text returned in content</li> <li>Both: returned in content and structuredContent</li> </ul> <p>If outputSchema is defined, validates structuredContent or errors if missing.</p>"},{"location":"reference/mcp/server/#mcp.server.Server.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Provides completions for prompts and resource templates</p>"},{"location":"reference/mcp/server/#mcp.server.Server.create_initialization_options","title":"create_initialization_options","text":"<pre><code>create_initialization_options(\n    notification_options: NotificationOptions | None = None,\n    experimental_capabilities: (\n        dict[str, dict[str, Any]] | None\n    ) = None,\n) -&gt; InitializationOptions\n</code></pre> <p>Create initialization options from this server instance.</p>"},{"location":"reference/mcp/server/#mcp.server.Server.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(\n    notification_options: NotificationOptions,\n    experimental_capabilities: dict[str, dict[str, Any]],\n) -&gt; ServerCapabilities\n</code></pre> <p>Convert existing handlers to a ServerCapabilities object.</p>"},{"location":"reference/mcp/server/#mcp.server.Server.request_context","title":"request_context  <code>property</code>","text":"<pre><code>request_context: RequestContext[\n    ServerSession, LifespanResultT, RequestT\n]\n</code></pre> <p>Access the current request context for low-level MCP server operations.</p> <p>This property provides access to the <code>RequestContext</code> for the current request, which contains the session, request metadata, lifespan context, and other request-scoped information. This is the primary way to access MCP capabilities when using the low-level SDK.</p> <p>You typically access this property from within handler functions (tool handlers, resource handlers, prompt handlers, etc.) to get the context for the current client request. The context is automatically managed by the server and is only available during request processing.</p> <p>Examples:</p> <p>Logging and communication:</p> <pre><code>@app.call_tool()\nasync def my_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    await ctx.session.send_log_message(\n        level=\"info\",\n        data=\"Starting tool processing\",\n        related_request_id=ctx.request_id\n    )\n</code></pre> <p>Capability checking:</p> <pre><code>@app.call_tool()\nasync def advanced_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Use advanced features\n        response = await ctx.session.create_message(messages, max_tokens=100)\n    else:\n        # Fall back to basic functionality\n        pass\n</code></pre> <p>Accessing lifespan resources:</p> <pre><code>@app.call_tool()\nasync def database_query(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    db = ctx.lifespan_context[\"database\"]  # Access startup resource\n    results = await db.query(arguments[\"sql\"])\n    return [types.TextContent(type=\"text\", text=str(results))]\n</code></pre> <p>Returns:</p> Type Description <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p><code>RequestContext</code> for the current request,</p> <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p>containing session, metadata, and lifespan context.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>For FastMCP applications, consider using the injected <code>Context</code> parameter instead, which provides the same functionality with additional convenience methods and better ergonomics.</p>"},{"location":"reference/mcp/server/auth/","title":"mcp.server.auth","text":"<p>MCP OAuth server authorization components.</p>"},{"location":"reference/mcp/server/auth/errors/","title":"mcp.server.auth.errors","text":""},{"location":"reference/mcp/server/auth/handlers/","title":"mcp.server.auth.handlers","text":"<p>Request handlers for MCP authorization endpoints.</p>"},{"location":"reference/mcp/server/auth/handlers/authorize/","title":"mcp.server.auth.handlers.authorize","text":""},{"location":"reference/mcp/server/auth/handlers/metadata/","title":"mcp.server.auth.handlers.metadata","text":""},{"location":"reference/mcp/server/auth/handlers/register/","title":"mcp.server.auth.handlers.register","text":""},{"location":"reference/mcp/server/auth/handlers/revoke/","title":"mcp.server.auth.handlers.revoke","text":""},{"location":"reference/mcp/server/auth/handlers/revoke/#mcp.server.auth.handlers.revoke.RevocationHandler","title":"RevocationHandler  <code>dataclass</code>","text":""},{"location":"reference/mcp/server/auth/handlers/revoke/#mcp.server.auth.handlers.revoke.RevocationHandler.handle","title":"handle  <code>async</code>","text":"<pre><code>handle(request: Request) -&gt; Response\n</code></pre> <p>Handler for the OAuth 2.0 Token Revocation endpoint.</p>"},{"location":"reference/mcp/server/auth/handlers/revoke/#mcp.server.auth.handlers.revoke.RevocationRequest","title":"RevocationRequest","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/server/auth/handlers/revoke/#mcp.server.auth.handlers.revoke.RevocationRequest--see-httpsdatatrackerietforgdochtmlrfc7009section-21","title":"See https://datatracker.ietf.org/doc/html/rfc7009#section-2.1","text":""},{"location":"reference/mcp/server/auth/handlers/token/","title":"mcp.server.auth.handlers.token","text":""},{"location":"reference/mcp/server/auth/handlers/token/#mcp.server.auth.handlers.token.TokenErrorResponse","title":"TokenErrorResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>See https://datatracker.ietf.org/doc/html/rfc6749#section-5.2</p>"},{"location":"reference/mcp/server/auth/json_response/","title":"mcp.server.auth.json_response","text":""},{"location":"reference/mcp/server/auth/middleware/","title":"mcp.server.auth.middleware","text":"<p>Middleware for MCP authorization.</p>"},{"location":"reference/mcp/server/auth/middleware/auth_context/","title":"mcp.server.auth.middleware.auth_context","text":""},{"location":"reference/mcp/server/auth/middleware/auth_context/#mcp.server.auth.middleware.auth_context.AuthContextMiddleware","title":"AuthContextMiddleware","text":"<p>Middleware that extracts the authenticated user from the request and sets it in a contextvar for easy access throughout the request lifecycle.</p> <p>This middleware should be added after the AuthenticationMiddleware in the middleware stack to ensure that the user is properly authenticated before being stored in the context.</p>"},{"location":"reference/mcp/server/auth/middleware/auth_context/#mcp.server.auth.middleware.auth_context.get_access_token","title":"get_access_token","text":"<pre><code>get_access_token() -&gt; AccessToken | None\n</code></pre> <p>Get the access token from the current context.</p> <p>Returns:</p> Type Description <code>AccessToken | None</code> <p>The access token if an authenticated user is available, None otherwise.</p>"},{"location":"reference/mcp/server/auth/middleware/bearer_auth/","title":"mcp.server.auth.middleware.bearer_auth","text":""},{"location":"reference/mcp/server/auth/middleware/bearer_auth/#mcp.server.auth.middleware.bearer_auth.AuthenticatedUser","title":"AuthenticatedUser","text":"<p>               Bases: <code>SimpleUser</code></p> <p>User with authentication info.</p>"},{"location":"reference/mcp/server/auth/middleware/bearer_auth/#mcp.server.auth.middleware.bearer_auth.BearerAuthBackend","title":"BearerAuthBackend","text":"<p>               Bases: <code>AuthenticationBackend</code></p> <p>Authentication backend that validates Bearer tokens using a TokenVerifier.</p>"},{"location":"reference/mcp/server/auth/middleware/bearer_auth/#mcp.server.auth.middleware.bearer_auth.RequireAuthMiddleware","title":"RequireAuthMiddleware","text":"<p>Middleware that requires a valid Bearer token in the Authorization header.</p> <p>This will validate the token with the auth provider and store the resulting auth info in the request state.</p>"},{"location":"reference/mcp/server/auth/middleware/bearer_auth/#mcp.server.auth.middleware.bearer_auth.RequireAuthMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    app: Any,\n    required_scopes: list[str],\n    resource_metadata_url: AnyHttpUrl | None = None,\n)\n</code></pre> <p>Initialize the middleware.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Any</code> <p>ASGI application</p> required <code>required_scopes</code> <code>list[str]</code> <p>List of scopes that the token must have</p> required <code>resource_metadata_url</code> <code>AnyHttpUrl | None</code> <p>Optional protected resource metadata URL for WWW-Authenticate header</p> <code>None</code>"},{"location":"reference/mcp/server/auth/middleware/client_auth/","title":"mcp.server.auth.middleware.client_auth","text":""},{"location":"reference/mcp/server/auth/middleware/client_auth/#mcp.server.auth.middleware.client_auth.ClientAuthenticator","title":"ClientAuthenticator","text":"<p>ClientAuthenticator is a callable which validates requests from a client application, used to verify /token calls. If, during registration, the client requested to be issued a secret, the authenticator asserts that /token calls must be authenticated with that same token. NOTE: clients can opt for no authentication during registration, in which case this logic is skipped.</p>"},{"location":"reference/mcp/server/auth/middleware/client_auth/#mcp.server.auth.middleware.client_auth.ClientAuthenticator.__init__","title":"__init__","text":"<pre><code>__init__(\n    provider: OAuthAuthorizationServerProvider[\n        Any, Any, Any\n    ],\n)\n</code></pre> <p>Initialize the dependency.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>OAuthAuthorizationServerProvider[Any, Any, Any]</code> <p>Provider to look up client information</p> required"},{"location":"reference/mcp/server/auth/provider/","title":"mcp.server.auth.provider","text":""},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider","title":"OAuthAuthorizationServerProvider","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[AuthorizationCodeT, RefreshTokenT, AccessTokenT]</code></p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.authorize","title":"authorize  <code>async</code>","text":"<pre><code>authorize(\n    client: OAuthClientInformationFull,\n    params: AuthorizationParams,\n) -&gt; str\n</code></pre> <p>Called as part of the /authorize endpoint, and returns a URL that the client will be redirected to. Many MCP implementations will redirect to a third-party provider to perform a second OAuth exchange with that provider. In this sort of setup, the client has an OAuth connection with the MCP server, and the MCP server has an OAuth connection with the 3rd-party provider. At the end of this flow, the client should be redirected to the redirect_uri from params.redirect_uri.</p> <p>+--------+     +------------+     +-------------------+ |        |     |            |     |                   | | Client | --&gt; | MCP Server | --&gt; | 3rd Party OAuth   | |        |     |            |     | Server            | +--------+     +------------+     +-------------------+                     |   ^                  | +------------+      |   |                  | |            |      |   |    Redirect      | |redirect_uri|&lt;-----+   +------------------+ |            | +------------+</p> <p>Implementations will need to define another handler on the MCP server return flow to perform the second redirect, and generate and store an authorization code as part of completing the OAuth authorization step.</p> <p>Implementations SHOULD generate an authorization code with at least 160 bits of entropy, and MUST generate an authorization code with at least 128 bits of entropy. See https://datatracker.ietf.org/doc/html/rfc6749#section-10.10.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuthClientInformationFull</code> <p>The client requesting authorization.</p> required <code>params</code> <code>AuthorizationParams</code> <p>The parameters of the authorization request.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A URL to redirect the client to for authorization.</p> <p>Raises:</p> Type Description <code>AuthorizeError</code> <p>If the authorization request is invalid.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.exchange_authorization_code","title":"exchange_authorization_code  <code>async</code>","text":"<pre><code>exchange_authorization_code(\n    client: OAuthClientInformationFull,\n    authorization_code: AuthorizationCodeT,\n) -&gt; OAuthToken\n</code></pre> <p>Exchanges an authorization code for an access token and refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuthClientInformationFull</code> <p>The client exchanging the authorization code.</p> required <code>authorization_code</code> <code>AuthorizationCodeT</code> <p>The authorization code to exchange.</p> required <p>Returns:</p> Type Description <code>OAuthToken</code> <p>The OAuth token, containing access and refresh tokens.</p> <p>Raises:</p> Type Description <code>TokenError</code> <p>If the request is invalid</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.exchange_refresh_token","title":"exchange_refresh_token  <code>async</code>","text":"<pre><code>exchange_refresh_token(\n    client: OAuthClientInformationFull,\n    refresh_token: RefreshTokenT,\n    scopes: list[str],\n) -&gt; OAuthToken\n</code></pre> <p>Exchanges a refresh token for an access token and refresh token.</p> <p>Implementations SHOULD rotate both the access token and refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuthClientInformationFull</code> <p>The client exchanging the refresh token.</p> required <code>refresh_token</code> <code>RefreshTokenT</code> <p>The refresh token to exchange.</p> required <code>scopes</code> <code>list[str]</code> <p>Optional scopes to request with the new access token.</p> required <p>Returns:</p> Type Description <code>OAuthToken</code> <p>The OAuth token, containing access and refresh tokens.</p> <p>Raises:</p> Type Description <code>TokenError</code> <p>If the request is invalid</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.get_client","title":"get_client  <code>async</code>","text":"<pre><code>get_client(\n    client_id: str,\n) -&gt; OAuthClientInformationFull | None\n</code></pre> <p>Retrieves client information by client ID.</p> <p>Implementors MAY raise NotImplementedError if dynamic client registration is disabled in ClientRegistrationOptions.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The ID of the client to retrieve.</p> required <p>Returns:</p> Type Description <code>OAuthClientInformationFull | None</code> <p>The client information, or None if the client does not exist.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.load_access_token","title":"load_access_token  <code>async</code>","text":"<pre><code>load_access_token(token: str) -&gt; AccessTokenT | None\n</code></pre> <p>Loads an access token by its token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The access token to verify.</p> required <p>Returns:</p> Type Description <code>AccessTokenT | None</code> <p>The AuthInfo, or None if the token is invalid.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.load_authorization_code","title":"load_authorization_code  <code>async</code>","text":"<pre><code>load_authorization_code(\n    client: OAuthClientInformationFull,\n    authorization_code: str,\n) -&gt; AuthorizationCodeT | None\n</code></pre> <p>Loads an AuthorizationCode by its code.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuthClientInformationFull</code> <p>The client that requested the authorization code.</p> required <code>authorization_code</code> <code>str</code> <p>The authorization code to get the challenge for.</p> required <p>Returns:</p> Type Description <code>AuthorizationCodeT | None</code> <p>The AuthorizationCode, or None if not found</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.load_refresh_token","title":"load_refresh_token  <code>async</code>","text":"<pre><code>load_refresh_token(\n    client: OAuthClientInformationFull, refresh_token: str\n) -&gt; RefreshTokenT | None\n</code></pre> <p>Loads a RefreshToken by its token string.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuthClientInformationFull</code> <p>The client that is requesting to load the refresh token.</p> required <code>refresh_token</code> <code>str</code> <p>The refresh token string to load.</p> required <p>Returns:</p> Type Description <code>RefreshTokenT | None</code> <p>The RefreshToken object if found, or None if not found.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.register_client","title":"register_client  <code>async</code>","text":"<pre><code>register_client(\n    client_info: OAuthClientInformationFull,\n) -&gt; None\n</code></pre> <p>Saves client information as part of registering it.</p> <p>Implementors MAY raise NotImplementedError if dynamic client registration is disabled in ClientRegistrationOptions.</p> <p>Parameters:</p> Name Type Description Default <code>client_info</code> <code>OAuthClientInformationFull</code> <p>The client metadata to register.</p> required <p>Raises:</p> Type Description <code>RegistrationError</code> <p>If the client metadata is invalid.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.OAuthAuthorizationServerProvider.revoke_token","title":"revoke_token  <code>async</code>","text":"<pre><code>revoke_token(token: AccessTokenT | RefreshTokenT) -&gt; None\n</code></pre> <p>Revokes an access or refresh token.</p> <p>If the given token is invalid or already revoked, this method should do nothing.</p> <p>Implementations SHOULD revoke both the access token and its corresponding refresh token, regardless of which of the access token or refresh token is provided.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>AccessTokenT | RefreshTokenT</code> <p>the token to revoke</p> required"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.ProviderTokenVerifier","title":"ProviderTokenVerifier","text":"<p>               Bases: <code>TokenVerifier</code></p> <p>Token verifier that uses an OAuthAuthorizationServerProvider.</p> <p>This is provided for backwards compatibility with existing auth_server_provider configurations. For new implementations using AS/RS separation, consider using the TokenVerifier protocol with a dedicated implementation like IntrospectionTokenVerifier.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.ProviderTokenVerifier.verify_token","title":"verify_token  <code>async</code>","text":"<pre><code>verify_token(token: str) -&gt; AccessToken | None\n</code></pre> <p>Verify token using the provider's load_access_token method.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.TokenVerifier","title":"TokenVerifier","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for verifying bearer tokens.</p>"},{"location":"reference/mcp/server/auth/provider/#mcp.server.auth.provider.TokenVerifier.verify_token","title":"verify_token  <code>async</code>","text":"<pre><code>verify_token(token: str) -&gt; AccessToken | None\n</code></pre> <p>Verify a bearer token and return access info if valid.</p>"},{"location":"reference/mcp/server/auth/routes/","title":"mcp.server.auth.routes","text":""},{"location":"reference/mcp/server/auth/routes/#mcp.server.auth.routes.create_protected_resource_routes","title":"create_protected_resource_routes","text":"<pre><code>create_protected_resource_routes(\n    resource_url: AnyHttpUrl,\n    authorization_servers: list[AnyHttpUrl],\n    scopes_supported: list[str] | None = None,\n    resource_name: str | None = None,\n    resource_documentation: AnyHttpUrl | None = None,\n) -&gt; list[Route]\n</code></pre> <p>Create routes for OAuth 2.0 Protected Resource Metadata (RFC 9728).</p> <p>Parameters:</p> Name Type Description Default <code>resource_url</code> <code>AnyHttpUrl</code> <p>The URL of this resource server</p> required <code>authorization_servers</code> <code>list[AnyHttpUrl]</code> <p>List of authorization servers that can issue tokens</p> required <code>scopes_supported</code> <code>list[str] | None</code> <p>Optional list of scopes supported by this resource</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Route]</code> <p>List of Starlette routes for protected resource metadata</p>"},{"location":"reference/mcp/server/auth/routes/#mcp.server.auth.routes.validate_issuer_url","title":"validate_issuer_url","text":"<pre><code>validate_issuer_url(url: AnyHttpUrl)\n</code></pre> <p>Validate that the issuer URL meets OAuth 2.0 requirements.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>AnyHttpUrl</code> <p>The issuer URL to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the issuer URL is invalid</p>"},{"location":"reference/mcp/server/auth/settings/","title":"mcp.server.auth.settings","text":""},{"location":"reference/mcp/server/elicitation/","title":"mcp.server.elicitation","text":"<p>Elicitation utilities for MCP servers.</p>"},{"location":"reference/mcp/server/elicitation/#mcp.server.elicitation.AcceptedElicitation","title":"AcceptedElicitation","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ElicitSchemaModelT]</code></p> <p>Result when user accepts the elicitation.</p>"},{"location":"reference/mcp/server/elicitation/#mcp.server.elicitation.CancelledElicitation","title":"CancelledElicitation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result when user cancels the elicitation.</p>"},{"location":"reference/mcp/server/elicitation/#mcp.server.elicitation.DeclinedElicitation","title":"DeclinedElicitation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result when user declines the elicitation.</p>"},{"location":"reference/mcp/server/elicitation/#mcp.server.elicitation.elicit_with_validation","title":"elicit_with_validation  <code>async</code>","text":"<pre><code>elicit_with_validation(\n    session: ServerSession,\n    message: str,\n    schema: type[ElicitSchemaModelT],\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitationResult[ElicitSchemaModelT]\n</code></pre> <p>Elicit information from the client/user with schema validation.</p> <p>This method can be used to interactively ask for additional information from the client within a tool's execution. The client might display the message to the user and collect a response according to the provided schema. Or in case a client is an agent, it might decide how to handle the elicitation -- either by asking the user or automatically generating a response.</p>"},{"location":"reference/mcp/server/fastmcp/","title":"mcp.server.fastmcp","text":"<p>FastMCP - A more ergonomic interface for MCP servers.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context","title":"Context","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ServerSessionT, LifespanContextT, RequestT]</code></p> <p>High-level context object providing convenient access to MCP capabilities.</p> <p>This is FastMCP's user-friendly wrapper around the underlying <code>RequestContext</code> that provides the same functionality with additional convenience methods and better ergonomics. It gets automatically injected into FastMCP tool and resource functions that declare it in their type hints, eliminating the need to manually access the request context.</p> <p>The Context object provides access to all MCP capabilities including logging, progress reporting, resource reading, user interaction, capability checking, and access to the underlying session and request metadata. It's the recommended way to interact with MCP functionality in FastMCP applications.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context--automatic-injection","title":"Automatic injection","text":"<p>Context is automatically injected into functions based on type hints. The parameter name can be anything as long as it's annotated with <code>Context</code>. The context parameter is optional - tools that don't need it can omit it entirely.</p> <pre><code>from mcp.server.fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"example\")\n\n@mcp.tool()\nasync def simple_tool(data: str) -&gt; str:\n    # No context needed\n    return f\"Processed: {data}\"\n\n@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Context automatically injected\n    await ctx.info(\"Starting processing\")\n    return f\"Processed: {data}\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context--relationship-to-requestcontext","title":"Relationship to RequestContext","text":"<p>Context is a thin wrapper around <code>RequestContext</code> that provides the same underlying functionality with additional convenience methods:</p> <ul> <li>Context convenience methods: <code>ctx.info()</code>, <code>ctx.error()</code>, <code>ctx.elicit()</code>, etc.</li> <li>Direct RequestContext access: <code>ctx.request_context</code> for low-level operations</li> <li>Session access: <code>ctx.session</code> for advanced ServerSession functionality</li> <li>Request metadata: <code>ctx.request_id</code>, access to lifespan context, etc.</li> </ul>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context--capabilities-provided","title":"Capabilities provided","text":"<p>Logging: Send structured log messages to the client with automatic request linking:</p> <pre><code>await ctx.debug(\"Detailed debug information\")\nawait ctx.info(\"General status updates\")\nawait ctx.warning(\"Important warnings\")\nawait ctx.error(\"Error conditions\")\n</code></pre> <p>Progress reporting: Keep users informed during long operations:</p> <pre><code>for i in range(100):\n    await ctx.report_progress(i, 100, f\"Processing item {i}\")\n    # ... do work\n</code></pre> <p>User interaction: Collect additional information during tool execution:</p> <pre><code>class UserPrefs(BaseModel):\n    format: str\n    detailed: bool\n\nresult = await ctx.elicit(\"How should I format the output?\", UserPrefs)\nif result.action == \"accept\":\n    format_data(data, result.data.format)\n</code></pre> <p>Resource access: Read MCP resources during tool execution:</p> <pre><code>content = await ctx.read_resource(\"file://data/config.json\")\n</code></pre> <p>Capability checking: Verify client support before using advanced features:</p> <pre><code>if ctx.session.check_client_capability(types.ClientCapabilities(sampling=...)):\n    # Use advanced features\n    pass\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context--examples","title":"Examples","text":"<p>Complete tool with context usage:</p> <pre><code>from pydantic import BaseModel\nfrom mcp.server.fastmcp import FastMCP, Context\n\nclass ProcessingOptions(BaseModel):\n    format: str\n    include_metadata: bool\n\nmcp = FastMCP(name=\"processor\")\n\n@mcp.tool()\nasync def process_data(\n    data: str,\n    ctx: Context,\n    auto_format: bool = False\n) -&gt; str:\n    await ctx.info(f\"Starting to process {len(data)} characters\")\n\n    # Get user preferences if not auto-formatting\n    if not auto_format:\n        if ctx.session.check_client_capability(\n            types.ClientCapabilities(elicitation=types.ElicitationCapability())\n        ):\n            prefs_result = await ctx.elicit(\n                \"How would you like the data processed?\",\n                ProcessingOptions\n            )\n            if prefs_result.action == \"accept\":\n                format_type = prefs_result.data.format\n                include_meta = prefs_result.data.include_metadata\n            else:\n                await ctx.warning(\"Using default format\")\n                format_type = \"standard\"\n                include_meta = False\n        else:\n            format_type = \"standard\"\n            include_meta = False\n    else:\n        format_type = \"auto\"\n        include_meta = True\n\n    # Process with progress updates\n    for i in range(0, len(data), 100):\n        chunk = data[i:i+100]\n        await ctx.report_progress(i, len(data), f\"Processing chunk {i//100 + 1}\")\n        # ... process chunk\n\n    await ctx.info(f\"Processing complete with format: {format_type}\")\n    return processed_data\n</code></pre> Note <p>Context objects are request-scoped and automatically managed by FastMCP. Don't store references to them beyond the request lifecycle. Each tool invocation gets a fresh Context instance tied to that specific request.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: str | None\n</code></pre> <p>Get the client ID if available.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.debug","title":"debug  <code>async</code>","text":"<pre><code>debug(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send a debug log message.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str, schema: type[ElicitSchemaModelT]\n) -&gt; ElicitationResult[ElicitSchemaModelT]\n</code></pre> <p>Elicit structured information from the client or user during tool execution.</p> <p>This method enables interactive data collection from clients during tool processing. The client may display the message to the user and collect a response according to the provided Pydantic schema, or if the client is an agent, it may automatically generate an appropriate response. This is useful for gathering additional parameters, user preferences, or confirmation before proceeding with operations.</p> <p>You typically access this method through the <code>Context</code> object injected into your FastMCP tool functions. Always check that the client supports elicitation using <code>check_client_capability</code> before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt or question to present to the user. Should clearly explain what information is being requested and why it's needed.</p> required <code>schema</code> <code>type[ElicitSchemaModelT]</code> <p>A Pydantic model class defining the expected response structure. According to the MCP specification, only primitive types (str, int, float, bool) and simple containers (list, dict) are allowed - no complex nested objects.</p> required <p>Returns:</p> Type Description <code>ElicitationResult[ElicitSchemaModelT]</code> <p><code>ElicitationResult</code> containing:</p> <code>ElicitationResult[ElicitSchemaModelT]</code> <ul> <li><code>action</code>: One of \"accept\", \"decline\", or \"cancel\" indicating user response</li> </ul> <code>ElicitationResult[ElicitSchemaModelT]</code> <ul> <li><code>data</code>: The structured response data (only populated if action is \"accept\")</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>ValidationError</code> <p>If the client response doesn't match the provided schema.</p> <code>Various exceptions</code> <p>Depending on client implementation and user interaction.</p> <p>Examples:</p> <p>Collect user preferences before processing:</p> <pre><code>from pydantic import BaseModel\nfrom mcp.server.fastmcp import FastMCP, Context\n\nclass ProcessingOptions(BaseModel):\n    format: str\n    include_metadata: bool\n    max_items: int\n\nmcp = FastMCP(name=\"example-server\")\n\n@mcp.tool()\nasync def process_data(data: str, ctx: Context) -&gt; str:\n    # Check if client supports elicitation\n    if not ctx.session.check_client_capability(\n        types.ClientCapabilities(elicitation=types.ElicitationCapability())\n    ):\n        # Fall back to default processing\n        return process_with_defaults(data)\n\n    # Ask user for processing preferences\n    result = await ctx.elicit(\n        \"How would you like me to process this data?\",\n        ProcessingOptions\n    )\n\n    if result.action == \"accept\":\n        options = result.data\n        await ctx.info(f\"Processing with format: {options.format}\")\n        return process_with_options(data, options)\n    elif result.action == \"decline\":\n        return process_with_defaults(data)\n    else:  # cancel\n        return \"Processing cancelled by user\"\n</code></pre> <p>Confirm before destructive operations:</p> <pre><code>class ConfirmDelete(BaseModel):\n    confirm: bool\n    reason: str\n\n@mcp.tool()\nasync def delete_files(pattern: str, ctx: Context) -&gt; str:\n    files = find_matching_files(pattern)\n\n    result = await ctx.elicit(\n        f\"About to delete {len(files)} files matching '{pattern}'. Continue?\",\n        ConfirmDelete\n    )\n\n    if result.action == \"accept\" and result.data.confirm:\n        await ctx.info(f\"Deletion confirmed: {result.data.reason}\")\n        return delete_files(files)\n    else:\n        return \"Deletion cancelled\"\n</code></pre> <p>Handle different response types:</p> <pre><code>class UserChoice(BaseModel):\n    option: str  # \"auto\", \"manual\", \"skip\"\n    details: str\n\n@mcp.tool()\nasync def configure_system(ctx: Context) -&gt; str:\n    result = await ctx.elicit(\n        \"How should I configure the system?\",\n        UserChoice\n    )\n\n    match result.action:\n        case \"accept\":\n            choice = result.data\n            await ctx.info(f\"User selected: {choice.option}\")\n            return configure_with_choice(choice)\n        case \"decline\":\n            await ctx.warning(\"User declined configuration\")\n            return \"Configuration skipped by user\"\n        case \"cancel\":\n            await ctx.info(\"Configuration cancelled\")\n            return \"Operation cancelled\"\n</code></pre> Note <p>The client determines how to handle elicitation requests. Some clients may show interactive forms to users, while others may automatically generate responses based on context. Always handle all possible action values (\"accept\", \"decline\", \"cancel\") in your code and provide appropriate fallbacks for clients that don't support elicitation.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.error","title":"error  <code>async</code>","text":"<pre><code>error(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send an error log message.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.fastmcp","title":"fastmcp  <code>property</code>","text":"<pre><code>fastmcp: FastMCP\n</code></pre> <p>Access to the FastMCP server.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.info","title":"info  <code>async</code>","text":"<pre><code>info(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send an info log message.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.log","title":"log  <code>async</code>","text":"<pre><code>log(\n    level: Literal[\"debug\", \"info\", \"warning\", \"error\"],\n    message: str,\n    *,\n    logger_name: str | None = None\n) -&gt; None\n</code></pre> <p>Send a log message to the client.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['debug', 'info', 'warning', 'error']</code> <p>Log level (debug, info, warning, error)</p> required <code>message</code> <code>str</code> <p>Log message</p> required <code>logger_name</code> <code>str | None</code> <p>Optional logger name</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(\n    uri: str | AnyUrl,\n) -&gt; Iterable[ReadResourceContents]\n</code></pre> <p>Read a resource by URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str | AnyUrl</code> <p>Resource URI to read</p> required <p>Returns:</p> Type Description <code>Iterable[ReadResourceContents]</code> <p>The resource content as either text or bytes</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.report_progress","title":"report_progress  <code>async</code>","text":"<pre><code>report_progress(\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Report progress for the current operation.</p> <p>Parameters:</p> Name Type Description Default <code>progress</code> <code>float</code> <p>Current progress value e.g. 24</p> required <code>total</code> <code>float | None</code> <p>Optional total value e.g. 100</p> <code>None</code> <code>message</code> <code>str | None</code> <p>Optional message e.g. Starting render...</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.request_context","title":"request_context  <code>property</code>","text":"<pre><code>request_context: RequestContext[\n    ServerSessionT, LifespanContextT, RequestT\n]\n</code></pre> <p>Access to the underlying RequestContext for low-level operations.</p> <p>This property provides direct access to the <code>RequestContext</code> that this Context wraps. Use this when you need low-level access to request metadata, lifespan context, or other features not exposed by Context's convenience methods.</p> <p>Most users should prefer Context's convenience methods like <code>info()</code>, <code>elicit()</code>, etc. rather than accessing the underlying RequestContext directly.</p> <p>Returns:</p> Type Description <code>RequestContext[ServerSessionT, LifespanContextT, RequestT]</code> <p>The underlying <code>RequestContext</code> containing</p> <code>RequestContext[ServerSessionT, LifespanContextT, RequestT]</code> <p>session, metadata, and lifespan context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If called outside of a request context.</p> Example <pre><code>@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Access lifespan context directly\n    db = ctx.request_context.lifespan_context[\"database\"]\n\n    # Access request metadata\n    progress_token = ctx.request_context.meta.progressToken if ctx.request_context.meta else None\n\n    return processed_data\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre> <p>Get the unique identifier for the current request.</p> <p>This ID uniquely identifies the current client request and is useful for logging, tracing, error reporting, and linking related operations. It's automatically used by Context's convenience methods when sending notifications or responses to ensure they're associated with the correct request.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique request identifier that can be used for tracing and logging.</p> Example <pre><code>@mcp.tool()\nasync def traceable_tool(data: str, ctx: Context) -&gt; str:\n    # Log with request ID for traceability\n    print(f\"Processing request {ctx.request_id}\")\n\n    # Request ID is automatically included in Context methods\n    await ctx.info(\"Starting processing\")  # Links to this request\n\n    return processed_data\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.session","title":"session  <code>property</code>","text":"<pre><code>session: ServerSession\n</code></pre> <p>Access to the underlying ServerSession for advanced MCP operations.</p> <p>This property provides direct access to the <code>ServerSession</code> for advanced operations not covered by Context's convenience methods. Use this when you need direct session control, capability checking, or low-level MCP protocol operations.</p> <p>Most users should prefer Context's convenience methods (<code>info()</code>, <code>elicit()</code>, etc.) which internally use this session with appropriate request linking.</p> <p>Returns:</p> Type Description <code>ServerSession</code> <p><code>ServerSession</code>: The session for</p> <code>ServerSession</code> <p>communicating with the client and accessing advanced MCP features.</p> <p>Examples:</p> <p>Capability checking before using advanced features:</p> <pre><code>@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Check client capabilities\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Use LLM sampling\n        response = await ctx.session.create_message(\n            messages=[types.SamplingMessage(...)],\n            max_tokens=100\n        )\n        return response.content.text\n    else:\n        return \"Client doesn't support LLM sampling\"\n</code></pre> <p>Direct resource notifications:</p> <pre><code>@mcp.tool()\nasync def update_resource(uri: str, ctx: Context) -&gt; str:\n    # ... update the resource ...\n\n    # Notify client of resource changes\n    await ctx.session.send_resource_updated(AnyUrl(uri))\n    return \"Resource updated\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Context.warning","title":"warning  <code>async</code>","text":"<pre><code>warning(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send a warning log message.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP","title":"FastMCP","text":"<p>               Bases: <code>Generic[LifespanResultT]</code></p> <p>A high-level ergonomic interface for creating MCP servers.</p> <p>FastMCP provides a decorator-based API for building MCP servers with automatic parameter validation, structured output support, and built-in transport handling. It supports stdio, SSE, and Streamable HTTP transports out of the box.</p> <p>Features include automatic validation using Pydantic, structured output conversion, context injection for MCP capabilities, lifespan management, multiple transport support, and built-in OAuth 2.1 authentication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Human-readable name for the server. If None, defaults to \"FastMCP\"</p> <code>None</code> <code>instructions</code> <code>str | None</code> <p>Optional instructions/description for the server</p> <code>None</code> <code>auth_server_provider</code> <code>OAuthAuthorizationServerProvider[Any, Any, Any] | None</code> <p>OAuth authorization server provider for authentication</p> <code>None</code> <code>token_verifier</code> <code>TokenVerifier | None</code> <p>Token verifier for validating OAuth tokens</p> <code>None</code> <code>event_store</code> <code>EventStore | None</code> <p>Event store for Streamable HTTP transport persistence</p> <code>None</code> <code>tools</code> <code>list[Tool] | None</code> <p>Pre-configured tools to register with the server</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode for additional logging</p> <code>False</code> <code>log_level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'INFO'</code> <code>host</code> <code>str</code> <p>Host address for HTTP transports</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port number for HTTP transports</p> <code>8000</code> <code>mount_path</code> <code>str</code> <p>Base mount path for SSE transport</p> <code>'/'</code> <code>sse_path</code> <code>str</code> <p>Path for SSE endpoint</p> <code>'/sse'</code> <code>message_path</code> <code>str</code> <p>Path for message endpoint</p> <code>'/messages/'</code> <code>streamable_http_path</code> <code>str</code> <p>Path for Streamable HTTP endpoint</p> <code>'/mcp'</code> <code>json_response</code> <code>bool</code> <p>Whether to use JSON responses instead of SSE for Streamable HTTP</p> <code>False</code> <code>stateless_http</code> <code>bool</code> <p>Whether to operate in stateless mode for Streamable HTTP</p> <code>False</code> <code>warn_on_duplicate_resources</code> <code>bool</code> <p>Whether to warn when duplicate resources are registered</p> <code>True</code> <code>warn_on_duplicate_tools</code> <code>bool</code> <p>Whether to warn when duplicate tools are registered</p> <code>True</code> <code>warn_on_duplicate_prompts</code> <code>bool</code> <p>Whether to warn when duplicate prompts are registered</p> <code>True</code> <code>dependencies</code> <code>Collection[str]</code> <p>List of package dependencies (currently unused)</p> <code>()</code> <code>lifespan</code> <code>Callable[[FastMCP[LifespanResultT]], AbstractAsyncContextManager[LifespanResultT]] | None</code> <p>Async context manager for server startup/shutdown lifecycle</p> <code>None</code> <code>auth</code> <code>AuthSettings | None</code> <p>Authentication settings for OAuth 2.1 support</p> <code>None</code> <code>transport_security</code> <code>TransportSecuritySettings | None</code> <p>Transport security settings</p> <code>None</code> <p>Examples:</p> <p>Basic server creation:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create a server\nmcp = FastMCP(\"My Server\")\n\n# Add a tool\n@mcp.tool()\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n# Add a resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\n# Run the server\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre> <p>Server with authentication:</p> <pre><code>from mcp.server.auth.settings import AuthSettings\nfrom pydantic import AnyHttpUrl\n\nmcp = FastMCP(\n    \"Protected Server\",\n    auth=AuthSettings(\n        issuer_url=AnyHttpUrl(\"https://auth.example.com\"),\n        resource_server_url=AnyHttpUrl(\"http://localhost:8000\"),\n        required_scopes=[\"read\", \"write\"]\n    )\n)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.add_prompt","title":"add_prompt","text":"<pre><code>add_prompt(prompt: Prompt) -&gt; None\n</code></pre> <p>Add a prompt to the server.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>A Prompt instance to add</p> required"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.add_resource","title":"add_resource","text":"<pre><code>add_resource(resource: Resource) -&gt; None\n</code></pre> <p>Add a resource to the server.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>A Resource instance to add</p> required"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: AnyFunction,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; None\n</code></pre> <p>Add a tool to the server.</p> <p>The tool function can optionally request a Context object by adding a parameter with the Context type annotation. See the @tool decorator for examples.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>AnyFunction</code> <p>The function to register as a tool</p> required <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, arguments: dict[str, Any]\n) -&gt; Sequence[ContentBlock] | dict[str, Any]\n</code></pre> <p>Call a registered tool by name with the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool to call</p> required <code>arguments</code> <code>dict[str, Any]</code> <p>Dictionary of arguments to pass to the tool</p> required <p>Returns:</p> Type Description <code>Sequence[ContentBlock] | dict[str, Any]</code> <p>Tool execution result, either as content blocks or structured data</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If the tool is not found or execution fails</p> <code>ValidationError</code> <p>If the arguments don't match the tool's schema</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Decorator to register a completion handler.</p> <p>The completion handler receives: - ref: PromptReference or ResourceTemplateReference - argument: CompletionArgument with name and partial value - context: Optional CompletionContext with previously resolved arguments</p> <p>Example:</p> <pre><code>@mcp.completion()\nasync def handle_completion(ref, argument, context):\n    if isinstance(ref, ResourceTemplateReference):\n        # Return completions based on ref, argument, and context\n        return Completion(values=[\"option1\", \"option2\"])\n    return None\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.custom_route","title":"custom_route","text":"<pre><code>custom_route(\n    path: str,\n    methods: list[str],\n    name: str | None = None,\n    include_in_schema: bool = True,\n)\n</code></pre> <p>Decorator to register a custom HTTP route on the FastMCP server.</p> <p>Allows adding arbitrary HTTP endpoints outside the standard MCP protocol, which can be useful for OAuth callbacks, health checks, or admin APIs. The handler function must be an async function that accepts a Starlette Request and returns a Response.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL path for the route (e.g., \"/oauth/callback\")</p> required <code>methods</code> <code>list[str]</code> <p>List of HTTP methods to support (e.g., [\"GET\", \"POST\"])</p> required <code>name</code> <code>str | None</code> <p>Optional name for the route (to reference this route with   Starlette's reverse URL lookup feature)</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include in OpenAPI schema, defaults to True</p> <code>True</code> <p>Example:</p> <pre><code>@server.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -&gt; Response:\n    return JSONResponse({\"status\": \"ok\"})\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.get_context","title":"get_context","text":"<pre><code>get_context() -&gt; (\n    Context[ServerSession, LifespanResultT, Request]\n)\n</code></pre> <p>Get the current request context when automatic injection isn't available.</p> <p>This method provides access to the current <code>Context</code> object when you can't rely on FastMCP's automatic parameter injection. It's primarily useful in helper functions, callbacks, or other scenarios where the context isn't automatically provided via function parameters.</p> <p>In most cases, you should prefer automatic context injection by declaring a Context parameter in your tool/resource functions. Use this method only when you need context access from code that isn't directly called by FastMCP.</p> <p>You might call this method directly in:</p> <ul> <li> <p>Helper functions</p> <pre><code>mcp = FastMCP(name=\"example\")\n\nasync def log_operation(operation: str):\n    # Get context when it's not injected\n    ctx = mcp.get_context()\n    await ctx.info(f\"Performing operation: {operation}\")\n\n@mcp.tool()\nasync def main_tool(data: str) -&gt; str:\n    await log_operation(\"data_processing\")  # Helper needs context\n    return process_data(data)\n</code></pre> </li> <li> <p>Callbacks and event handlers when context is needed in async callbacks</p> <pre><code>async def progress_callback(current: int, total: int):\n    ctx = mcp.get_context()  # Access context in callback\n    await ctx.report_progress(current, total)\n\n@mcp.tool()\nasync def long_operation(data: str) -&gt; str:\n    return await process_with_callback(data, progress_callback)\n</code></pre> </li> <li> <p>Class methods when context is needed in class-based code</p> <pre><code>class DataProcessor:\n    def __init__(self, mcp_server: FastMCP):\n        self.mcp = mcp_server\n\n    async def process_chunk(self, chunk: str) -&gt; str:\n        ctx = self.mcp.get_context()  # Get context in method\n        await ctx.debug(f\"Processing chunk of size {len(chunk)}\")\n        return processed_chunk\n\nprocessor = DataProcessor(mcp)\n\n@mcp.tool()\nasync def process_data(data: str) -&gt; str:\n    return await processor.process_chunk(data)\n</code></pre> </li> </ul> <p>Returns:</p> Type Description <code>Context[ServerSession, LifespanResultT, Request]</code> <p><code>Context</code> object for the current request</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>with access to all MCP capabilities including logging, progress reporting,</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>user interaction, and session access.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>Prefer automatic injection: In most cases, declare a Context parameter in your function signature instead of calling this method:</p> <pre><code># Preferred approach\n@mcp.tool()\nasync def my_tool(data: str, ctx: Context) -&gt; str:\n    await ctx.info(\"Processing data\")\n    return result\n\n# Only use get_context() when injection isn't available\nasync def helper_function():\n    ctx = mcp.get_context()\n    await ctx.info(\"Helper called\")\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, Any] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Get a prompt by name with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts() -&gt; list[Prompt]\n</code></pre> <p>List all available prompts.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates() -&gt; list[ResourceTemplate]\n</code></pre> <p>List all available resource templates registered with this server.</p> <p>Resource templates define URI patterns that can be dynamically resolved with different parameters to access multiple related resources.</p> <p>Returns:</p> Type Description <code>list[ResourceTemplate]</code> <p>List of MCP ResourceTemplate objects containing URI templates, names,</p> <code>list[ResourceTemplate]</code> <p>and descriptions for each registered resource template.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources() -&gt; list[Resource]\n</code></pre> <p>List all available resources registered with this server.</p> <p>Returns:</p> Type Description <code>list[Resource]</code> <p>List of MCP Resource objects containing URI, name, description, and MIME type</p> <code>list[Resource]</code> <p>information for each registered resource.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools() -&gt; list[Tool]\n</code></pre> <p>List all available tools.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.prompt","title":"prompt","text":"<pre><code>prompt(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a prompt.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the prompt (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the prompt</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the prompt does</p> <code>None</code> <p>Examples:</p> <pre><code>@server.prompt()\ndef analyze_table(table_name: str) -&gt; list[Message]:\n    schema = read_table_schema(table_name)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": f\"Analyze this schema: {schema}\"\n        }\n    ]\n\n@server.prompt()\nasync def analyze_file(path: str) -&gt; list[Message]:\n    content = await read_file(path)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": {\n                \"type\": \"resource\",\n                \"resource\": {\n                    \"uri\": f\"file://{path}\",\n                    \"text\": content\n                }\n            }\n        }\n    ]\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(\n    uri: AnyUrl | str,\n) -&gt; Iterable[ReadResourceContents]\n</code></pre> <p>Read the contents of a resource by its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>AnyUrl | str</code> <p>The URI of the resource to read</p> required <p>Returns:</p> Type Description <code>Iterable[ReadResourceContents]</code> <p>Iterable of ReadResourceContents containing the resource data</p> <p>Raises:</p> Type Description <code>ResourceError</code> <p>If the resource is not found or cannot be read</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.resource","title":"resource","text":"<pre><code>resource(\n    uri: str,\n    *,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a function as a resource.</p> <p>The function will be called when the resource is read to generate its content. The function can return: - str for text content - bytes for binary content - other types will be converted to JSON</p> <p>If the URI contains parameters (e.g. \"resource://{param}\") or the function has parameters, it will be registered as a template resource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>URI for the resource (e.g. \"resource://my-resource\" or \"resource://{param}\")</p> required <code>name</code> <code>str | None</code> <p>Optional name for the resource</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the resource</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of the resource</p> <code>None</code> <code>mime_type</code> <code>str | None</code> <p>Optional MIME type for the resource</p> <code>None</code> <p>Example:</p> <pre><code>@server.resource(\"resource://my-resource\")\ndef get_data() -&gt; str:\n    return \"Hello, world!\"\n\n@server.resource(\"resource://my-resource\")\nasync get_data() -&gt; str:\n    data = await fetch_data()\n    return f\"Hello, world! {data}\"\n\n@server.resource(\"resource://{city}/weather\")\ndef get_weather(city: str) -&gt; str:\n    return f\"Weather for {city}\"\n\n@server.resource(\"resource://{city}/weather\")\nasync def get_weather(city: str) -&gt; str:\n    data = await fetch_weather(city)\n    return f\"Weather for {city}: {data}\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.run","title":"run","text":"<pre><code>run(\n    transport: Literal[\n        \"stdio\", \"sse\", \"streamable-http\"\n    ] = \"stdio\",\n    mount_path: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the FastMCP server. This is a synchronous function.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Literal['stdio', 'sse', 'streamable-http']</code> <p>Transport protocol to use (\"stdio\", \"sse\", or \"streamable-http\")</p> <code>'stdio'</code> <code>mount_path</code> <code>str | None</code> <p>Optional mount path for SSE transport</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.run_sse_async","title":"run_sse_async  <code>async</code>","text":"<pre><code>run_sse_async(mount_path: str | None = None) -&gt; None\n</code></pre> <p>Run the server using SSE transport.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.run_stdio_async","title":"run_stdio_async  <code>async</code>","text":"<pre><code>run_stdio_async() -&gt; None\n</code></pre> <p>Run the server using stdio transport.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.run_streamable_http_async","title":"run_streamable_http_async  <code>async</code>","text":"<pre><code>run_streamable_http_async() -&gt; None\n</code></pre> <p>Run the server using StreamableHTTP transport.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.session_manager","title":"session_manager  <code>property</code>","text":"<pre><code>session_manager: StreamableHTTPSessionManager\n</code></pre> <p>Get the StreamableHTTP session manager.</p> <p>This is exposed to enable advanced use cases like mounting multiple FastMCP servers in a single FastAPI application.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before streamable_http_app() has been called.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.sse_app","title":"sse_app","text":"<pre><code>sse_app(mount_path: str | None = None) -&gt; Starlette\n</code></pre> <p>Return an instance of the SSE server app.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.streamable_http_app","title":"streamable_http_app","text":"<pre><code>streamable_http_app() -&gt; Starlette\n</code></pre> <p>Return an instance of the StreamableHTTP server app.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.FastMCP.tool","title":"tool","text":"<pre><code>tool(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a tool.</p> <p>Tools can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and resource access.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code> <p>Example:</p> <pre><code>@server.tool()\ndef my_tool(x: int) -&gt; str:\n    return str(x)\n\n@server.tool()\ndef tool_with_context(x: int, ctx: Context) -&gt; str:\n    ctx.info(f\"Processing {x}\")\n    return str(x)\n\n@server.tool()\nasync def async_tool(x: int, context: Context) -&gt; str:\n    await context.report_progress(50, 100)\n    return str(x)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Image","title":"Image","text":"<p>Helper class for returning images from tools.</p>"},{"location":"reference/mcp/server/fastmcp/#mcp.server.fastmcp.Image.to_image_content","title":"to_image_content","text":"<pre><code>to_image_content() -&gt; ImageContent\n</code></pre> <p>Convert to MCP ImageContent.</p>"},{"location":"reference/mcp/server/fastmcp/exceptions/","title":"mcp.server.fastmcp.exceptions","text":"<p>Custom exceptions for FastMCP.</p>"},{"location":"reference/mcp/server/fastmcp/exceptions/#mcp.server.fastmcp.exceptions.FastMCPError","title":"FastMCPError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for all FastMCP-related errors.</p> <p>This is the root exception type for all errors that can occur within the FastMCP framework. Specific error types inherit from this class.</p>"},{"location":"reference/mcp/server/fastmcp/exceptions/#mcp.server.fastmcp.exceptions.InvalidSignature","title":"InvalidSignature","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a function signature is incompatible with FastMCP.</p> <p>This exception is raised when trying to register a function as a tool, resource, or prompt that has an incompatible signature. This can occur when functions have unsupported parameter types, complex annotations that cannot be converted to JSON schema, or other signature issues.</p>"},{"location":"reference/mcp/server/fastmcp/exceptions/#mcp.server.fastmcp.exceptions.ResourceError","title":"ResourceError","text":"<p>               Bases: <code>FastMCPError</code></p> <p>Raised when resource operations fail.</p> <p>This exception is raised for resource-related errors such as:</p> <ul> <li>Resource not found for a given URI</li> <li>Resource content cannot be read or generated</li> <li>Resource template parameter validation failures</li> <li>Resource access permission errors</li> </ul>"},{"location":"reference/mcp/server/fastmcp/exceptions/#mcp.server.fastmcp.exceptions.ToolError","title":"ToolError","text":"<p>               Bases: <code>FastMCPError</code></p> <p>Raised when tool operations fail.</p> <p>This exception is raised for tool-related errors such as:</p> <ul> <li>Tool not found for a given name</li> <li>Tool execution failures or unhandled exceptions</li> <li>Tool registration conflicts or validation errors</li> <li>Tool parameter or result processing errors</li> </ul>"},{"location":"reference/mcp/server/fastmcp/exceptions/#mcp.server.fastmcp.exceptions.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>FastMCPError</code></p> <p>Raised when parameter or return value validation fails.</p> <p>This exception is raised when input arguments don't match a tool's input schema, or when output values fail validation against output schemas. It typically indicates incorrect data types, missing required fields, or values that don't meet schema constraints.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/","title":"mcp.server.fastmcp.prompts","text":""},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.Prompt","title":"Prompt","text":"<p>               Bases: <code>BaseModel</code></p> <p>A prompt template that can be rendered with parameters.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.Prompt.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[\n        ..., PromptResult | Awaitable[PromptResult]\n    ],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n) -&gt; Prompt\n</code></pre> <p>Create a Prompt from a function.</p> <p>The function can return:</p> <ul> <li>A string (converted to a message)</li> <li>A Message object</li> <li>A dict (converted to a message)</li> <li>A sequence of any of the above</li> </ul>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.Prompt.render","title":"render  <code>async</code>","text":"<pre><code>render(\n    arguments: dict[str, Any] | None = None,\n) -&gt; list[Message]\n</code></pre> <p>Render the prompt with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.PromptManager","title":"PromptManager","text":"<p>Manages prompt registration, storage, and rendering for FastMCP servers.</p> <p>The PromptManager is the central registry for all prompts in a FastMCP server. It handles prompt registration, retrieval by name, listing all available prompts, and rendering prompts with provided arguments. Prompts are templates that can generate structured messages for AI model interactions.</p> <p>This class is typically used internally by FastMCP servers but can be used directly for advanced prompt management scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>warn_on_duplicate_prompts</code> <code>bool</code> <p>Whether to log warnings when attempting to register a prompt with a name that already exists. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>warn_on_duplicate_prompts</code> <p>Whether duplicate prompt warnings are enabled.</p> <p>Examples:</p> <p>Basic usage:</p> <pre><code>from mcp.server.fastmcp.prompts import PromptManager, Prompt\n\n# Create a manager\nmanager = PromptManager()\n\n# Create and add a prompt\ndef greeting_prompt(name: str) -&gt; str:\n    return f\"Hello, {name}! How can I help you today?\"\n\nprompt = Prompt.from_function(greeting_prompt)\nmanager.add_prompt(prompt)\n\n# Render the prompt\nmessages = await manager.render_prompt(\"greeting_prompt\", {\"name\": \"Alice\"})\n</code></pre> <p>Disabling duplicate warnings:</p> <pre><code># Useful in testing scenarios or when you need to replace prompts\nmanager = PromptManager(warn_on_duplicate_prompts=False)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.PromptManager.add_prompt","title":"add_prompt","text":"<pre><code>add_prompt(prompt: Prompt) -&gt; Prompt\n</code></pre> <p>Register a prompt with the manager.</p> <p>If a prompt with the same name already exists, the existing prompt is returned without modification. A warning is logged if warn_on_duplicate_prompts is True.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>The Prompt object to register.</p> required <p>Returns:</p> Type Description <code>Prompt</code> <p>The registered Prompt object. If a prompt with the same name already exists,</p> <code>Prompt</code> <p>returns the existing prompt instead of the new one.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.PromptManager.get_prompt","title":"get_prompt","text":"<pre><code>get_prompt(name: str) -&gt; Prompt | None\n</code></pre> <p>Retrieve a registered prompt by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the prompt to retrieve.</p> required <p>Returns:</p> Type Description <code>Prompt | None</code> <p>The Prompt object if found, None if no prompt exists with the given name.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.PromptManager.list_prompts","title":"list_prompts","text":"<pre><code>list_prompts() -&gt; list[Prompt]\n</code></pre> <p>Get a list of all registered prompts.</p> <p>Returns:</p> Type Description <code>list[Prompt]</code> <p>A list containing all Prompt objects currently registered with this manager.</p> <code>list[Prompt]</code> <p>Returns an empty list if no prompts are registered.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/#mcp.server.fastmcp.prompts.PromptManager.render_prompt","title":"render_prompt  <code>async</code>","text":"<pre><code>render_prompt(\n    name: str, arguments: dict[str, Any] | None = None\n) -&gt; list[Message]\n</code></pre> <p>Render a prompt into a list of messages ready for AI model consumption.</p> <p>This method looks up the prompt by name, validates that all required arguments are provided, executes the prompt function with the given arguments, and converts the result into a standardized list of Message objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the prompt to render.</p> required <code>arguments</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of arguments to pass to the prompt function. Must include all required arguments defined by the prompt.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Message]</code> <p>A list of Message objects containing the rendered prompt content.</p> <code>list[Message]</code> <p>Each Message has a role (\"user\" or \"assistant\") and content.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the prompt name is not found or if required arguments are missing.</p> <p>Examples:</p> <p>Simple prompt without arguments:</p> <pre><code>messages = await manager.render_prompt(\"welcome\")\n</code></pre> <p>Prompt with arguments:</p> <pre><code>messages = await manager.render_prompt(\n    \"greeting\",\n    {\"name\": \"Alice\", \"language\": \"en\"}\n)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/prompts/base/","title":"mcp.server.fastmcp.prompts.base","text":"<p>Base classes for FastMCP prompts.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.AssistantMessage","title":"AssistantMessage","text":"<p>               Bases: <code>Message</code></p> <p>A message from the assistant.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.Message","title":"Message","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all prompt messages.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.Prompt","title":"Prompt","text":"<p>               Bases: <code>BaseModel</code></p> <p>A prompt template that can be rendered with parameters.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.Prompt.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[\n        ..., PromptResult | Awaitable[PromptResult]\n    ],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n) -&gt; Prompt\n</code></pre> <p>Create a Prompt from a function.</p> <p>The function can return:</p> <ul> <li>A string (converted to a message)</li> <li>A Message object</li> <li>A dict (converted to a message)</li> <li>A sequence of any of the above</li> </ul>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.Prompt.render","title":"render  <code>async</code>","text":"<pre><code>render(\n    arguments: dict[str, Any] | None = None,\n) -&gt; list[Message]\n</code></pre> <p>Render the prompt with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.PromptArgument","title":"PromptArgument","text":"<p>               Bases: <code>BaseModel</code></p> <p>An argument that can be passed to a prompt.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/base/#mcp.server.fastmcp.prompts.base.UserMessage","title":"UserMessage","text":"<p>               Bases: <code>Message</code></p> <p>A message from the user.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/","title":"mcp.server.fastmcp.prompts.manager","text":"<p>Prompt management functionality for FastMCP servers.</p> <p>This module provides the PromptManager class, which serves as the central registry for managing prompts in FastMCP servers. Prompts are reusable templates that generate structured messages for AI model interactions, enabling consistent and parameterized communication patterns.</p> <p>The PromptManager handles the complete lifecycle of prompts:</p> <ul> <li>Registration and storage of prompt templates</li> <li>Retrieval by name for use in MCP protocol handlers</li> <li>Rendering with arguments to produce message sequences</li> <li>Duplicate detection and management</li> </ul> <p>Key concepts:</p> <ul> <li>Prompts are created from functions using Prompt.from_function()</li> <li>Each prompt has a unique name used for registration and retrieval</li> <li>Prompts can accept typed arguments for dynamic content generation</li> <li>Rendered prompts return Message objects ready for AI model consumption</li> </ul> <p>Examples:</p> <p>Basic prompt management workflow:</p> <pre><code>from mcp.server.fastmcp.prompts import PromptManager, Prompt\n\n# Initialize the manager\nmanager = PromptManager()\n\n# Create a prompt from a function\ndef analysis_prompt(topic: str, context: str) -&gt; list[str]:\n    return [\n        f\"Please analyze the following topic: {topic}\",\n        f\"Additional context: {context}\",\n        \"Provide a detailed analysis with key insights.\"\n    ]\n\n# Register the prompt\nprompt = Prompt.from_function(analysis_prompt)\nmanager.add_prompt(prompt)\n\n# Render the prompt with arguments\nmessages = await manager.render_prompt(\n    \"analysis_prompt\",\n    {\"topic\": \"AI Safety\", \"context\": \"Enterprise deployment\"}\n)\n</code></pre> <p>Integration with FastMCP servers:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"My Server\")\n\n@mcp.prompt()\ndef code_review(language: str, code: str) -&gt; str:\n    return f\"Review this {language} code for best practices:\\n\\n{code}\"\n\n# The prompt is automatically registered with the server's PromptManager\n</code></pre> Note <p>This module is primarily used internally by FastMCP servers, but can be used directly for advanced prompt management scenarios or custom MCP implementations.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/#mcp.server.fastmcp.prompts.manager.PromptManager","title":"PromptManager","text":"<p>Manages prompt registration, storage, and rendering for FastMCP servers.</p> <p>The PromptManager is the central registry for all prompts in a FastMCP server. It handles prompt registration, retrieval by name, listing all available prompts, and rendering prompts with provided arguments. Prompts are templates that can generate structured messages for AI model interactions.</p> <p>This class is typically used internally by FastMCP servers but can be used directly for advanced prompt management scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>warn_on_duplicate_prompts</code> <code>bool</code> <p>Whether to log warnings when attempting to register a prompt with a name that already exists. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>warn_on_duplicate_prompts</code> <p>Whether duplicate prompt warnings are enabled.</p> <p>Examples:</p> <p>Basic usage:</p> <pre><code>from mcp.server.fastmcp.prompts import PromptManager, Prompt\n\n# Create a manager\nmanager = PromptManager()\n\n# Create and add a prompt\ndef greeting_prompt(name: str) -&gt; str:\n    return f\"Hello, {name}! How can I help you today?\"\n\nprompt = Prompt.from_function(greeting_prompt)\nmanager.add_prompt(prompt)\n\n# Render the prompt\nmessages = await manager.render_prompt(\"greeting_prompt\", {\"name\": \"Alice\"})\n</code></pre> <p>Disabling duplicate warnings:</p> <pre><code># Useful in testing scenarios or when you need to replace prompts\nmanager = PromptManager(warn_on_duplicate_prompts=False)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/#mcp.server.fastmcp.prompts.manager.PromptManager.add_prompt","title":"add_prompt","text":"<pre><code>add_prompt(prompt: Prompt) -&gt; Prompt\n</code></pre> <p>Register a prompt with the manager.</p> <p>If a prompt with the same name already exists, the existing prompt is returned without modification. A warning is logged if warn_on_duplicate_prompts is True.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>The Prompt object to register.</p> required <p>Returns:</p> Type Description <code>Prompt</code> <p>The registered Prompt object. If a prompt with the same name already exists,</p> <code>Prompt</code> <p>returns the existing prompt instead of the new one.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/#mcp.server.fastmcp.prompts.manager.PromptManager.get_prompt","title":"get_prompt","text":"<pre><code>get_prompt(name: str) -&gt; Prompt | None\n</code></pre> <p>Retrieve a registered prompt by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the prompt to retrieve.</p> required <p>Returns:</p> Type Description <code>Prompt | None</code> <p>The Prompt object if found, None if no prompt exists with the given name.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/#mcp.server.fastmcp.prompts.manager.PromptManager.list_prompts","title":"list_prompts","text":"<pre><code>list_prompts() -&gt; list[Prompt]\n</code></pre> <p>Get a list of all registered prompts.</p> <p>Returns:</p> Type Description <code>list[Prompt]</code> <p>A list containing all Prompt objects currently registered with this manager.</p> <code>list[Prompt]</code> <p>Returns an empty list if no prompts are registered.</p>"},{"location":"reference/mcp/server/fastmcp/prompts/manager/#mcp.server.fastmcp.prompts.manager.PromptManager.render_prompt","title":"render_prompt  <code>async</code>","text":"<pre><code>render_prompt(\n    name: str, arguments: dict[str, Any] | None = None\n) -&gt; list[Message]\n</code></pre> <p>Render a prompt into a list of messages ready for AI model consumption.</p> <p>This method looks up the prompt by name, validates that all required arguments are provided, executes the prompt function with the given arguments, and converts the result into a standardized list of Message objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the prompt to render.</p> required <code>arguments</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of arguments to pass to the prompt function. Must include all required arguments defined by the prompt.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Message]</code> <p>A list of Message objects containing the rendered prompt content.</p> <code>list[Message]</code> <p>Each Message has a role (\"user\" or \"assistant\") and content.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the prompt name is not found or if required arguments are missing.</p> <p>Examples:</p> <p>Simple prompt without arguments:</p> <pre><code>messages = await manager.render_prompt(\"welcome\")\n</code></pre> <p>Prompt with arguments:</p> <pre><code>messages = await manager.render_prompt(\n    \"greeting\",\n    {\"name\": \"Alice\", \"language\": \"en\"}\n)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/resources/","title":"mcp.server.fastmcp.resources","text":""},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.BinaryResource","title":"BinaryResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from bytes.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.BinaryResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; bytes\n</code></pre> <p>Read the binary content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.DirectoryResource","title":"DirectoryResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that lists files in a directory.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.DirectoryResource.list_files","title":"list_files","text":"<pre><code>list_files() -&gt; list[Path]\n</code></pre> <p>List files in the directory.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.DirectoryResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str\n</code></pre> <p>Read the directory listing.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.DirectoryResource.validate_absolute_path","title":"validate_absolute_path  <code>classmethod</code>","text":"<pre><code>validate_absolute_path(path: Path) -&gt; Path\n</code></pre> <p>Ensure path is absolute.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FileResource","title":"FileResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from a file.</p> <p>Set is_binary=True to read file as binary data instead of text.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FileResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the file content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FileResource.set_binary_from_mime_type","title":"set_binary_from_mime_type  <code>classmethod</code>","text":"<pre><code>set_binary_from_mime_type(\n    is_binary: bool, info: ValidationInfo\n) -&gt; bool\n</code></pre> <p>Set is_binary based on mime_type if not explicitly set.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FileResource.validate_absolute_path","title":"validate_absolute_path  <code>classmethod</code>","text":"<pre><code>validate_absolute_path(path: Path) -&gt; Path\n</code></pre> <p>Ensure path is absolute.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FunctionResource","title":"FunctionResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that defers data loading by wrapping a function.</p> <p>The function is only called when the resource is read, allowing for lazy loading of potentially expensive data. This is particularly useful when listing resources, as the function won't be called until the resource is actually accessed.</p> <p>The function can return: - str for text content (default) - bytes for binary content - other types will be converted to JSON</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FunctionResource.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    uri: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; FunctionResource\n</code></pre> <p>Create a FunctionResource from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.FunctionResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the resource by calling the wrapped function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.HttpResource","title":"HttpResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from an HTTP endpoint.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.HttpResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the HTTP content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.Resource","title":"Resource","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Base class for all MCP resources.</p> <p>Resources provide contextual data that can be read by LLMs. Each resource has a URI, optional metadata like name and description, and content that can be retrieved via the read() method.</p> <p>Attributes:</p> Name Type Description <code>uri</code> <code>Annotated[AnyUrl, UrlConstraints(host_required=False)]</code> <p>Unique identifier for the resource</p> <code>name</code> <code>str | None</code> <p>Optional name for the resource (defaults to URI if not provided)</p> <code>title</code> <code>str | None</code> <p>Optional human-readable title</p> <code>description</code> <code>str | None</code> <p>Optional description of the resource content</p> <code>mime_type</code> <code>str</code> <p>MIME type of the resource content (defaults to text/plain)</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.Resource.read","title":"read  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the resource content.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The resource content as either a string or bytes</p> <p>Raises:</p> Type Description <code>ResourceError</code> <p>If the resource cannot be read</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.Resource.set_default_name","title":"set_default_name  <code>classmethod</code>","text":"<pre><code>set_default_name(\n    name: str | None, info: ValidationInfo\n) -&gt; str\n</code></pre> <p>Set default name from URI if not provided.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The provided name value</p> required <code>info</code> <code>ValidationInfo</code> <p>Pydantic validation info containing other field values</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name to use for the resource</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither name nor uri is provided</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager","title":"ResourceManager","text":"<p>Manages FastMCP resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager.add_resource","title":"add_resource","text":"<pre><code>add_resource(resource: Resource) -&gt; Resource\n</code></pre> <p>Add a resource to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>A Resource instance to add</p> required <p>Returns:</p> Type Description <code>Resource</code> <p>The added resource. If a resource with the same URI already exists,</p> <code>Resource</code> <p>returns the existing resource.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager.add_template","title":"add_template","text":"<pre><code>add_template(\n    fn: Callable[..., Any],\n    uri_template: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; ResourceTemplate\n</code></pre> <p>Add a template from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager.get_resource","title":"get_resource  <code>async</code>","text":"<pre><code>get_resource(uri: AnyUrl | str) -&gt; Resource | None\n</code></pre> <p>Get resource by URI, checking concrete resources first, then templates.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager.list_resources","title":"list_resources","text":"<pre><code>list_resources() -&gt; list[Resource]\n</code></pre> <p>List all registered resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceManager.list_templates","title":"list_templates","text":"<pre><code>list_templates() -&gt; list[ResourceTemplate]\n</code></pre> <p>List all registered templates.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceTemplate","title":"ResourceTemplate","text":"<p>               Bases: <code>BaseModel</code></p> <p>A template for dynamically creating resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceTemplate.create_resource","title":"create_resource  <code>async</code>","text":"<pre><code>create_resource(\n    uri: str, params: dict[str, Any]\n) -&gt; Resource\n</code></pre> <p>Create a resource from the template with the given parameters.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceTemplate.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    uri_template: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; ResourceTemplate\n</code></pre> <p>Create a template from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.ResourceTemplate.matches","title":"matches","text":"<pre><code>matches(uri: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Check if URI matches template and extract parameters.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.TextResource","title":"TextResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from a string.</p>"},{"location":"reference/mcp/server/fastmcp/resources/#mcp.server.fastmcp.resources.TextResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str\n</code></pre> <p>Read the text content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/base/","title":"mcp.server.fastmcp.resources.base","text":"<p>Base classes and interfaces for FastMCP resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/base/#mcp.server.fastmcp.resources.base.Resource","title":"Resource","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Base class for all MCP resources.</p> <p>Resources provide contextual data that can be read by LLMs. Each resource has a URI, optional metadata like name and description, and content that can be retrieved via the read() method.</p> <p>Attributes:</p> Name Type Description <code>uri</code> <code>Annotated[AnyUrl, UrlConstraints(host_required=False)]</code> <p>Unique identifier for the resource</p> <code>name</code> <code>str | None</code> <p>Optional name for the resource (defaults to URI if not provided)</p> <code>title</code> <code>str | None</code> <p>Optional human-readable title</p> <code>description</code> <code>str | None</code> <p>Optional description of the resource content</p> <code>mime_type</code> <code>str</code> <p>MIME type of the resource content (defaults to text/plain)</p>"},{"location":"reference/mcp/server/fastmcp/resources/base/#mcp.server.fastmcp.resources.base.Resource.read","title":"read  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the resource content.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The resource content as either a string or bytes</p> <p>Raises:</p> Type Description <code>ResourceError</code> <p>If the resource cannot be read</p>"},{"location":"reference/mcp/server/fastmcp/resources/base/#mcp.server.fastmcp.resources.base.Resource.set_default_name","title":"set_default_name  <code>classmethod</code>","text":"<pre><code>set_default_name(\n    name: str | None, info: ValidationInfo\n) -&gt; str\n</code></pre> <p>Set default name from URI if not provided.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The provided name value</p> required <code>info</code> <code>ValidationInfo</code> <p>Pydantic validation info containing other field values</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name to use for the resource</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither name nor uri is provided</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/","title":"mcp.server.fastmcp.resources.resource_manager","text":"<p>Resource manager functionality.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager","title":"ResourceManager","text":"<p>Manages FastMCP resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager.add_resource","title":"add_resource","text":"<pre><code>add_resource(resource: Resource) -&gt; Resource\n</code></pre> <p>Add a resource to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>A Resource instance to add</p> required <p>Returns:</p> Type Description <code>Resource</code> <p>The added resource. If a resource with the same URI already exists,</p> <code>Resource</code> <p>returns the existing resource.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager.add_template","title":"add_template","text":"<pre><code>add_template(\n    fn: Callable[..., Any],\n    uri_template: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; ResourceTemplate\n</code></pre> <p>Add a template from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager.get_resource","title":"get_resource  <code>async</code>","text":"<pre><code>get_resource(uri: AnyUrl | str) -&gt; Resource | None\n</code></pre> <p>Get resource by URI, checking concrete resources first, then templates.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager.list_resources","title":"list_resources","text":"<pre><code>list_resources() -&gt; list[Resource]\n</code></pre> <p>List all registered resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/resource_manager/#mcp.server.fastmcp.resources.resource_manager.ResourceManager.list_templates","title":"list_templates","text":"<pre><code>list_templates() -&gt; list[ResourceTemplate]\n</code></pre> <p>List all registered templates.</p>"},{"location":"reference/mcp/server/fastmcp/resources/templates/","title":"mcp.server.fastmcp.resources.templates","text":"<p>Resource template functionality.</p>"},{"location":"reference/mcp/server/fastmcp/resources/templates/#mcp.server.fastmcp.resources.templates.ResourceTemplate","title":"ResourceTemplate","text":"<p>               Bases: <code>BaseModel</code></p> <p>A template for dynamically creating resources.</p>"},{"location":"reference/mcp/server/fastmcp/resources/templates/#mcp.server.fastmcp.resources.templates.ResourceTemplate.create_resource","title":"create_resource  <code>async</code>","text":"<pre><code>create_resource(\n    uri: str, params: dict[str, Any]\n) -&gt; Resource\n</code></pre> <p>Create a resource from the template with the given parameters.</p>"},{"location":"reference/mcp/server/fastmcp/resources/templates/#mcp.server.fastmcp.resources.templates.ResourceTemplate.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    uri_template: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; ResourceTemplate\n</code></pre> <p>Create a template from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/templates/#mcp.server.fastmcp.resources.templates.ResourceTemplate.matches","title":"matches","text":"<pre><code>matches(uri: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Check if URI matches template and extract parameters.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/","title":"mcp.server.fastmcp.resources.types","text":"<p>Concrete resource implementations.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.BinaryResource","title":"BinaryResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from bytes.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.BinaryResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; bytes\n</code></pre> <p>Read the binary content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.DirectoryResource","title":"DirectoryResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that lists files in a directory.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.DirectoryResource.list_files","title":"list_files","text":"<pre><code>list_files() -&gt; list[Path]\n</code></pre> <p>List files in the directory.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.DirectoryResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str\n</code></pre> <p>Read the directory listing.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.DirectoryResource.validate_absolute_path","title":"validate_absolute_path  <code>classmethod</code>","text":"<pre><code>validate_absolute_path(path: Path) -&gt; Path\n</code></pre> <p>Ensure path is absolute.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FileResource","title":"FileResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from a file.</p> <p>Set is_binary=True to read file as binary data instead of text.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FileResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the file content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FileResource.set_binary_from_mime_type","title":"set_binary_from_mime_type  <code>classmethod</code>","text":"<pre><code>set_binary_from_mime_type(\n    is_binary: bool, info: ValidationInfo\n) -&gt; bool\n</code></pre> <p>Set is_binary based on mime_type if not explicitly set.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FileResource.validate_absolute_path","title":"validate_absolute_path  <code>classmethod</code>","text":"<pre><code>validate_absolute_path(path: Path) -&gt; Path\n</code></pre> <p>Ensure path is absolute.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FunctionResource","title":"FunctionResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that defers data loading by wrapping a function.</p> <p>The function is only called when the resource is read, allowing for lazy loading of potentially expensive data. This is particularly useful when listing resources, as the function won't be called until the resource is actually accessed.</p> <p>The function can return: - str for text content (default) - bytes for binary content - other types will be converted to JSON</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FunctionResource.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    uri: str,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None,\n) -&gt; FunctionResource\n</code></pre> <p>Create a FunctionResource from a function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.FunctionResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the resource by calling the wrapped function.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.HttpResource","title":"HttpResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from an HTTP endpoint.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.HttpResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str | bytes\n</code></pre> <p>Read the HTTP content.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.TextResource","title":"TextResource","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that reads from a string.</p>"},{"location":"reference/mcp/server/fastmcp/resources/types/#mcp.server.fastmcp.resources.types.TextResource.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; str\n</code></pre> <p>Read the text content.</p>"},{"location":"reference/mcp/server/fastmcp/server/","title":"mcp.server.fastmcp.server","text":"<p>FastMCP - A more ergonomic interface for MCP servers.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context","title":"Context","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ServerSessionT, LifespanContextT, RequestT]</code></p> <p>High-level context object providing convenient access to MCP capabilities.</p> <p>This is FastMCP's user-friendly wrapper around the underlying <code>RequestContext</code> that provides the same functionality with additional convenience methods and better ergonomics. It gets automatically injected into FastMCP tool and resource functions that declare it in their type hints, eliminating the need to manually access the request context.</p> <p>The Context object provides access to all MCP capabilities including logging, progress reporting, resource reading, user interaction, capability checking, and access to the underlying session and request metadata. It's the recommended way to interact with MCP functionality in FastMCP applications.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context--automatic-injection","title":"Automatic injection","text":"<p>Context is automatically injected into functions based on type hints. The parameter name can be anything as long as it's annotated with <code>Context</code>. The context parameter is optional - tools that don't need it can omit it entirely.</p> <pre><code>from mcp.server.fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"example\")\n\n@mcp.tool()\nasync def simple_tool(data: str) -&gt; str:\n    # No context needed\n    return f\"Processed: {data}\"\n\n@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Context automatically injected\n    await ctx.info(\"Starting processing\")\n    return f\"Processed: {data}\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context--relationship-to-requestcontext","title":"Relationship to RequestContext","text":"<p>Context is a thin wrapper around <code>RequestContext</code> that provides the same underlying functionality with additional convenience methods:</p> <ul> <li>Context convenience methods: <code>ctx.info()</code>, <code>ctx.error()</code>, <code>ctx.elicit()</code>, etc.</li> <li>Direct RequestContext access: <code>ctx.request_context</code> for low-level operations</li> <li>Session access: <code>ctx.session</code> for advanced ServerSession functionality</li> <li>Request metadata: <code>ctx.request_id</code>, access to lifespan context, etc.</li> </ul>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context--capabilities-provided","title":"Capabilities provided","text":"<p>Logging: Send structured log messages to the client with automatic request linking:</p> <pre><code>await ctx.debug(\"Detailed debug information\")\nawait ctx.info(\"General status updates\")\nawait ctx.warning(\"Important warnings\")\nawait ctx.error(\"Error conditions\")\n</code></pre> <p>Progress reporting: Keep users informed during long operations:</p> <pre><code>for i in range(100):\n    await ctx.report_progress(i, 100, f\"Processing item {i}\")\n    # ... do work\n</code></pre> <p>User interaction: Collect additional information during tool execution:</p> <pre><code>class UserPrefs(BaseModel):\n    format: str\n    detailed: bool\n\nresult = await ctx.elicit(\"How should I format the output?\", UserPrefs)\nif result.action == \"accept\":\n    format_data(data, result.data.format)\n</code></pre> <p>Resource access: Read MCP resources during tool execution:</p> <pre><code>content = await ctx.read_resource(\"file://data/config.json\")\n</code></pre> <p>Capability checking: Verify client support before using advanced features:</p> <pre><code>if ctx.session.check_client_capability(types.ClientCapabilities(sampling=...)):\n    # Use advanced features\n    pass\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context--examples","title":"Examples","text":"<p>Complete tool with context usage:</p> <pre><code>from pydantic import BaseModel\nfrom mcp.server.fastmcp import FastMCP, Context\n\nclass ProcessingOptions(BaseModel):\n    format: str\n    include_metadata: bool\n\nmcp = FastMCP(name=\"processor\")\n\n@mcp.tool()\nasync def process_data(\n    data: str,\n    ctx: Context,\n    auto_format: bool = False\n) -&gt; str:\n    await ctx.info(f\"Starting to process {len(data)} characters\")\n\n    # Get user preferences if not auto-formatting\n    if not auto_format:\n        if ctx.session.check_client_capability(\n            types.ClientCapabilities(elicitation=types.ElicitationCapability())\n        ):\n            prefs_result = await ctx.elicit(\n                \"How would you like the data processed?\",\n                ProcessingOptions\n            )\n            if prefs_result.action == \"accept\":\n                format_type = prefs_result.data.format\n                include_meta = prefs_result.data.include_metadata\n            else:\n                await ctx.warning(\"Using default format\")\n                format_type = \"standard\"\n                include_meta = False\n        else:\n            format_type = \"standard\"\n            include_meta = False\n    else:\n        format_type = \"auto\"\n        include_meta = True\n\n    # Process with progress updates\n    for i in range(0, len(data), 100):\n        chunk = data[i:i+100]\n        await ctx.report_progress(i, len(data), f\"Processing chunk {i//100 + 1}\")\n        # ... process chunk\n\n    await ctx.info(f\"Processing complete with format: {format_type}\")\n    return processed_data\n</code></pre> Note <p>Context objects are request-scoped and automatically managed by FastMCP. Don't store references to them beyond the request lifecycle. Each tool invocation gets a fresh Context instance tied to that specific request.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: str | None\n</code></pre> <p>Get the client ID if available.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.debug","title":"debug  <code>async</code>","text":"<pre><code>debug(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send a debug log message.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str, schema: type[ElicitSchemaModelT]\n) -&gt; ElicitationResult[ElicitSchemaModelT]\n</code></pre> <p>Elicit structured information from the client or user during tool execution.</p> <p>This method enables interactive data collection from clients during tool processing. The client may display the message to the user and collect a response according to the provided Pydantic schema, or if the client is an agent, it may automatically generate an appropriate response. This is useful for gathering additional parameters, user preferences, or confirmation before proceeding with operations.</p> <p>You typically access this method through the <code>Context</code> object injected into your FastMCP tool functions. Always check that the client supports elicitation using <code>check_client_capability</code> before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt or question to present to the user. Should clearly explain what information is being requested and why it's needed.</p> required <code>schema</code> <code>type[ElicitSchemaModelT]</code> <p>A Pydantic model class defining the expected response structure. According to the MCP specification, only primitive types (str, int, float, bool) and simple containers (list, dict) are allowed - no complex nested objects.</p> required <p>Returns:</p> Type Description <code>ElicitationResult[ElicitSchemaModelT]</code> <p><code>ElicitationResult</code> containing:</p> <code>ElicitationResult[ElicitSchemaModelT]</code> <ul> <li><code>action</code>: One of \"accept\", \"decline\", or \"cancel\" indicating user response</li> </ul> <code>ElicitationResult[ElicitSchemaModelT]</code> <ul> <li><code>data</code>: The structured response data (only populated if action is \"accept\")</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>ValidationError</code> <p>If the client response doesn't match the provided schema.</p> <code>Various exceptions</code> <p>Depending on client implementation and user interaction.</p> <p>Examples:</p> <p>Collect user preferences before processing:</p> <pre><code>from pydantic import BaseModel\nfrom mcp.server.fastmcp import FastMCP, Context\n\nclass ProcessingOptions(BaseModel):\n    format: str\n    include_metadata: bool\n    max_items: int\n\nmcp = FastMCP(name=\"example-server\")\n\n@mcp.tool()\nasync def process_data(data: str, ctx: Context) -&gt; str:\n    # Check if client supports elicitation\n    if not ctx.session.check_client_capability(\n        types.ClientCapabilities(elicitation=types.ElicitationCapability())\n    ):\n        # Fall back to default processing\n        return process_with_defaults(data)\n\n    # Ask user for processing preferences\n    result = await ctx.elicit(\n        \"How would you like me to process this data?\",\n        ProcessingOptions\n    )\n\n    if result.action == \"accept\":\n        options = result.data\n        await ctx.info(f\"Processing with format: {options.format}\")\n        return process_with_options(data, options)\n    elif result.action == \"decline\":\n        return process_with_defaults(data)\n    else:  # cancel\n        return \"Processing cancelled by user\"\n</code></pre> <p>Confirm before destructive operations:</p> <pre><code>class ConfirmDelete(BaseModel):\n    confirm: bool\n    reason: str\n\n@mcp.tool()\nasync def delete_files(pattern: str, ctx: Context) -&gt; str:\n    files = find_matching_files(pattern)\n\n    result = await ctx.elicit(\n        f\"About to delete {len(files)} files matching '{pattern}'. Continue?\",\n        ConfirmDelete\n    )\n\n    if result.action == \"accept\" and result.data.confirm:\n        await ctx.info(f\"Deletion confirmed: {result.data.reason}\")\n        return delete_files(files)\n    else:\n        return \"Deletion cancelled\"\n</code></pre> <p>Handle different response types:</p> <pre><code>class UserChoice(BaseModel):\n    option: str  # \"auto\", \"manual\", \"skip\"\n    details: str\n\n@mcp.tool()\nasync def configure_system(ctx: Context) -&gt; str:\n    result = await ctx.elicit(\n        \"How should I configure the system?\",\n        UserChoice\n    )\n\n    match result.action:\n        case \"accept\":\n            choice = result.data\n            await ctx.info(f\"User selected: {choice.option}\")\n            return configure_with_choice(choice)\n        case \"decline\":\n            await ctx.warning(\"User declined configuration\")\n            return \"Configuration skipped by user\"\n        case \"cancel\":\n            await ctx.info(\"Configuration cancelled\")\n            return \"Operation cancelled\"\n</code></pre> Note <p>The client determines how to handle elicitation requests. Some clients may show interactive forms to users, while others may automatically generate responses based on context. Always handle all possible action values (\"accept\", \"decline\", \"cancel\") in your code and provide appropriate fallbacks for clients that don't support elicitation.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.error","title":"error  <code>async</code>","text":"<pre><code>error(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send an error log message.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.fastmcp","title":"fastmcp  <code>property</code>","text":"<pre><code>fastmcp: FastMCP\n</code></pre> <p>Access to the FastMCP server.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.info","title":"info  <code>async</code>","text":"<pre><code>info(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send an info log message.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.log","title":"log  <code>async</code>","text":"<pre><code>log(\n    level: Literal[\"debug\", \"info\", \"warning\", \"error\"],\n    message: str,\n    *,\n    logger_name: str | None = None\n) -&gt; None\n</code></pre> <p>Send a log message to the client.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['debug', 'info', 'warning', 'error']</code> <p>Log level (debug, info, warning, error)</p> required <code>message</code> <code>str</code> <p>Log message</p> required <code>logger_name</code> <code>str | None</code> <p>Optional logger name</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(\n    uri: str | AnyUrl,\n) -&gt; Iterable[ReadResourceContents]\n</code></pre> <p>Read a resource by URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str | AnyUrl</code> <p>Resource URI to read</p> required <p>Returns:</p> Type Description <code>Iterable[ReadResourceContents]</code> <p>The resource content as either text or bytes</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.report_progress","title":"report_progress  <code>async</code>","text":"<pre><code>report_progress(\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Report progress for the current operation.</p> <p>Parameters:</p> Name Type Description Default <code>progress</code> <code>float</code> <p>Current progress value e.g. 24</p> required <code>total</code> <code>float | None</code> <p>Optional total value e.g. 100</p> <code>None</code> <code>message</code> <code>str | None</code> <p>Optional message e.g. Starting render...</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.request_context","title":"request_context  <code>property</code>","text":"<pre><code>request_context: RequestContext[\n    ServerSessionT, LifespanContextT, RequestT\n]\n</code></pre> <p>Access to the underlying RequestContext for low-level operations.</p> <p>This property provides direct access to the <code>RequestContext</code> that this Context wraps. Use this when you need low-level access to request metadata, lifespan context, or other features not exposed by Context's convenience methods.</p> <p>Most users should prefer Context's convenience methods like <code>info()</code>, <code>elicit()</code>, etc. rather than accessing the underlying RequestContext directly.</p> <p>Returns:</p> Type Description <code>RequestContext[ServerSessionT, LifespanContextT, RequestT]</code> <p>The underlying <code>RequestContext</code> containing</p> <code>RequestContext[ServerSessionT, LifespanContextT, RequestT]</code> <p>session, metadata, and lifespan context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If called outside of a request context.</p> Example <pre><code>@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Access lifespan context directly\n    db = ctx.request_context.lifespan_context[\"database\"]\n\n    # Access request metadata\n    progress_token = ctx.request_context.meta.progressToken if ctx.request_context.meta else None\n\n    return processed_data\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre> <p>Get the unique identifier for the current request.</p> <p>This ID uniquely identifies the current client request and is useful for logging, tracing, error reporting, and linking related operations. It's automatically used by Context's convenience methods when sending notifications or responses to ensure they're associated with the correct request.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique request identifier that can be used for tracing and logging.</p> Example <pre><code>@mcp.tool()\nasync def traceable_tool(data: str, ctx: Context) -&gt; str:\n    # Log with request ID for traceability\n    print(f\"Processing request {ctx.request_id}\")\n\n    # Request ID is automatically included in Context methods\n    await ctx.info(\"Starting processing\")  # Links to this request\n\n    return processed_data\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.session","title":"session  <code>property</code>","text":"<pre><code>session: ServerSession\n</code></pre> <p>Access to the underlying ServerSession for advanced MCP operations.</p> <p>This property provides direct access to the <code>ServerSession</code> for advanced operations not covered by Context's convenience methods. Use this when you need direct session control, capability checking, or low-level MCP protocol operations.</p> <p>Most users should prefer Context's convenience methods (<code>info()</code>, <code>elicit()</code>, etc.) which internally use this session with appropriate request linking.</p> <p>Returns:</p> Type Description <code>ServerSession</code> <p><code>ServerSession</code>: The session for</p> <code>ServerSession</code> <p>communicating with the client and accessing advanced MCP features.</p> <p>Examples:</p> <p>Capability checking before using advanced features:</p> <pre><code>@mcp.tool()\nasync def advanced_tool(data: str, ctx: Context) -&gt; str:\n    # Check client capabilities\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Use LLM sampling\n        response = await ctx.session.create_message(\n            messages=[types.SamplingMessage(...)],\n            max_tokens=100\n        )\n        return response.content.text\n    else:\n        return \"Client doesn't support LLM sampling\"\n</code></pre> <p>Direct resource notifications:</p> <pre><code>@mcp.tool()\nasync def update_resource(uri: str, ctx: Context) -&gt; str:\n    # ... update the resource ...\n\n    # Notify client of resource changes\n    await ctx.session.send_resource_updated(AnyUrl(uri))\n    return \"Resource updated\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Context.warning","title":"warning  <code>async</code>","text":"<pre><code>warning(message: str, **extra: Any) -&gt; None\n</code></pre> <p>Send a warning log message.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP","title":"FastMCP","text":"<p>               Bases: <code>Generic[LifespanResultT]</code></p> <p>A high-level ergonomic interface for creating MCP servers.</p> <p>FastMCP provides a decorator-based API for building MCP servers with automatic parameter validation, structured output support, and built-in transport handling. It supports stdio, SSE, and Streamable HTTP transports out of the box.</p> <p>Features include automatic validation using Pydantic, structured output conversion, context injection for MCP capabilities, lifespan management, multiple transport support, and built-in OAuth 2.1 authentication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Human-readable name for the server. If None, defaults to \"FastMCP\"</p> <code>None</code> <code>instructions</code> <code>str | None</code> <p>Optional instructions/description for the server</p> <code>None</code> <code>auth_server_provider</code> <code>OAuthAuthorizationServerProvider[Any, Any, Any] | None</code> <p>OAuth authorization server provider for authentication</p> <code>None</code> <code>token_verifier</code> <code>TokenVerifier | None</code> <p>Token verifier for validating OAuth tokens</p> <code>None</code> <code>event_store</code> <code>EventStore | None</code> <p>Event store for Streamable HTTP transport persistence</p> <code>None</code> <code>tools</code> <code>list[Tool] | None</code> <p>Pre-configured tools to register with the server</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug mode for additional logging</p> <code>False</code> <code>log_level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'INFO'</code> <code>host</code> <code>str</code> <p>Host address for HTTP transports</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port number for HTTP transports</p> <code>8000</code> <code>mount_path</code> <code>str</code> <p>Base mount path for SSE transport</p> <code>'/'</code> <code>sse_path</code> <code>str</code> <p>Path for SSE endpoint</p> <code>'/sse'</code> <code>message_path</code> <code>str</code> <p>Path for message endpoint</p> <code>'/messages/'</code> <code>streamable_http_path</code> <code>str</code> <p>Path for Streamable HTTP endpoint</p> <code>'/mcp'</code> <code>json_response</code> <code>bool</code> <p>Whether to use JSON responses instead of SSE for Streamable HTTP</p> <code>False</code> <code>stateless_http</code> <code>bool</code> <p>Whether to operate in stateless mode for Streamable HTTP</p> <code>False</code> <code>warn_on_duplicate_resources</code> <code>bool</code> <p>Whether to warn when duplicate resources are registered</p> <code>True</code> <code>warn_on_duplicate_tools</code> <code>bool</code> <p>Whether to warn when duplicate tools are registered</p> <code>True</code> <code>warn_on_duplicate_prompts</code> <code>bool</code> <p>Whether to warn when duplicate prompts are registered</p> <code>True</code> <code>dependencies</code> <code>Collection[str]</code> <p>List of package dependencies (currently unused)</p> <code>()</code> <code>lifespan</code> <code>Callable[[FastMCP[LifespanResultT]], AbstractAsyncContextManager[LifespanResultT]] | None</code> <p>Async context manager for server startup/shutdown lifecycle</p> <code>None</code> <code>auth</code> <code>AuthSettings | None</code> <p>Authentication settings for OAuth 2.1 support</p> <code>None</code> <code>transport_security</code> <code>TransportSecuritySettings | None</code> <p>Transport security settings</p> <code>None</code> <p>Examples:</p> <p>Basic server creation:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create a server\nmcp = FastMCP(\"My Server\")\n\n# Add a tool\n@mcp.tool()\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n# Add a resource\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\n# Run the server\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre> <p>Server with authentication:</p> <pre><code>from mcp.server.auth.settings import AuthSettings\nfrom pydantic import AnyHttpUrl\n\nmcp = FastMCP(\n    \"Protected Server\",\n    auth=AuthSettings(\n        issuer_url=AnyHttpUrl(\"https://auth.example.com\"),\n        resource_server_url=AnyHttpUrl(\"http://localhost:8000\"),\n        required_scopes=[\"read\", \"write\"]\n    )\n)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.add_prompt","title":"add_prompt","text":"<pre><code>add_prompt(prompt: Prompt) -&gt; None\n</code></pre> <p>Add a prompt to the server.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>A Prompt instance to add</p> required"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.add_resource","title":"add_resource","text":"<pre><code>add_resource(resource: Resource) -&gt; None\n</code></pre> <p>Add a resource to the server.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>A Resource instance to add</p> required"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: AnyFunction,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; None\n</code></pre> <p>Add a tool to the server.</p> <p>The tool function can optionally request a Context object by adding a parameter with the Context type annotation. See the @tool decorator for examples.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>AnyFunction</code> <p>The function to register as a tool</p> required <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, arguments: dict[str, Any]\n) -&gt; Sequence[ContentBlock] | dict[str, Any]\n</code></pre> <p>Call a registered tool by name with the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool to call</p> required <code>arguments</code> <code>dict[str, Any]</code> <p>Dictionary of arguments to pass to the tool</p> required <p>Returns:</p> Type Description <code>Sequence[ContentBlock] | dict[str, Any]</code> <p>Tool execution result, either as content blocks or structured data</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If the tool is not found or execution fails</p> <code>ValidationError</code> <p>If the arguments don't match the tool's schema</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Decorator to register a completion handler.</p> <p>The completion handler receives: - ref: PromptReference or ResourceTemplateReference - argument: CompletionArgument with name and partial value - context: Optional CompletionContext with previously resolved arguments</p> <p>Example:</p> <pre><code>@mcp.completion()\nasync def handle_completion(ref, argument, context):\n    if isinstance(ref, ResourceTemplateReference):\n        # Return completions based on ref, argument, and context\n        return Completion(values=[\"option1\", \"option2\"])\n    return None\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.custom_route","title":"custom_route","text":"<pre><code>custom_route(\n    path: str,\n    methods: list[str],\n    name: str | None = None,\n    include_in_schema: bool = True,\n)\n</code></pre> <p>Decorator to register a custom HTTP route on the FastMCP server.</p> <p>Allows adding arbitrary HTTP endpoints outside the standard MCP protocol, which can be useful for OAuth callbacks, health checks, or admin APIs. The handler function must be an async function that accepts a Starlette Request and returns a Response.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>URL path for the route (e.g., \"/oauth/callback\")</p> required <code>methods</code> <code>list[str]</code> <p>List of HTTP methods to support (e.g., [\"GET\", \"POST\"])</p> required <code>name</code> <code>str | None</code> <p>Optional name for the route (to reference this route with   Starlette's reverse URL lookup feature)</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include in OpenAPI schema, defaults to True</p> <code>True</code> <p>Example:</p> <pre><code>@server.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -&gt; Response:\n    return JSONResponse({\"status\": \"ok\"})\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.get_context","title":"get_context","text":"<pre><code>get_context() -&gt; (\n    Context[ServerSession, LifespanResultT, Request]\n)\n</code></pre> <p>Get the current request context when automatic injection isn't available.</p> <p>This method provides access to the current <code>Context</code> object when you can't rely on FastMCP's automatic parameter injection. It's primarily useful in helper functions, callbacks, or other scenarios where the context isn't automatically provided via function parameters.</p> <p>In most cases, you should prefer automatic context injection by declaring a Context parameter in your tool/resource functions. Use this method only when you need context access from code that isn't directly called by FastMCP.</p> <p>You might call this method directly in:</p> <ul> <li> <p>Helper functions</p> <pre><code>mcp = FastMCP(name=\"example\")\n\nasync def log_operation(operation: str):\n    # Get context when it's not injected\n    ctx = mcp.get_context()\n    await ctx.info(f\"Performing operation: {operation}\")\n\n@mcp.tool()\nasync def main_tool(data: str) -&gt; str:\n    await log_operation(\"data_processing\")  # Helper needs context\n    return process_data(data)\n</code></pre> </li> <li> <p>Callbacks and event handlers when context is needed in async callbacks</p> <pre><code>async def progress_callback(current: int, total: int):\n    ctx = mcp.get_context()  # Access context in callback\n    await ctx.report_progress(current, total)\n\n@mcp.tool()\nasync def long_operation(data: str) -&gt; str:\n    return await process_with_callback(data, progress_callback)\n</code></pre> </li> <li> <p>Class methods when context is needed in class-based code</p> <pre><code>class DataProcessor:\n    def __init__(self, mcp_server: FastMCP):\n        self.mcp = mcp_server\n\n    async def process_chunk(self, chunk: str) -&gt; str:\n        ctx = self.mcp.get_context()  # Get context in method\n        await ctx.debug(f\"Processing chunk of size {len(chunk)}\")\n        return processed_chunk\n\nprocessor = DataProcessor(mcp)\n\n@mcp.tool()\nasync def process_data(data: str) -&gt; str:\n    return await processor.process_chunk(data)\n</code></pre> </li> </ul> <p>Returns:</p> Type Description <code>Context[ServerSession, LifespanResultT, Request]</code> <p><code>Context</code> object for the current request</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>with access to all MCP capabilities including logging, progress reporting,</p> <code>Context[ServerSession, LifespanResultT, Request]</code> <p>user interaction, and session access.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>Prefer automatic injection: In most cases, declare a Context parameter in your function signature instead of calling this method:</p> <pre><code># Preferred approach\n@mcp.tool()\nasync def my_tool(data: str, ctx: Context) -&gt; str:\n    await ctx.info(\"Processing data\")\n    return result\n\n# Only use get_context() when injection isn't available\nasync def helper_function():\n    ctx = mcp.get_context()\n    await ctx.info(\"Helper called\")\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, Any] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Get a prompt by name with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts() -&gt; list[Prompt]\n</code></pre> <p>List all available prompts.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates() -&gt; list[ResourceTemplate]\n</code></pre> <p>List all available resource templates registered with this server.</p> <p>Resource templates define URI patterns that can be dynamically resolved with different parameters to access multiple related resources.</p> <p>Returns:</p> Type Description <code>list[ResourceTemplate]</code> <p>List of MCP ResourceTemplate objects containing URI templates, names,</p> <code>list[ResourceTemplate]</code> <p>and descriptions for each registered resource template.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources() -&gt; list[Resource]\n</code></pre> <p>List all available resources registered with this server.</p> <p>Returns:</p> Type Description <code>list[Resource]</code> <p>List of MCP Resource objects containing URI, name, description, and MIME type</p> <code>list[Resource]</code> <p>information for each registered resource.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools() -&gt; list[Tool]\n</code></pre> <p>List all available tools.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.prompt","title":"prompt","text":"<pre><code>prompt(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a prompt.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the prompt (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the prompt</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the prompt does</p> <code>None</code> <p>Examples:</p> <pre><code>@server.prompt()\ndef analyze_table(table_name: str) -&gt; list[Message]:\n    schema = read_table_schema(table_name)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": f\"Analyze this schema: {schema}\"\n        }\n    ]\n\n@server.prompt()\nasync def analyze_file(path: str) -&gt; list[Message]:\n    content = await read_file(path)\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": {\n                \"type\": \"resource\",\n                \"resource\": {\n                    \"uri\": f\"file://{path}\",\n                    \"text\": content\n                }\n            }\n        }\n    ]\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(\n    uri: AnyUrl | str,\n) -&gt; Iterable[ReadResourceContents]\n</code></pre> <p>Read the contents of a resource by its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>AnyUrl | str</code> <p>The URI of the resource to read</p> required <p>Returns:</p> Type Description <code>Iterable[ReadResourceContents]</code> <p>Iterable of ReadResourceContents containing the resource data</p> <p>Raises:</p> Type Description <code>ResourceError</code> <p>If the resource is not found or cannot be read</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.resource","title":"resource","text":"<pre><code>resource(\n    uri: str,\n    *,\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    mime_type: str | None = None\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a function as a resource.</p> <p>The function will be called when the resource is read to generate its content. The function can return: - str for text content - bytes for binary content - other types will be converted to JSON</p> <p>If the URI contains parameters (e.g. \"resource://{param}\") or the function has parameters, it will be registered as a template resource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>URI for the resource (e.g. \"resource://my-resource\" or \"resource://{param}\")</p> required <code>name</code> <code>str | None</code> <p>Optional name for the resource</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the resource</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of the resource</p> <code>None</code> <code>mime_type</code> <code>str | None</code> <p>Optional MIME type for the resource</p> <code>None</code> <p>Example:</p> <pre><code>@server.resource(\"resource://my-resource\")\ndef get_data() -&gt; str:\n    return \"Hello, world!\"\n\n@server.resource(\"resource://my-resource\")\nasync get_data() -&gt; str:\n    data = await fetch_data()\n    return f\"Hello, world! {data}\"\n\n@server.resource(\"resource://{city}/weather\")\ndef get_weather(city: str) -&gt; str:\n    return f\"Weather for {city}\"\n\n@server.resource(\"resource://{city}/weather\")\nasync def get_weather(city: str) -&gt; str:\n    data = await fetch_weather(city)\n    return f\"Weather for {city}: {data}\"\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.run","title":"run","text":"<pre><code>run(\n    transport: Literal[\n        \"stdio\", \"sse\", \"streamable-http\"\n    ] = \"stdio\",\n    mount_path: str | None = None,\n) -&gt; None\n</code></pre> <p>Run the FastMCP server. This is a synchronous function.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Literal['stdio', 'sse', 'streamable-http']</code> <p>Transport protocol to use (\"stdio\", \"sse\", or \"streamable-http\")</p> <code>'stdio'</code> <code>mount_path</code> <code>str | None</code> <p>Optional mount path for SSE transport</p> <code>None</code>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.run_sse_async","title":"run_sse_async  <code>async</code>","text":"<pre><code>run_sse_async(mount_path: str | None = None) -&gt; None\n</code></pre> <p>Run the server using SSE transport.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.run_stdio_async","title":"run_stdio_async  <code>async</code>","text":"<pre><code>run_stdio_async() -&gt; None\n</code></pre> <p>Run the server using stdio transport.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.run_streamable_http_async","title":"run_streamable_http_async  <code>async</code>","text":"<pre><code>run_streamable_http_async() -&gt; None\n</code></pre> <p>Run the server using StreamableHTTP transport.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.session_manager","title":"session_manager  <code>property</code>","text":"<pre><code>session_manager: StreamableHTTPSessionManager\n</code></pre> <p>Get the StreamableHTTP session manager.</p> <p>This is exposed to enable advanced use cases like mounting multiple FastMCP servers in a single FastAPI application.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before streamable_http_app() has been called.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.sse_app","title":"sse_app","text":"<pre><code>sse_app(mount_path: str | None = None) -&gt; Starlette\n</code></pre> <p>Return an instance of the SSE server app.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.streamable_http_app","title":"streamable_http_app","text":"<pre><code>streamable_http_app() -&gt; Starlette\n</code></pre> <p>Return an instance of the StreamableHTTP server app.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.FastMCP.tool","title":"tool","text":"<pre><code>tool(\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Callable[[AnyFunction], AnyFunction]\n</code></pre> <p>Decorator to register a tool.</p> <p>Tools can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and resource access.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description of what the tool does</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional ToolAnnotations providing additional tool information</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured - If None, auto-detects based on the function's return type annotation - If True, unconditionally creates a structured tool (return type annotation permitting) - If False, unconditionally creates an unstructured tool</p> <code>None</code> <p>Example:</p> <pre><code>@server.tool()\ndef my_tool(x: int) -&gt; str:\n    return str(x)\n\n@server.tool()\ndef tool_with_context(x: int, ctx: Context) -&gt; str:\n    ctx.info(f\"Processing {x}\")\n    return str(x)\n\n@server.tool()\nasync def async_tool(x: int, context: Context) -&gt; str:\n    await context.report_progress(50, 100)\n    return str(x)\n</code></pre>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Settings","title":"Settings","text":"<p>               Bases: <code>BaseSettings</code>, <code>Generic[LifespanResultT]</code></p> <p>FastMCP server settings.</p> <p>All settings can be configured via environment variables with the prefix FASTMCP_. For example, FASTMCP_DEBUG=true will set debug=True.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Settings.dependencies","title":"dependencies  <code>instance-attribute</code>","text":"<pre><code>dependencies: list[str]\n</code></pre> <p>A list of dependencies to install in the server environment.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Settings.lifespan","title":"lifespan  <code>instance-attribute</code>","text":"<pre><code>lifespan: (\n    Callable[\n        [FastMCP[LifespanResultT]],\n        AbstractAsyncContextManager[LifespanResultT],\n    ]\n    | None\n)\n</code></pre> <p>A async context manager that will be called when the server is started.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.Settings.stateless_http","title":"stateless_http  <code>instance-attribute</code>","text":"<pre><code>stateless_http: bool\n</code></pre> <p>Define if the server should create a new transport per request.</p>"},{"location":"reference/mcp/server/fastmcp/server/#mcp.server.fastmcp.server.StreamableHTTPASGIApp","title":"StreamableHTTPASGIApp","text":"<p>ASGI application for Streamable HTTP server transport.</p>"},{"location":"reference/mcp/server/fastmcp/tools/","title":"mcp.server.fastmcp.tools","text":""},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.Tool","title":"Tool","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal tool registration info.</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.Tool.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    context_kwarg: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Tool\n</code></pre> <p>Create a Tool from a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to wrap as a tool</p> required <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description (defaults to function docstring)</p> <code>None</code> <code>context_kwarg</code> <code>str | None</code> <p>Name of parameter that should receive the Context object</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional tool annotations for additional metadata</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Whether to enable structured output for this tool</p> <code>None</code> <p>Returns:</p> Type Description <code>Tool</code> <p>Tool instance configured from the function</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the function is a lambda without a provided name</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.Tool.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    arguments: dict[str, Any],\n    context: (\n        Context[ServerSessionT, LifespanContextT, RequestT]\n        | None\n    ) = None,\n    convert_result: bool = False,\n) -&gt; Any\n</code></pre> <p>Run the tool with the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>dict[str, Any]</code> <p>Dictionary of arguments to pass to the tool function</p> required <code>context</code> <code>Context[ServerSessionT, LifespanContextT, RequestT] | None</code> <p>Optional MCP context for accessing capabilities</p> <code>None</code> <code>convert_result</code> <code>bool</code> <p>Whether to convert the result using the function metadata</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The tool's execution result, potentially converted based on convert_result</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool execution fails or validation errors occur</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.ToolManager","title":"ToolManager","text":"<p>Manages registration and execution of FastMCP tools.</p> <p>The ToolManager handles tool registration, validation, and execution. It maintains a registry of tools and provides methods for adding, retrieving, and calling tools.</p> <p>Attributes:</p> Name Type Description <code>warn_on_duplicate_tools</code> <p>Whether to warn when duplicate tools are registered</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.ToolManager.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: Callable[..., Any],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Tool\n</code></pre> <p>Add a tool to the server.</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.ToolManager.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any],\n    context: (\n        Context[ServerSessionT, LifespanContextT, RequestT]\n        | None\n    ) = None,\n    convert_result: bool = False,\n) -&gt; Any\n</code></pre> <p>Call a tool by name with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.ToolManager.get_tool","title":"get_tool","text":"<pre><code>get_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Get a registered tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool to retrieve</p> required <p>Returns:</p> Type Description <code>Tool | None</code> <p>Tool instance if found, None otherwise</p>"},{"location":"reference/mcp/server/fastmcp/tools/#mcp.server.fastmcp.tools.ToolManager.list_tools","title":"list_tools","text":"<pre><code>list_tools() -&gt; list[Tool]\n</code></pre> <p>List all registered tools.</p> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>List of all Tool instances registered with this manager</p>"},{"location":"reference/mcp/server/fastmcp/tools/base/","title":"mcp.server.fastmcp.tools.base","text":""},{"location":"reference/mcp/server/fastmcp/tools/base/#mcp.server.fastmcp.tools.base.Tool","title":"Tool","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal tool registration info.</p>"},{"location":"reference/mcp/server/fastmcp/tools/base/#mcp.server.fastmcp.tools.base.Tool.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    context_kwarg: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Tool\n</code></pre> <p>Create a Tool from a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to wrap as a tool</p> required <code>name</code> <code>str | None</code> <p>Optional name for the tool (defaults to function name)</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional human-readable title for the tool</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description (defaults to function docstring)</p> <code>None</code> <code>context_kwarg</code> <code>str | None</code> <p>Name of parameter that should receive the Context object</p> <code>None</code> <code>annotations</code> <code>ToolAnnotations | None</code> <p>Optional tool annotations for additional metadata</p> <code>None</code> <code>structured_output</code> <code>bool | None</code> <p>Whether to enable structured output for this tool</p> <code>None</code> <p>Returns:</p> Type Description <code>Tool</code> <p>Tool instance configured from the function</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the function is a lambda without a provided name</p>"},{"location":"reference/mcp/server/fastmcp/tools/base/#mcp.server.fastmcp.tools.base.Tool.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    arguments: dict[str, Any],\n    context: (\n        Context[ServerSessionT, LifespanContextT, RequestT]\n        | None\n    ) = None,\n    convert_result: bool = False,\n) -&gt; Any\n</code></pre> <p>Run the tool with the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>dict[str, Any]</code> <p>Dictionary of arguments to pass to the tool function</p> required <code>context</code> <code>Context[ServerSessionT, LifespanContextT, RequestT] | None</code> <p>Optional MCP context for accessing capabilities</p> <code>None</code> <code>convert_result</code> <code>bool</code> <p>Whether to convert the result using the function metadata</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The tool's execution result, potentially converted based on convert_result</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool execution fails or validation errors occur</p>"},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/","title":"mcp.server.fastmcp.tools.tool_manager","text":""},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/#mcp.server.fastmcp.tools.tool_manager.ToolManager","title":"ToolManager","text":"<p>Manages registration and execution of FastMCP tools.</p> <p>The ToolManager handles tool registration, validation, and execution. It maintains a registry of tools and provides methods for adding, retrieving, and calling tools.</p> <p>Attributes:</p> Name Type Description <code>warn_on_duplicate_tools</code> <p>Whether to warn when duplicate tools are registered</p>"},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/#mcp.server.fastmcp.tools.tool_manager.ToolManager.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: Callable[..., Any],\n    name: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    annotations: ToolAnnotations | None = None,\n    structured_output: bool | None = None,\n) -&gt; Tool\n</code></pre> <p>Add a tool to the server.</p>"},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/#mcp.server.fastmcp.tools.tool_manager.ToolManager.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any],\n    context: (\n        Context[ServerSessionT, LifespanContextT, RequestT]\n        | None\n    ) = None,\n    convert_result: bool = False,\n) -&gt; Any\n</code></pre> <p>Call a tool by name with arguments.</p>"},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/#mcp.server.fastmcp.tools.tool_manager.ToolManager.get_tool","title":"get_tool","text":"<pre><code>get_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Get a registered tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool to retrieve</p> required <p>Returns:</p> Type Description <code>Tool | None</code> <p>Tool instance if found, None otherwise</p>"},{"location":"reference/mcp/server/fastmcp/tools/tool_manager/#mcp.server.fastmcp.tools.tool_manager.ToolManager.list_tools","title":"list_tools","text":"<pre><code>list_tools() -&gt; list[Tool]\n</code></pre> <p>List all registered tools.</p> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>List of all Tool instances registered with this manager</p>"},{"location":"reference/mcp/server/fastmcp/utilities/","title":"mcp.server.fastmcp.utilities","text":"<p>FastMCP utility modules.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/","title":"mcp.server.fastmcp.utilities.func_metadata","text":""},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.ArgModelBase","title":"ArgModelBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing the arguments to a function.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.ArgModelBase.model_dump_one_level","title":"model_dump_one_level","text":"<pre><code>model_dump_one_level() -&gt; dict[str, Any]\n</code></pre> <p>Return a dict of the model's fields, one level deep.</p> <p>That is, sub-models etc are not dumped - they are kept as pydantic models.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.FuncMetadata","title":"FuncMetadata","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.FuncMetadata.call_fn_with_arg_validation","title":"call_fn_with_arg_validation  <code>async</code>","text":"<pre><code>call_fn_with_arg_validation(\n    fn: Callable[..., Any | Awaitable[Any]],\n    fn_is_async: bool,\n    arguments_to_validate: dict[str, Any],\n    arguments_to_pass_directly: dict[str, Any] | None,\n) -&gt; Any\n</code></pre> <p>Call the given function with arguments validated and injected.</p> <p>Arguments are first attempted to be parsed from JSON, then validated against the argument model, before being passed to the function.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.FuncMetadata.convert_result","title":"convert_result","text":"<pre><code>convert_result(result: Any) -&gt; Any\n</code></pre> <p>Convert the result of a function call to the appropriate format for  the lowlevel server tool call handler:</p> <ul> <li>If output_model is None, return the unstructured content directly.</li> <li>If output_model is not None, convert the result to structured output format     (dict[str, Any]) and return both unstructured and structured content.</li> </ul> <p>Note: we return unstructured content here even though the lowlevel server tool call handler provides generic backwards compatibility serialization of structured content. This is for FastMCP backwards compatibility: we need to retain FastMCP's ad hoc conversion logic for constructing unstructured output from function return values, whereas the lowlevel server simply serializes the structured output.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.FuncMetadata.pre_parse_json","title":"pre_parse_json","text":"<pre><code>pre_parse_json(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Pre-parse data from JSON.</p> <p>Return a dict with same keys as input but with values parsed from JSON if appropriate.</p> <p>This is to handle cases like <code>[\"a\", \"b\", \"c\"]</code> being passed in as JSON inside a string rather than an actual list. Claude desktop is prone to this - in fact it seems incapable of NOT doing this. For sub-models, it tends to pass dicts (JSON objects) as JSON strings, which can be pre-parsed here.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.StrictJsonSchema","title":"StrictJsonSchema","text":"<p>               Bases: <code>GenerateJsonSchema</code></p> <p>A JSON schema generator that raises exceptions instead of emitting warnings.</p> <p>This is used to detect non-serializable types during schema generation.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/func_metadata/#mcp.server.fastmcp.utilities.func_metadata.func_metadata","title":"func_metadata","text":"<pre><code>func_metadata(\n    func: Callable[..., Any],\n    skip_names: Sequence[str] = (),\n    structured_output: bool | None = None,\n) -&gt; FuncMetadata\n</code></pre> <p>Given a function, return metadata including a pydantic model representing its signature.</p> <p>The use case for this is <pre><code>meta = func_metadata(func)\nvalidated_args = meta.arg_model.model_validate(some_raw_data_dict)\nreturn func(**validated_args.model_dump_one_level())\n</code></pre></p> <p>critically it also provides pre-parse helper to attempt to parse things from JSON.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to convert to a pydantic model</p> required <code>skip_names</code> <code>Sequence[str]</code> <p>A list of parameter names to skip. These will not be included in the model.</p> <code>()</code> <code>structured_output</code> <code>bool | None</code> <p>Controls whether the tool's output is structured or unstructured. If None, auto-detects based on the function's return type annotation. If True, unconditionally creates a structured tool (return type annotation permitting). If False, unconditionally creates an unstructured tool.</p> <code>None</code> Note <p>If structured, creates a Pydantic model for the function's result based on its annotation. Supports various return types:     - BaseModel subclasses (used directly)     - Primitive types (str, int, float, bool, bytes, None) - wrapped in a         model with a 'result' field     - TypedDict - converted to a Pydantic model with same fields     - Dataclasses and other annotated classes - converted to Pydantic models     - Generic types (list, dict, Union, etc.) - wrapped in a model with a 'result' field</p> <p>Returns:</p> Type Description <code>FuncMetadata</code> <p>A FuncMetadata object containing:</p> <code>FuncMetadata</code> <ul> <li>arg_model: A pydantic model representing the function's arguments</li> </ul> <code>FuncMetadata</code> <ul> <li>output_model: A pydantic model for the return type if output is structured</li> </ul> <code>FuncMetadata</code> <ul> <li>output_conversion: Records how function output should be converted before returning.</li> </ul>"},{"location":"reference/mcp/server/fastmcp/utilities/logging/","title":"mcp.server.fastmcp.utilities.logging","text":"<p>Logging utilities for FastMCP.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/logging/#mcp.server.fastmcp.utilities.logging.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(\n    level: Literal[\n        \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"\n    ] = \"INFO\",\n) -&gt; None\n</code></pre> <p>Configure logging for MCP.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>the log level to use</p> <code>'INFO'</code>"},{"location":"reference/mcp/server/fastmcp/utilities/logging/#mcp.server.fastmcp.utilities.logging.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str) -&gt; Logger\n</code></pre> <p>Get a logger nested under MCPnamespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the logger, which will be prefixed with 'FastMCP.'</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>a configured logger instance</p>"},{"location":"reference/mcp/server/fastmcp/utilities/types/","title":"mcp.server.fastmcp.utilities.types","text":"<p>Common types used across FastMCP.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/types/#mcp.server.fastmcp.utilities.types.Image","title":"Image","text":"<p>Helper class for returning images from tools.</p>"},{"location":"reference/mcp/server/fastmcp/utilities/types/#mcp.server.fastmcp.utilities.types.Image.to_image_content","title":"to_image_content","text":"<pre><code>to_image_content() -&gt; ImageContent\n</code></pre> <p>Convert to MCP ImageContent.</p>"},{"location":"reference/mcp/server/lowlevel/","title":"mcp.server.lowlevel","text":""},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server","title":"Server","text":"<p>               Bases: <code>Generic[LifespanResultT, RequestT]</code></p>"},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server.call_tool","title":"call_tool","text":"<pre><code>call_tool(*, validate_input: bool = True)\n</code></pre> <p>Register a tool call handler.</p> <p>Parameters:</p> Name Type Description Default <code>validate_input</code> <code>bool</code> <p>If True, validates input against inputSchema. Default is True.</p> <code>True</code> <p>The handler validates input against inputSchema (if validate_input=True), calls the tool function, and builds a CallToolResult with the results:</p> <ul> <li>Unstructured content (iterable of ContentBlock): returned in content</li> <li>Structured content (dict): returned in structuredContent, serialized JSON text returned in content</li> <li>Both: returned in content and structuredContent</li> </ul> <p>If outputSchema is defined, validates structuredContent or errors if missing.</p>"},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Provides completions for prompts and resource templates</p>"},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server.create_initialization_options","title":"create_initialization_options","text":"<pre><code>create_initialization_options(\n    notification_options: NotificationOptions | None = None,\n    experimental_capabilities: (\n        dict[str, dict[str, Any]] | None\n    ) = None,\n) -&gt; InitializationOptions\n</code></pre> <p>Create initialization options from this server instance.</p>"},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(\n    notification_options: NotificationOptions,\n    experimental_capabilities: dict[str, dict[str, Any]],\n) -&gt; ServerCapabilities\n</code></pre> <p>Convert existing handlers to a ServerCapabilities object.</p>"},{"location":"reference/mcp/server/lowlevel/#mcp.server.lowlevel.Server.request_context","title":"request_context  <code>property</code>","text":"<pre><code>request_context: RequestContext[\n    ServerSession, LifespanResultT, RequestT\n]\n</code></pre> <p>Access the current request context for low-level MCP server operations.</p> <p>This property provides access to the <code>RequestContext</code> for the current request, which contains the session, request metadata, lifespan context, and other request-scoped information. This is the primary way to access MCP capabilities when using the low-level SDK.</p> <p>You typically access this property from within handler functions (tool handlers, resource handlers, prompt handlers, etc.) to get the context for the current client request. The context is automatically managed by the server and is only available during request processing.</p> <p>Examples:</p> <p>Logging and communication:</p> <pre><code>@app.call_tool()\nasync def my_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    await ctx.session.send_log_message(\n        level=\"info\",\n        data=\"Starting tool processing\",\n        related_request_id=ctx.request_id\n    )\n</code></pre> <p>Capability checking:</p> <pre><code>@app.call_tool()\nasync def advanced_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Use advanced features\n        response = await ctx.session.create_message(messages, max_tokens=100)\n    else:\n        # Fall back to basic functionality\n        pass\n</code></pre> <p>Accessing lifespan resources:</p> <pre><code>@app.call_tool()\nasync def database_query(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    db = ctx.lifespan_context[\"database\"]  # Access startup resource\n    results = await db.query(arguments[\"sql\"])\n    return [types.TextContent(type=\"text\", text=str(results))]\n</code></pre> <p>Returns:</p> Type Description <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p><code>RequestContext</code> for the current request,</p> <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p>containing session, metadata, and lifespan context.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>For FastMCP applications, consider using the injected <code>Context</code> parameter instead, which provides the same functionality with additional convenience methods and better ergonomics.</p>"},{"location":"reference/mcp/server/lowlevel/helper_types/","title":"mcp.server.lowlevel.helper_types","text":""},{"location":"reference/mcp/server/lowlevel/helper_types/#mcp.server.lowlevel.helper_types.ReadResourceContents","title":"ReadResourceContents  <code>dataclass</code>","text":"<p>Contents returned from a read_resource call.</p>"},{"location":"reference/mcp/server/lowlevel/server/","title":"mcp.server.lowlevel.server","text":"<p>MCP Server Module</p> <p>This module provides a framework for creating an MCP (Model Context Protocol) server. It allows you to easily define and handle various types of requests and notifications in an asynchronous manner.</p> <p>The <code>Server</code> class provides methods to register handlers for various MCP requests and notifications. It automatically manages the request context and handles incoming messages from the client.</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server--usage-example","title":"Usage example","text":"<ol> <li> <p>Create a <code>Server</code> instance:</p> <pre><code>server = Server(\"your_server_name\")\n</code></pre> </li> <li> <p>Define request handlers using decorators:</p> <pre><code>@server.list_prompts()\nasync def handle_list_prompts() -&gt; list[types.Prompt]:\n    # Implementation\n    ...\n\n@server.get_prompt()\nasync def handle_get_prompt(\n    name: str, arguments: dict[str, str] | None\n) -&gt; types.GetPromptResult:\n    # Implementation\n    ...\n\n@server.list_tools()\nasync def handle_list_tools() -&gt; list[types.Tool]:\n    # Implementation\n    ...\n\n@server.call_tool()\nasync def handle_call_tool(\n    name: str, arguments: dict | None\n) -&gt; list[types.TextContent | types.ImageContent | types.EmbeddedResource]:\n    # Implementation\n    ...\n\n@server.list_resource_templates()\nasync def handle_list_resource_templates() -&gt; list[types.ResourceTemplate]:\n    # Implementation\n    ...\n</code></pre> </li> <li> <p>Define notification handlers if needed:</p> <pre><code>@server.progress_notification()\nasync def handle_progress(\n    progress_token: str | int, progress: float, total: float | None,\n    message: str | None\n) -&gt; None:\n    # Implementation\n    ...\n</code></pre> </li> <li> <p>Run the server:</p> <pre><code>async def main():\n    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            InitializationOptions(\n                server_name=\"your_server_name\",\n                server_version=\"your_version\",\n                capabilities=server.get_capabilities(\n                    notification_options=NotificationOptions(),\n                    experimental_capabilities={},\n                ),\n            ),\n        )\n\nasyncio.run(main())\n</code></pre> </li> </ol>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server","title":"Server","text":"<p>               Bases: <code>Generic[LifespanResultT, RequestT]</code></p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server.call_tool","title":"call_tool","text":"<pre><code>call_tool(*, validate_input: bool = True)\n</code></pre> <p>Register a tool call handler.</p> <p>Parameters:</p> Name Type Description Default <code>validate_input</code> <code>bool</code> <p>If True, validates input against inputSchema. Default is True.</p> <code>True</code> <p>The handler validates input against inputSchema (if validate_input=True), calls the tool function, and builds a CallToolResult with the results:</p> <ul> <li>Unstructured content (iterable of ContentBlock): returned in content</li> <li>Structured content (dict): returned in structuredContent, serialized JSON text returned in content</li> <li>Both: returned in content and structuredContent</li> </ul> <p>If outputSchema is defined, validates structuredContent or errors if missing.</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server.completion","title":"completion","text":"<pre><code>completion()\n</code></pre> <p>Provides completions for prompts and resource templates</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server.create_initialization_options","title":"create_initialization_options","text":"<pre><code>create_initialization_options(\n    notification_options: NotificationOptions | None = None,\n    experimental_capabilities: (\n        dict[str, dict[str, Any]] | None\n    ) = None,\n) -&gt; InitializationOptions\n</code></pre> <p>Create initialization options from this server instance.</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(\n    notification_options: NotificationOptions,\n    experimental_capabilities: dict[str, dict[str, Any]],\n) -&gt; ServerCapabilities\n</code></pre> <p>Convert existing handlers to a ServerCapabilities object.</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.Server.request_context","title":"request_context  <code>property</code>","text":"<pre><code>request_context: RequestContext[\n    ServerSession, LifespanResultT, RequestT\n]\n</code></pre> <p>Access the current request context for low-level MCP server operations.</p> <p>This property provides access to the <code>RequestContext</code> for the current request, which contains the session, request metadata, lifespan context, and other request-scoped information. This is the primary way to access MCP capabilities when using the low-level SDK.</p> <p>You typically access this property from within handler functions (tool handlers, resource handlers, prompt handlers, etc.) to get the context for the current client request. The context is automatically managed by the server and is only available during request processing.</p> <p>Examples:</p> <p>Logging and communication:</p> <pre><code>@app.call_tool()\nasync def my_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    await ctx.session.send_log_message(\n        level=\"info\",\n        data=\"Starting tool processing\",\n        related_request_id=ctx.request_id\n    )\n</code></pre> <p>Capability checking:</p> <pre><code>@app.call_tool()\nasync def advanced_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Use advanced features\n        response = await ctx.session.create_message(messages, max_tokens=100)\n    else:\n        # Fall back to basic functionality\n        pass\n</code></pre> <p>Accessing lifespan resources:</p> <pre><code>@app.call_tool()\nasync def database_query(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    db = ctx.lifespan_context[\"database\"]  # Access startup resource\n    results = await db.query(arguments[\"sql\"])\n    return [types.TextContent(type=\"text\", text=str(results))]\n</code></pre> <p>Returns:</p> Type Description <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p><code>RequestContext</code> for the current request,</p> <code>RequestContext[ServerSession, LifespanResultT, RequestT]</code> <p>containing session, metadata, and lifespan context.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If called outside of a request context (e.g., during server initialization, shutdown, or from code not handling a client request).</p> Note <p>For FastMCP applications, consider using the injected <code>Context</code> parameter instead, which provides the same functionality with additional convenience methods and better ergonomics.</p>"},{"location":"reference/mcp/server/lowlevel/server/#mcp.server.lowlevel.server.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(\n    _: Server[LifespanResultT, RequestT],\n) -&gt; AsyncIterator[dict[str, Any]]\n</code></pre> <p>Default lifespan context manager that does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Server[LifespanResultT, RequestT]</code> <p>The server instance this lifespan is managing</p> required <p>Returns:</p> Type Description <code>AsyncIterator[dict[str, Any]]</code> <p>An empty context object</p>"},{"location":"reference/mcp/server/models/","title":"mcp.server.models","text":"<p>This module provides simpler types to use with the server for managing prompts and tools.</p>"},{"location":"reference/mcp/server/session/","title":"mcp.server.session","text":"<p>ServerSession Module</p> <p>This module provides the ServerSession class, which manages communication between the server and client in the MCP (Model Context Protocol) framework. It is most commonly used in MCP servers to interact with the client.</p> <p>Common usage pattern: <pre><code>server = Server(name)\n\n@server.call_tool()\nasync def handle_tool_call(ctx: RequestContext, arguments: dict[str, Any]) -&gt; Any:\n    # Check client capabilities before proceeding\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(experimental={\"advanced_tools\": dict()})\n    ):\n        # Perform advanced tool operations\n        result = await perform_advanced_tool_operation(arguments)\n    else:\n        # Fall back to basic tool operations\n        result = await perform_basic_tool_operation(arguments)\n    return result\n\n@server.list_prompts()\nasync def handle_list_prompts(ctx: RequestContext) -&gt; list[types.Prompt]:\n    # Access session for any necessary checks or operations\n    if ctx.session.client_params:\n        # Customize prompts based on client initialization parameters\n        return generate_custom_prompts(ctx.session.client_params)\n    else:\n        return default_prompts\n</code></pre></p> <p>The ServerSession class is typically used internally by the Server class and should not be instantiated directly by users of the MCP framework.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports specific capabilities before using advanced MCP features.</p> <p>This method allows MCP servers to verify that the connected client supports required capabilities before calling methods that depend on them. It performs an AND operation - the client must support ALL capabilities specified in the request, not just some of them.</p> <p>You typically access this method through the session available in your request context via <code>app.request_context.session</code>  within handler functions. Always check capabilities before using features like sampling, elicitation, or experimental functionality.</p> <p>Parameters:</p> Name Type Description Default <code>capability</code> <code>ClientCapabilities</code> <p>A <code>types.ClientCapabilities</code> object specifying which capabilities to check. Can include:</p> <ul> <li><code>roots</code>: Check if client supports root listing operations</li> <li><code>sampling</code>: Check if client supports LLM sampling via <code>create_message</code> </li> <li><code>elicitation</code>: Check if client supports user interaction via <code>elicit</code></li> <li><code>experimental</code>: Check for non-standard experimental capabilities</li> </ul> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the client supports ALL requested capabilities, <code>False</code> if the client hasn't been initialized yet or lacks any of the requested capabilities.</p> <p>Examples:</p> <p>Check sampling capability before creating LLM messages:</p> <pre><code>from typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n\n    # Check if client supports LLM sampling\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(sampling=types.SamplingCapability())\n    ):\n        # Safe to use create_message\n        response = await ctx.session.create_message(\n            messages=[types.SamplingMessage(\n                role=\"user\", \n                content=types.TextContent(type=\"text\", text=\"Help me analyze this data\")\n            )],\n            max_tokens=100\n        )\n        return [types.TextContent(type=\"text\", text=response.content.text)]\n    else:\n        return [types.TextContent(type=\"text\", text=\"Client doesn't support LLM sampling\")]\n</code></pre> <p>Check experimental capabilities:</p> <pre><code>@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n\n    # Check for experimental advanced tools capability\n    if ctx.session.check_client_capability(\n        types.ClientCapabilities(experimental={\"advanced_tools\": {}})\n    ):\n        # Use experimental features\n        return await use_advanced_tool_features(arguments)\n    else:\n        # Fall back to basic functionality\n        return await use_basic_tool_features(arguments)\n</code></pre> <p>Check multiple capabilities at once:</p> <pre><code># Client must support BOTH sampling AND elicitation\nif ctx.session.check_client_capability(\n    types.ClientCapabilities(\n        sampling=types.SamplingCapability(),\n        elicitation=types.ElicitationCapability()\n    )\n):\n    # Safe to use both features\n    user_input = await ctx.session.elicit(\"What would you like to analyze?\", schema)\n    llm_response = await ctx.session.create_message(messages, max_tokens=100)\n</code></pre> Note <p>This method returns <code>False</code> if the session hasn't been initialized yet (before the client sends the initialization request). It also returns <code>False</code> if the client lacks ANY of the requested capabilities - all specified capabilities must be supported for this method to return <code>True</code>.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre> <p>Send a message to an LLM through the MCP client for processing.</p> <p>This method enables MCP servers to request LLM sampling from the connected client. The client forwards the request to its configured LLM provider (OpenAI, Anthropic, etc.) and returns the generated response. This is useful for tools that need LLM assistance to process user requests or generate content.</p> <p>The client must support the sampling capability for this method to work. Check client capabilities using <code>check_client_capability</code> before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[SamplingMessage]</code> <p>List of <code>SamplingMessage</code> objects representing the conversation history. Each message has a role (\"user\" or \"assistant\") and content (text, image, or audio).</p> required <code>max_tokens</code> <code>int</code> <p>Maximum number of tokens the LLM should generate in the response.</p> required <code>system_prompt</code> <code>str | None</code> <p>Optional system message to set the LLM's behavior and context.</p> <code>None</code> <code>include_context</code> <code>IncludeContext | None</code> <p>Optional context inclusion preferences for the LLM request.</p> <code>None</code> <code>temperature</code> <code>float | None</code> <p>Optional sampling temperature (0.0-1.0) controlling response randomness. Lower values make responses more deterministic.</p> <code>None</code> <code>stop_sequences</code> <code>list[str] | None</code> <p>Optional list of strings that will cause the LLM to stop generating when encountered in the response.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Optional arbitrary metadata to include with the request.</p> <code>None</code> <code>model_preferences</code> <code>ModelPreferences | None</code> <p>Optional preferences for which model the client should use.</p> <code>None</code> <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID linking this request to a parent request for tracing.</p> <code>None</code> <p>Returns:</p> Type Description <code>CreateMessageResult</code> <p>CreateMessageResult containing the LLM's response with role, content, model name, and stop reason information.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on client implementation and LLM provider errors.</p> <p>Examples:</p> <p>Basic text generation:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nresult = await session.create_message(\n    messages=[\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"Explain quantum computing\")\n        )\n    ],\n    max_tokens=150\n)\nprint(result.content.text)  # Generated explanation\n</code></pre> <p>Multi-turn conversation with system prompt:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nresult = await session.create_message(\n    messages=[\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"What's the weather like?\")\n        ),\n        SamplingMessage(\n            role=\"assistant\",\n            content=TextContent(type=\"text\", text=\"I don't have access to weather data.\")\n        ),\n        SamplingMessage(\n            role=\"user\",\n            content=TextContent(type=\"text\", text=\"Then help me write a poem about rain\")\n        )\n    ],\n    max_tokens=100,\n    system_prompt=\"You are a helpful poetry assistant.\",\n    temperature=0.8\n)\n</code></pre> Note <p>This method requires the client to have sampling capability enabled. Most modern MCP clients support this, but always check capabilities before use in production code.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str,\n    requestedSchema: ElicitRequestedSchema,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send an elicitation request to collect structured information from the client.</p> <p>This is the low-level method for client elicitation. For most use cases, prefer the higher-level <code>Context.elicit</code> method which provides automatic Pydantic validation and a more convenient interface.</p> <p>You typically access this method through the session available in your request context via <code>app.request_context.session</code>  within handler functions. Always check that the client supports elicitation using <code>check_client_capability</code>  before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt or question to present to the user.</p> required <code>requestedSchema</code> <code>ElicitRequestedSchema</code> <p>A <code>types.ElicitRequestedSchema</code>  defining the expected response structure according to JSON Schema.</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional <code>types.RequestId</code> linking  this elicitation to a specific client request for tracing.</p> <code>None</code> <p>Returns:</p> Type Description <code>ElicitResult</code> <p><code>types.ElicitResult</code> containing the client's response</p> <code>ElicitResult</code> <p>and action taken (accept, decline, or cancel).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on client implementation and user interaction.</p> Note <p>Most developers should use <code>Context.elicit</code>  instead, which provides Pydantic model validation and better error handling.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification from the server to the client.</p> <p>This method allows MCP servers to send log messages to the connected client for debugging, monitoring, and error reporting purposes. The client can filter these messages based on the logging level it has configured via the logging/setLevel request. Check client capabilities using <code>check_client_capability</code> if you need to verify logging support.</p> <p>You typically access this method through the session available in your request context. When using the low-level SDK, access it via  <code>app.request_context.session</code> within handler functions. With FastMCP, use the convenience logging methods on the  <code>Context</code> object instead, like <code>ctx.info()</code> or  <code>ctx.error()</code>.</p> <p>Log messages are one-way notifications and do not expect a response from the client. They are useful for providing visibility into server operations, debugging issues, and tracking the flow of request processing.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LoggingLevel</code> <p>The severity level of the log message as a <code>types.LoggingLevel</code>. Must be one of:</p> <ul> <li><code>debug</code>: Detailed information for debugging</li> <li><code>info</code>: General informational messages</li> <li><code>notice</code>: Normal but significant conditions</li> <li><code>warning</code>: Warning conditions that should be addressed</li> <li><code>error</code>: Error conditions that don't prevent operation</li> <li><code>critical</code>: Critical conditions requiring immediate attention</li> <li><code>alert</code>: Action must be taken immediately</li> <li><code>emergency</code>: System is unusable</li> </ul> required <code>data</code> <code>Any</code> <p>The data to log. Can be any JSON-serializable value including:</p> <ul> <li>Simple strings for text messages</li> <li>Objects/dictionaries for structured logging</li> <li>Lists for multiple related items</li> <li>Numbers, booleans, or null values</li> </ul> required <code>logger</code> <code>str | None</code> <p>Optional name to identify the source of the log message. Useful for categorizing logs from different components or modules within your server (e.g., \"database\", \"auth\", \"tool_handler\").</p> <code>None</code> <code>related_request_id</code> <code>RequestId | None</code> <p>Optional <code>types.RequestId</code> linking this log to a specific client request. Use this to associate log messages with the request they relate to, making it easier to trace request processing and debug issues.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called before session initialization is complete.</p> <code>Various exceptions</code> <p>Depending on serialization or transport errors.</p> <p>Examples:</p> <p>In a tool handler using the low-level SDK:</p> <pre><code>from typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    # Access the request context to get the session\n    ctx = app.request_context\n\n    # Log the start of processing\n    await ctx.session.send_log_message(\n        level=\"info\",\n        data=f\"Processing tool call: {name}\",\n        logger=\"tool_handler\",\n        related_request_id=ctx.request_id\n    )\n\n    # Process and log any issues\n    try:\n        result = perform_operation(arguments)\n    except Exception as e:\n        await ctx.session.send_log_message(\n            level=\"error\",\n            data={\"error\": str(e), \"tool\": name, \"args\": arguments},\n            logger=\"tool_handler\",\n            related_request_id=ctx.request_id\n        )\n        raise\n\n    return [types.TextContent(type=\"text\", text=str(result))]\n</code></pre> <p>Using FastMCP's <code>Context</code> helper for cleaner logging:</p> <pre><code>from mcp.server.fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"example-server\")\n\n@mcp.tool()\nasync def fetch_data(url: str, ctx: Context) -&gt; str:\n    # FastMCP's Context provides convenience methods that internally\n    # call send_log_message with the appropriate parameters\n    await ctx.info(f\"Fetching data from {url}\")\n    await ctx.debug(\"Starting request\")\n\n    try:\n        data = await fetch(url)\n        await ctx.info(\"Data fetched successfully\")\n        return data\n    except Exception as e:\n        await ctx.error(f\"Failed to fetch: {e}\")\n        raise\n</code></pre> <p>Streaming notifications with progress updates:</p> <pre><code>import anyio\nfrom typing import Any\nfrom mcp.server.lowlevel import Server\nimport mcp.types as types\n\napp = Server(\"example-server\")\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context\n    count = arguments.get(\"count\", 5)\n\n    for i in range(count):\n        # Send progress updates to the client\n        await ctx.session.send_log_message(\n            level=\"info\",\n            data=f\"[{i + 1}/{count}] Processing item\",\n            logger=\"progress_stream\",\n            related_request_id=ctx.request_id\n        )\n        if i &lt; count - 1:\n            await anyio.sleep(1)\n\n    return [types.TextContent(type=\"text\", text=\"Operation complete\")]\n</code></pre> Note <p>Log messages are only delivered to the client if the client's configured logging level permits it. For example, if the client has set its level to \"warning\", it will not receive \"debug\" or \"info\" messages. Consider this when deciding what level to use for your log messages. This method internally uses <code>send_notification</code> to deliver the log message to the client.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p>"},{"location":"reference/mcp/server/session/#mcp.server.session.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p>"},{"location":"reference/mcp/server/sse/","title":"mcp.server.sse","text":"<p>SSE Server Transport Module</p> <p>This module implements a Server-Sent Events (SSE) transport layer for MCP servers.</p> <p>Example usage: <pre><code>    # Create an SSE transport at an endpoint\n    sse = SseServerTransport(\"/messages/\")\n\n    # Create Starlette routes for SSE and message handling\n    routes = [\n        Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n        Mount(\"/messages/\", app=sse.handle_post_message),\n    ]\n\n    # Define handler functions\n    async def handle_sse(request):\n        async with sse.connect_sse(\n            request.scope, request.receive, request._send\n        ) as streams:\n            await app.run(\n                streams[0], streams[1], app.create_initialization_options()\n            )\n        # Return empty response to avoid NoneType error\n        return Response()\n\n    # Create and run Starlette app\n    starlette_app = Starlette(routes=routes)\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n</code></pre></p> <p>Note: The handle_sse function must return a Response to avoid a \"TypeError: 'NoneType' object is not callable\" error when client disconnects. The example above returns an empty Response() after the SSE connection ends to fix this.</p> <p>See SseServerTransport class documentation for more details.</p>"},{"location":"reference/mcp/server/sse/#mcp.server.sse.SseServerTransport","title":"SseServerTransport","text":"<p>SSE server transport for MCP. This class provides two ASGI applications, suitable to be used with a framework like Starlette and a server like Hypercorn:</p> <pre><code>1. connect_sse() is an ASGI application which receives incoming GET requests,\n   and sets up a new SSE stream to send server messages to the client.\n2. handle_post_message() is an ASGI application which receives incoming POST\n   requests, which should contain client messages that link to a\n   previously-established SSE session.\n</code></pre>"},{"location":"reference/mcp/server/sse/#mcp.server.sse.SseServerTransport.__init__","title":"__init__","text":"<pre><code>__init__(\n    endpoint: str,\n    security_settings: (\n        TransportSecuritySettings | None\n    ) = None,\n) -&gt; None\n</code></pre> <p>Creates a new SSE server transport, which will direct the client to POST messages to the relative path given.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>A relative path where messages should be posted     (e.g., \"/messages/\").</p> required <code>security_settings</code> <code>TransportSecuritySettings | None</code> <p>Optional security settings for DNS rebinding protection.</p> <code>None</code> Note <p>We use relative paths instead of full URLs for several reasons: 1. Security: Prevents cross-origin requests by ensuring clients only connect    to the same origin they established the SSE connection with 2. Flexibility: The server can be mounted at any path without needing to    know its full URL 3. Portability: The same endpoint configuration works across different    environments (development, staging, production)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the endpoint is a full URL instead of a relative path</p>"},{"location":"reference/mcp/server/stdio/","title":"mcp.server.stdio","text":"<p>Stdio Server Transport Module</p> <p>This module provides functionality for creating an stdio-based transport layer that can be used to communicate with an MCP client through standard input/output streams.</p> <p>Example usage: <pre><code>    async def run_server():\n        async with stdio_server() as (read_stream, write_stream):\n            # read_stream contains incoming JSONRPCMessages from stdin\n            # write_stream allows sending JSONRPCMessages to stdout\n            server = await create_my_server()\n            await server.run(read_stream, write_stream, init_options)\n\n    anyio.run(run_server)\n</code></pre></p>"},{"location":"reference/mcp/server/stdio/#mcp.server.stdio.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p>"},{"location":"reference/mcp/server/streamable_http/","title":"mcp.server.streamable_http","text":"<p>StreamableHTTP Server Transport Module</p> <p>This module implements an HTTP transport layer with Streamable HTTP.</p> <p>The transport handles bidirectional communication using HTTP requests and responses, with streaming support for long-running operations.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.EventMessage","title":"EventMessage  <code>dataclass</code>","text":"<p>A JSONRPCMessage with an optional event ID for stream resumability.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.EventStore","title":"EventStore","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for resumability support via event storage.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.EventStore.replay_events_after","title":"replay_events_after  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>replay_events_after(\n    last_event_id: EventId, send_callback: EventCallback\n) -&gt; StreamId | None\n</code></pre> <p>Replays events that occurred after the specified event ID.</p> <p>Parameters:</p> Name Type Description Default <code>last_event_id</code> <code>EventId</code> <p>The ID of the last event the client received</p> required <code>send_callback</code> <code>EventCallback</code> <p>A callback function to send events to the client</p> required <p>Returns:</p> Type Description <code>StreamId | None</code> <p>The stream ID of the replayed events</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.EventStore.store_event","title":"store_event  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>store_event(\n    stream_id: StreamId, message: JSONRPCMessage\n) -&gt; EventId\n</code></pre> <p>Stores an event for later retrieval.</p> <p>Parameters:</p> Name Type Description Default <code>stream_id</code> <code>StreamId</code> <p>ID of the stream the event belongs to</p> required <code>message</code> <code>JSONRPCMessage</code> <p>The JSON-RPC message to store</p> required <p>Returns:</p> Type Description <code>EventId</code> <p>The generated event ID for the stored event</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport","title":"StreamableHTTPServerTransport","text":"<p>HTTP server transport with event streaming support for MCP.</p> <p>Handles JSON-RPC messages in HTTP POST requests with SSE streaming. Supports optional JSON responses and session management.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport.__init__","title":"__init__","text":"<pre><code>__init__(\n    mcp_session_id: str | None,\n    is_json_response_enabled: bool = False,\n    event_store: EventStore | None = None,\n    security_settings: (\n        TransportSecuritySettings | None\n    ) = None,\n) -&gt; None\n</code></pre> <p>Initialize a new StreamableHTTP server transport.</p> <p>Parameters:</p> Name Type Description Default <code>mcp_session_id</code> <code>str | None</code> <p>Optional session identifier for this connection.             Must contain only visible ASCII characters (0x21-0x7E).</p> required <code>is_json_response_enabled</code> <code>bool</code> <p>If True, return JSON responses for requests                     instead of SSE streams. Default is False.</p> <code>False</code> <code>event_store</code> <code>EventStore | None</code> <p>Event store for resumability support. If provided,         resumability will be enabled, allowing clients to         reconnect and resume messages.</p> <code>None</code> <code>security_settings</code> <code>TransportSecuritySettings | None</code> <p>Optional security settings for DNS rebinding protection.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the session ID contains invalid characters.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; AsyncGenerator[\n    tuple[\n        MemoryObjectReceiveStream[\n            SessionMessage | Exception\n        ],\n        MemoryObjectSendStream[SessionMessage],\n    ],\n    None,\n]\n</code></pre> <p>Context manager that provides read and write streams for a connection.</p> <p>Yields:</p> Type Description <code>AsyncGenerator[tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage]], None]</code> <p>Tuple of (read_stream, write_stream) for bidirectional communication</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport.handle_request","title":"handle_request  <code>async</code>","text":"<pre><code>handle_request(\n    scope: Scope, receive: Receive, send: Send\n) -&gt; None\n</code></pre> <p>Application entry point that handles all HTTP requests</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport.is_terminated","title":"is_terminated  <code>property</code>","text":"<pre><code>is_terminated: bool\n</code></pre> <p>Check if this transport has been explicitly terminated.</p>"},{"location":"reference/mcp/server/streamable_http/#mcp.server.streamable_http.StreamableHTTPServerTransport.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate() -&gt; None\n</code></pre> <p>Terminate the current session, closing all streams.</p> <p>Once terminated, all requests with this session ID will receive 404 Not Found.</p>"},{"location":"reference/mcp/server/streamable_http_manager/","title":"mcp.server.streamable_http_manager","text":"<p>StreamableHTTP Session Manager for MCP servers.</p>"},{"location":"reference/mcp/server/streamable_http_manager/#mcp.server.streamable_http_manager.StreamableHTTPSessionManager","title":"StreamableHTTPSessionManager","text":"<p>Manages StreamableHTTP sessions with optional resumability via event store.</p> <p>This class abstracts away the complexity of session management, event storage, and request handling for StreamableHTTP transports. It handles:</p> <ol> <li>Session tracking for clients</li> <li>Resumability via an optional event store</li> <li>Connection management and lifecycle</li> <li>Request handling and transport setup</li> </ol> <p>Important: Only one StreamableHTTPSessionManager instance should be created per application. The instance cannot be reused after its run() context has completed. If you need to restart the manager, create a new instance.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Server[Any, Any]</code> <p>The MCP server instance</p> required <code>event_store</code> <code>EventStore | None</code> <p>Optional event store for resumability support.          If provided, enables resumable connections where clients          can reconnect and receive missed events.          If None, sessions are still tracked but not resumable.</p> <code>None</code> <code>json_response</code> <code>bool</code> <p>Whether to use JSON responses instead of SSE streams</p> <code>False</code> <code>stateless</code> <code>bool</code> <p>If True, creates a completely fresh transport for each request        with no session tracking or state persistence between requests.</p> <code>False</code>"},{"location":"reference/mcp/server/streamable_http_manager/#mcp.server.streamable_http_manager.StreamableHTTPSessionManager.handle_request","title":"handle_request  <code>async</code>","text":"<pre><code>handle_request(\n    scope: Scope, receive: Receive, send: Send\n) -&gt; None\n</code></pre> <p>Process ASGI request with proper session handling and transport setup.</p> <p>Dispatches to the appropriate handler based on stateless mode.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Scope</code> <p>ASGI scope</p> required <code>receive</code> <code>Receive</code> <p>ASGI receive function</p> required <code>send</code> <code>Send</code> <p>ASGI send function</p> required"},{"location":"reference/mcp/server/streamable_http_manager/#mcp.server.streamable_http_manager.StreamableHTTPSessionManager.run","title":"run  <code>async</code>","text":"<pre><code>run() -&gt; AsyncIterator[None]\n</code></pre> <p>Run the session manager with proper lifecycle management.</p> <p>This creates and manages the task group for all session operations.</p> <p>Important: This method can only be called once per instance. The same StreamableHTTPSessionManager instance cannot be reused after this context manager exits. Create a new instance if you need to restart.</p> <p>Use this in the lifespan context manager of your Starlette app:</p> <p>@contextlib.asynccontextmanager async def lifespan(app: Starlette) -&gt; AsyncIterator[None]:     async with session_manager.run():         yield</p>"},{"location":"reference/mcp/server/streaming_asgi_transport/","title":"mcp.server.streaming_asgi_transport","text":"<p>A modified version of httpx.ASGITransport that supports streaming responses.</p> <p>This transport runs the ASGI app as a separate anyio task, allowing it to handle streaming responses like SSE where the app doesn't terminate until the connection is closed.</p> <p>This is only intended for writing tests for the SSE transport.</p>"},{"location":"reference/mcp/server/streaming_asgi_transport/#mcp.server.streaming_asgi_transport.StreamingASGIResponseStream","title":"StreamingASGIResponseStream","text":"<p>               Bases: <code>AsyncByteStream</code></p> <p>A modified ASGIResponseStream that supports streaming responses.</p> <p>This class extends the standard ASGIResponseStream to handle cases where the response body continues to be generated after the initial response is returned.</p>"},{"location":"reference/mcp/server/streaming_asgi_transport/#mcp.server.streaming_asgi_transport.StreamingASGITransport","title":"StreamingASGITransport","text":"<p>               Bases: <code>AsyncBaseTransport</code></p> <p>A custom AsyncTransport that handles sending requests directly to an ASGI app and supports streaming responses like SSE.</p> <p>Unlike the standard ASGITransport, this transport runs the ASGI app in a separate anyio task, allowing it to handle responses from apps that don't terminate immediately (like SSE endpoints).</p> <p>Arguments:</p> <ul> <li><code>app</code> - The ASGI application.</li> <li><code>raise_app_exceptions</code> - Boolean indicating if exceptions in the application    should be raised. Default to <code>True</code>. Can be set to <code>False</code> for use cases    such as testing the content of a client 500 response.</li> <li><code>root_path</code> - The root path on which the ASGI application should be mounted.</li> <li><code>client</code> - A two-tuple indicating the client IP and port of incoming requests.</li> <li><code>response_timeout</code> - Timeout in seconds to wait for the initial response.    Default is 10 seconds.</li> </ul> <p>TODO: https://github.com/encode/httpx/pull/3059 is adding something similar to upstream httpx. When that merges, we should delete this &amp; switch back to the upstream implementation.</p>"},{"location":"reference/mcp/server/transport_security/","title":"mcp.server.transport_security","text":"<p>DNS rebinding protection for MCP server transports.</p>"},{"location":"reference/mcp/server/transport_security/#mcp.server.transport_security.TransportSecurityMiddleware","title":"TransportSecurityMiddleware","text":"<p>Middleware to enforce DNS rebinding protection for MCP transport endpoints.</p>"},{"location":"reference/mcp/server/transport_security/#mcp.server.transport_security.TransportSecurityMiddleware.validate_request","title":"validate_request  <code>async</code>","text":"<pre><code>validate_request(\n    request: Request, is_post: bool = False\n) -&gt; Response | None\n</code></pre> <p>Validate request headers for DNS rebinding protection.</p> <p>Returns None if validation passes, or an error Response if validation fails.</p>"},{"location":"reference/mcp/server/transport_security/#mcp.server.transport_security.TransportSecuritySettings","title":"TransportSecuritySettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Settings for MCP transport security features.</p> <p>These settings help protect against DNS rebinding attacks by validating incoming request headers.</p>"},{"location":"reference/mcp/server/websocket/","title":"mcp.server.websocket","text":""},{"location":"reference/mcp/server/websocket/#mcp.server.websocket.websocket_server","title":"websocket_server  <code>async</code>","text":"<pre><code>websocket_server(\n    scope: Scope, receive: Receive, send: Send\n)\n</code></pre> <p>WebSocket server transport for MCP. This is an ASGI application, suitable to be used with a framework like Starlette and a server like Hypercorn.</p>"},{"location":"reference/mcp/shared/","title":"mcp.shared","text":""},{"location":"reference/mcp/shared/auth/","title":"mcp.shared.auth","text":""},{"location":"reference/mcp/shared/auth/#mcp.shared.auth.OAuthClientInformationFull","title":"OAuthClientInformationFull","text":"<p>               Bases: <code>OAuthClientMetadata</code></p> <p>RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata).</p>"},{"location":"reference/mcp/shared/auth/#mcp.shared.auth.OAuthClientMetadata","title":"OAuthClientMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>RFC 7591 OAuth 2.0 Dynamic Client Registration metadata. See https://datatracker.ietf.org/doc/html/rfc7591#section-2 for the full specification.</p>"},{"location":"reference/mcp/shared/auth/#mcp.shared.auth.OAuthMetadata","title":"OAuthMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>RFC 8414 OAuth 2.0 Authorization Server Metadata. See https://datatracker.ietf.org/doc/html/rfc8414#section-2</p>"},{"location":"reference/mcp/shared/auth/#mcp.shared.auth.OAuthToken","title":"OAuthToken","text":"<p>               Bases: <code>BaseModel</code></p> <p>See https://datatracker.ietf.org/doc/html/rfc6749#section-5.1</p>"},{"location":"reference/mcp/shared/auth/#mcp.shared.auth.ProtectedResourceMetadata","title":"ProtectedResourceMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>RFC 9728 OAuth 2.0 Protected Resource Metadata. See https://datatracker.ietf.org/doc/html/rfc9728#section-2</p>"},{"location":"reference/mcp/shared/auth_utils/","title":"mcp.shared.auth_utils","text":"<p>Utilities for OAuth 2.0 Resource Indicators (RFC 8707).</p>"},{"location":"reference/mcp/shared/auth_utils/#mcp.shared.auth_utils.check_resource_allowed","title":"check_resource_allowed","text":"<pre><code>check_resource_allowed(\n    requested_resource: str, configured_resource: str\n) -&gt; bool\n</code></pre> <p>Check if a requested resource URL matches a configured resource URL.</p> <p>A requested resource matches if it has the same scheme, domain, port, and its path starts with the configured resource's path. This allows hierarchical matching where a token for a parent resource can be used for child resources.</p> <p>Parameters:</p> Name Type Description Default <code>requested_resource</code> <code>str</code> <p>The resource URL being requested</p> required <code>configured_resource</code> <code>str</code> <p>The resource URL that has been configured</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the requested resource matches the configured resource</p>"},{"location":"reference/mcp/shared/auth_utils/#mcp.shared.auth_utils.resource_url_from_server_url","title":"resource_url_from_server_url","text":"<pre><code>resource_url_from_server_url(\n    url: str | HttpUrl | AnyUrl,\n) -&gt; str\n</code></pre> <p>Convert server URL to canonical resource URL per RFC 8707.</p> <p>RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\". Returns absolute URI with lowercase scheme/host for canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | HttpUrl | AnyUrl</code> <p>Server URL to convert</p> required <p>Returns:</p> Type Description <code>str</code> <p>Canonical resource URL string</p>"},{"location":"reference/mcp/shared/context/","title":"mcp.shared.context","text":""},{"location":"reference/mcp/shared/context/#mcp.shared.context.RequestContext","title":"RequestContext  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[SessionT, LifespanContextT, RequestT]</code></p> <p>Context object containing information about the current MCP request.</p> <p>This is the fundamental context object in the MCP Python SDK that provides access to request-scoped information and capabilities. It's created automatically for each incoming client request and contains everything needed to process that request, including the session for client communication, request metadata, and any resources initialized during server startup.</p> <p>The RequestContext is available throughout the request lifecycle and provides the foundation for both low-level and high-level SDK usage patterns. In the low-level SDK, you access it via <code>Server.request_context</code>. In FastMCP, it's wrapped by the more convenient <code>Context</code>  class that provides the same functionality with additional helper methods.</p>"},{"location":"reference/mcp/shared/context/#mcp.shared.context.RequestContext--request-lifecycle","title":"Request lifecycle","text":"<p>The RequestContext is created when a client request arrives and destroyed when the request completes. It's only available during request processing - attempting to access it outside of a request handler will raise a <code>LookupError</code>.</p>"},{"location":"reference/mcp/shared/context/#mcp.shared.context.RequestContext--access-patterns","title":"Access patterns","text":"<p>Low-level SDK: Access directly via the server's request_context property:</p> <pre><code>@app.call_tool()\nasync def my_tool(name: str, arguments: dict[str, Any]) -&gt; list[types.ContentBlock]:\n    ctx = app.request_context  # Get the RequestContext\n    await ctx.session.send_log_message(level=\"info\", data=\"Processing...\")\n</code></pre> <p>FastMCP: Use the injected Context wrapper instead:</p> <pre><code>@mcp.tool()\nasync def my_tool(data: str, ctx: Context) -&gt; str:\n    await ctx.info(\"Processing...\")  # Context provides convenience methods\n</code></pre>"},{"location":"reference/mcp/shared/context/#mcp.shared.context.RequestContext--lifespan-context-integration","title":"Lifespan context integration","text":"<p>Resources initialized during server startup (databases, connections, etc.) are accessible through the <code>lifespan_context</code> attribute, enabling request handlers to use shared resources safely:</p> <pre><code># Server startup - initialize shared resources\n@asynccontextmanager\nasync def server_lifespan(server):\n    db = await Database.connect()\n    try:\n        yield {\"db\": db}\n    finally:\n        await db.disconnect()\n\n# Request handling - access shared resources\n@server.call_tool()  \nasync def query_data(name: str, arguments: dict[str, Any]):\n    ctx = server.request_context\n    db = ctx.lifespan_context[\"db\"]  # Access startup resource\n    results = await db.query(arguments[\"query\"])\n</code></pre> <p>Attributes:</p> Name Type Description <code>request_id</code> <code>RequestId</code> <p>Unique identifier for the current request as a <code>RequestId</code>. Use this for logging, tracing, or linking related operations.</p> <code>meta</code> <code>Meta | None</code> <p>Optional request metadata including progress tokens and other client-provided information. May be <code>None</code> if no metadata was provided.</p> <code>session</code> <code>SessionT</code> <p>The <code>ServerSession</code> for communicating with the client. Use this to send responses, log messages, or check capabilities.</p> <code>lifespan_context</code> <code>LifespanContextT</code> <p>Application-specific resources initialized during server startup. Contains any objects yielded by the server's lifespan function.</p> <code>request</code> <code>RequestT | None</code> <p>The original request object from the client, if available. May be <code>None</code> for some request types.</p> Note <p>This object is request-scoped and thread-safe within that scope. Each request gets its own RequestContext instance. Don't store references to it beyond the request lifecycle, as it becomes invalid when the request completes.</p>"},{"location":"reference/mcp/shared/exceptions/","title":"mcp.shared.exceptions","text":""},{"location":"reference/mcp/shared/exceptions/#mcp.shared.exceptions.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an MCP protocol error is received from a peer.</p> <p>This exception is raised when the remote MCP peer returns an error response instead of a successful result. It wraps the ErrorData received from the peer and provides access to the error code, message, and any additional data.</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>ErrorData</code> <p>The ErrorData object received from the MCP peer containing    error code, message, and optional additional data</p>"},{"location":"reference/mcp/shared/exceptions/#mcp.shared.exceptions.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError with error data from the MCP peer.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>ErrorData</code> <p>ErrorData object containing the error details from the peer</p> required"},{"location":"reference/mcp/shared/memory/","title":"mcp.shared.memory","text":"<p>In-memory transports</p>"},{"location":"reference/mcp/shared/memory/#mcp.shared.memory.create_client_server_memory_streams","title":"create_client_server_memory_streams  <code>async</code>","text":"<pre><code>create_client_server_memory_streams() -&gt; (\n    AsyncGenerator[\n        tuple[MessageStream, MessageStream], None\n    ]\n)\n</code></pre> <p>Creates a pair of bidirectional memory streams for client-server communication.</p> <p>Returns:</p> Type Description <code>AsyncGenerator[tuple[MessageStream, MessageStream], None]</code> <p>A tuple of (client_streams, server_streams) where each is a tuple of</p> <code>AsyncGenerator[tuple[MessageStream, MessageStream], None]</code> <p>(read_stream, write_stream)</p>"},{"location":"reference/mcp/shared/memory/#mcp.shared.memory.create_connected_server_and_client_session","title":"create_connected_server_and_client_session  <code>async</code>","text":"<pre><code>create_connected_server_and_client_session(\n    server: Server[Any],\n    read_timeout_seconds: timedelta | None = None,\n    sampling_callback: SamplingFnT | None = None,\n    list_roots_callback: ListRootsFnT | None = None,\n    logging_callback: LoggingFnT | None = None,\n    message_handler: MessageHandlerFnT | None = None,\n    client_info: Implementation | None = None,\n    raise_exceptions: bool = False,\n    elicitation_callback: ElicitationFnT | None = None,\n) -&gt; AsyncGenerator[ClientSession, None]\n</code></pre> <p>Creates a ClientSession that is connected to a running MCP server.</p>"},{"location":"reference/mcp/shared/message/","title":"mcp.shared.message","text":"<p>Message wrapper with metadata support.</p> <p>This module defines a wrapper type that combines JSONRPCMessage with metadata to support transport-specific features like resumability.</p>"},{"location":"reference/mcp/shared/message/#mcp.shared.message.ClientMessageMetadata","title":"ClientMessageMetadata  <code>dataclass</code>","text":"<p>Metadata specific to client messages.</p>"},{"location":"reference/mcp/shared/message/#mcp.shared.message.ServerMessageMetadata","title":"ServerMessageMetadata  <code>dataclass</code>","text":"<p>Metadata specific to server messages.</p>"},{"location":"reference/mcp/shared/message/#mcp.shared.message.SessionMessage","title":"SessionMessage  <code>dataclass</code>","text":"<p>A message with specific metadata for transport-specific features.</p>"},{"location":"reference/mcp/shared/metadata_utils/","title":"mcp.shared.metadata_utils","text":"<p>Utility functions for working with metadata in MCP types.</p> <p>These utilities are primarily intended for client-side usage to properly display human-readable names in user interfaces in a spec compliant way.</p>"},{"location":"reference/mcp/shared/metadata_utils/#mcp.shared.metadata_utils.get_display_name","title":"get_display_name","text":"<pre><code>get_display_name(\n    obj: (\n        Tool\n        | Resource\n        | Prompt\n        | ResourceTemplate\n        | Implementation\n    ),\n) -&gt; str\n</code></pre> <p>Get the display name for an MCP object with proper precedence.</p> <p>This is a client-side utility function designed to help MCP clients display human-readable names in their user interfaces. When servers provide a 'title' field, it should be preferred over the programmatic 'name' field for display.</p> <p>For tools: title &gt; annotations.title &gt; name For other objects: title &gt; name</p> Example <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Tool | Resource | Prompt | ResourceTemplate | Implementation</code> <p>An MCP object with name and optional title fields</p> required <p>Returns:</p> Type Description <code>str</code> <p>The display name to use for UI presentation</p>"},{"location":"reference/mcp/shared/metadata_utils/#mcp.shared.metadata_utils.get_display_name--in-a-client-displaying-available-tools","title":"In a client displaying available tools","text":"<p>tools = await session.list_tools() for tool in tools.tools:     display_name = get_display_name(tool)     print(f\"Available tool: {display_name}\")</p>"},{"location":"reference/mcp/shared/progress/","title":"mcp.shared.progress","text":""},{"location":"reference/mcp/shared/session/","title":"mcp.shared.session","text":""},{"location":"reference/mcp/shared/session/#mcp.shared.session.BaseSession","title":"BaseSession","text":"<p>               Bases: <code>Generic[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT]</code></p> <p>Implements an MCP \"session\" on top of read/write streams, including features like request/response linking, notifications, and progress.</p> <p>This class is an async context manager that automatically starts processing messages when entered.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.BaseSession.send_notification","title":"send_notification  <code>async</code>","text":"<pre><code>send_notification(\n    notification: SendNotificationT,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Emits a notification, which is a one-way message that does not expect a response.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.BaseSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Sends a progress notification for a request that is currently being processed.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.BaseSession.send_request","title":"send_request  <code>async</code>","text":"<pre><code>send_request(\n    request: SendRequestT,\n    result_type: type[ReceiveResultT],\n    request_read_timeout_seconds: timedelta | None = None,\n    metadata: MessageMetadata = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; ReceiveResultT\n</code></pre> <p>Sends a request and wait for a response. Raises an McpError if the response contains an error. If a request read timeout is provided, it will take precedence over the session read timeout.</p> <p>Do not use this method to emit notifications! Use send_notification() instead.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.ProgressFnT","title":"ProgressFnT","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for progress notification callbacks.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.RequestResponder","title":"RequestResponder","text":"<p>               Bases: <code>Generic[ReceiveRequestT, SendResultT]</code></p> <p>Handles responding to MCP requests and manages request lifecycle.</p> <p>This class MUST be used as a context manager to ensure proper cleanup and cancellation handling:</p> Example <p>with request_responder as resp:     await resp.respond(result)</p> <p>The context manager ensures: 1. Proper cancellation scope setup and cleanup 2. Request completion tracking 3. Cleanup of in-flight requests</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.RequestResponder.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; (\n    RequestResponder[ReceiveRequestT, SendResultT]\n)\n</code></pre> <p>Enter the context manager, enabling request cancellation tracking.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.RequestResponder.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit the context manager, performing cleanup and notifying completion.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.RequestResponder.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel() -&gt; None\n</code></pre> <p>Cancel this request and mark it as completed.</p>"},{"location":"reference/mcp/shared/session/#mcp.shared.session.RequestResponder.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(response: SendResultT | ErrorData) -&gt; None\n</code></pre> <p>Send a response for this request.</p> <p>Must be called within a context manager block. Raises:     RuntimeError: If not used within a context manager     AssertionError: If request was already responded to</p>"},{"location":"reference/mcp/shared/version/","title":"mcp.shared.version","text":""},{"location":"reference/mcp/types/","title":"mcp.types","text":""},{"location":"reference/mcp/types/#mcp.types.AudioContent","title":"AudioContent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio content for a message.</p>"},{"location":"reference/mcp/types/#mcp.types.AudioContent.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: str\n</code></pre> <p>The base64-encoded audio data.</p>"},{"location":"reference/mcp/types/#mcp.types.AudioContent.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.AudioContent.mimeType","title":"mimeType  <code>instance-attribute</code>","text":"<pre><code>mimeType: str\n</code></pre> <p>The MIME type of the audio. Different providers may support different audio types.</p>"},{"location":"reference/mcp/types/#mcp.types.BaseMetadata","title":"BaseMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for entities with name and optional title fields.</p>"},{"location":"reference/mcp/types/#mcp.types.BaseMetadata.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The programmatic name of the entity.</p>"},{"location":"reference/mcp/types/#mcp.types.BaseMetadata.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None = None\n</code></pre> <p>Intended for UI and end-user contexts \u2014 optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.</p> <p>If not provided, the name should be used for display (except for Tool, where <code>annotations.title</code> should be given precedence over using <code>name</code>, if present).</p>"},{"location":"reference/mcp/types/#mcp.types.BlobResourceContents","title":"BlobResourceContents","text":"<p>               Bases: <code>ResourceContents</code></p> <p>Binary contents of a resource.</p>"},{"location":"reference/mcp/types/#mcp.types.BlobResourceContents.blob","title":"blob  <code>instance-attribute</code>","text":"<pre><code>blob: str\n</code></pre> <p>A base64-encoded string representing the binary data of the item.</p>"},{"location":"reference/mcp/types/#mcp.types.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p>"},{"location":"reference/mcp/types/#mcp.types.CallToolRequestParams","title":"CallToolRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for calling a tool.</p>"},{"location":"reference/mcp/types/#mcp.types.CallToolResult","title":"CallToolResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a tool call.</p>"},{"location":"reference/mcp/types/#mcp.types.CallToolResult.structuredContent","title":"structuredContent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>structuredContent: dict[str, Any] | None = None\n</code></pre> <p>An optional JSON object that represents the structured result of the tool call.</p>"},{"location":"reference/mcp/types/#mcp.types.CancelledNotification","title":"CancelledNotification","text":"<p>               Bases: <code>Notification[CancelledNotificationParams, Literal['notifications/cancelled']]</code></p> <p>This notification can be sent by either side to indicate that it is canceling a previously-issued request.</p>"},{"location":"reference/mcp/types/#mcp.types.CancelledNotificationParams","title":"CancelledNotificationParams","text":"<p>               Bases: <code>NotificationParams</code></p> <p>Parameters for cancellation notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.CancelledNotificationParams.reason","title":"reason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reason: str | None = None\n</code></pre> <p>An optional string describing the reason for the cancellation.</p>"},{"location":"reference/mcp/types/#mcp.types.CancelledNotificationParams.requestId","title":"requestId  <code>instance-attribute</code>","text":"<pre><code>requestId: RequestId\n</code></pre> <p>The ID of the request to cancel.</p>"},{"location":"reference/mcp/types/#mcp.types.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p>"},{"location":"reference/mcp/types/#mcp.types.ClientCapabilities.elicitation","title":"elicitation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elicitation: ElicitationCapability | None = None\n</code></pre> <p>Present if the client supports elicitation from the user.</p>"},{"location":"reference/mcp/types/#mcp.types.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"reference/mcp/types/#mcp.types.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"reference/mcp/types/#mcp.types.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM.</p>"},{"location":"reference/mcp/types/#mcp.types.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p>"},{"location":"reference/mcp/types/#mcp.types.CompleteRequestParams","title":"CompleteRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for completion requests.</p>"},{"location":"reference/mcp/types/#mcp.types.CompleteRequestParams.context","title":"context  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context: CompletionContext | None = None\n</code></pre> <p>Additional, optional context for completions</p>"},{"location":"reference/mcp/types/#mcp.types.CompleteResult","title":"CompleteResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a completion/complete request</p>"},{"location":"reference/mcp/types/#mcp.types.Completion","title":"Completion","text":"<p>               Bases: <code>BaseModel</code></p> <p>Completion information.</p>"},{"location":"reference/mcp/types/#mcp.types.Completion.hasMore","title":"hasMore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hasMore: bool | None = None\n</code></pre> <p>Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.</p>"},{"location":"reference/mcp/types/#mcp.types.Completion.total","title":"total  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total: int | None = None\n</code></pre> <p>The total number of completion options available. This can exceed the number of values actually sent in the response.</p>"},{"location":"reference/mcp/types/#mcp.types.Completion.values","title":"values  <code>instance-attribute</code>","text":"<pre><code>values: list[str]\n</code></pre> <p>An array of completion values. Must not exceed 100 items.</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionArgument","title":"CompletionArgument","text":"<p>               Bases: <code>BaseModel</code></p> <p>The argument's information for completion requests.</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionArgument.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the argument</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionArgument.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>The value of the argument to use for completion matching.</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionContext","title":"CompletionContext","text":"<p>               Bases: <code>BaseModel</code></p> <p>Additional, optional context for completions.</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionContext.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: dict[str, str] | None = None\n</code></pre> <p>Previously-resolved variables in a URI template or prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.CompletionsCapability","title":"CompletionsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for completions operations.</p>"},{"location":"reference/mcp/types/#mcp.types.ContentBlock","title":"ContentBlock  <code>module-attribute</code>","text":"<pre><code>ContentBlock = (\n    TextContent\n    | ImageContent\n    | AudioContent\n    | ResourceLink\n    | EmbeddedResource\n)\n</code></pre> <p>A content block that can be used in prompts and tool results.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams","title":"CreateMessageRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for creating a message.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams.includeContext","title":"includeContext  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>includeContext: IncludeContext | None = None\n</code></pre> <p>A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams.maxTokens","title":"maxTokens  <code>instance-attribute</code>","text":"<pre><code>maxTokens: int\n</code></pre> <p>The maximum number of tokens to sample, as requested by the server.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any] | None = None\n</code></pre> <p>Optional metadata to pass through to the LLM provider.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams.modelPreferences","title":"modelPreferences  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>modelPreferences: ModelPreferences | None = None\n</code></pre> <p>The server's preferences for which model to select. The client MAY ignore these preferences.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageRequestParams.systemPrompt","title":"systemPrompt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>systemPrompt: str | None = None\n</code></pre> <p>An optional system prompt the server wants to use for sampling.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"reference/mcp/types/#mcp.types.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitRequest","title":"ElicitRequest","text":"<p>               Bases: <code>Request[ElicitRequestParams, Literal['elicitation/create']]</code></p> <p>A request from the server to elicit information from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitRequestParams","title":"ElicitRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for elicitation requests.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitRequestedSchema","title":"ElicitRequestedSchema  <code>module-attribute</code>","text":"<pre><code>ElicitRequestedSchema: TypeAlias = dict[str, Any]\n</code></pre> <p>Schema for elicitation requests.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitResult","title":"ElicitResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to an elicitation request.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitResult.action","title":"action  <code>instance-attribute</code>","text":"<pre><code>action: Literal['accept', 'decline', 'cancel']\n</code></pre> <p>The user action in response to the elicitation. - \"accept\": User submitted the form/confirmed the action - \"decline\": User explicitly declined the action - \"cancel\": User dismissed without making an explicit choice</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitResult.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content: (\n    dict[str, str | int | float | bool | None] | None\n) = None\n</code></pre> <p>The submitted form data, only present when action is \"accept\". Contains values matching the requested schema.</p>"},{"location":"reference/mcp/types/#mcp.types.ElicitationCapability","title":"ElicitationCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for elicitation operations.</p>"},{"location":"reference/mcp/types/#mcp.types.EmbeddedResource","title":"EmbeddedResource","text":"<p>               Bases: <code>BaseModel</code></p> <p>The contents of a resource, embedded into a prompt or tool call result.</p> <p>It is up to the client how best to render embedded resources for the benefit of the LLM and/or the user.</p>"},{"location":"reference/mcp/types/#mcp.types.EmbeddedResource.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.EmptyResult","title":"EmptyResult","text":"<p>               Bases: <code>Result</code></p> <p>A response that indicates success but carries no data.</p>"},{"location":"reference/mcp/types/#mcp.types.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p>"},{"location":"reference/mcp/types/#mcp.types.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"reference/mcp/types/#mcp.types.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"reference/mcp/types/#mcp.types.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptRequestParams","title":"GetPromptRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for getting a prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptRequestParams.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: dict[str, str] | None = None\n</code></pre> <p>Arguments to use for templating the prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptRequestParams.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the prompt or prompt template.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.ImageContent","title":"ImageContent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Image content for a message.</p>"},{"location":"reference/mcp/types/#mcp.types.ImageContent.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: str\n</code></pre> <p>The base64-encoded image data.</p>"},{"location":"reference/mcp/types/#mcp.types.ImageContent.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.ImageContent.mimeType","title":"mimeType  <code>instance-attribute</code>","text":"<pre><code>mimeType: str\n</code></pre> <p>The MIME type of the image. Different providers may support different image types.</p>"},{"location":"reference/mcp/types/#mcp.types.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Describes the name and version of an MCP implementation.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeRequestParams","title":"InitializeRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for the initialize request.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeRequestParams.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The latest version of the Model Context Protocol that the client supports.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"reference/mcp/types/#mcp.types.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p>"},{"location":"reference/mcp/types/#mcp.types.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p>"},{"location":"reference/mcp/types/#mcp.types.JSONRPCNotification","title":"JSONRPCNotification","text":"<p>               Bases: <code>Notification[dict[str, Any] | None, str]</code></p> <p>A notification which does not expect a response.</p>"},{"location":"reference/mcp/types/#mcp.types.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p>"},{"location":"reference/mcp/types/#mcp.types.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p>"},{"location":"reference/mcp/types/#mcp.types.LATEST_PROTOCOL_VERSION","title":"LATEST_PROTOCOL_VERSION  <code>module-attribute</code>","text":"<pre><code>LATEST_PROTOCOL_VERSION = '2025-06-18'\n</code></pre> <p>The default negotiated version of the Model Context Protocol when no version is specified. We need this to satisfy the MCP specification, which requires the server to assume a specific version if none is provided by the client. See section \"Protocol Version Header\" at https://modelcontextprotocol.io/specification</p>"},{"location":"reference/mcp/types/#mcp.types.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p>"},{"location":"reference/mcp/types/#mcp.types.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.ListResourceTemplatesRequest","title":"ListResourceTemplatesRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['resources/templates/list']]</code></p> <p>Sent from the client to request a list of resource templates the server has.</p>"},{"location":"reference/mcp/types/#mcp.types.ListResourceTemplatesResult","title":"ListResourceTemplatesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/templates/list request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p>"},{"location":"reference/mcp/types/#mcp.types.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.ListRootsRequest","title":"ListRootsRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['roots/list']]</code></p> <p>Sent from the server to request a list of root URIs from the client. Roots allow servers to ask for specific directories or files to operate on. A common example for roots is providing a set of repositories or directories a server should operate on.</p> <p>This request is typically used when the server needs to understand the file system structure or access specific locations that the client has permission to read from.</p>"},{"location":"reference/mcp/types/#mcp.types.ListRootsResult","title":"ListRootsResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a roots/list request from the server. This result contains an array of Root objects, each representing a root directory or file that the server can operate on.</p>"},{"location":"reference/mcp/types/#mcp.types.ListToolsRequest","title":"ListToolsRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['tools/list']]</code></p> <p>Sent from the client to request a list of tools the server has.</p>"},{"location":"reference/mcp/types/#mcp.types.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingCapability","title":"LoggingCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for logging operations.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingMessageNotificationParams","title":"LoggingMessageNotificationParams","text":"<p>               Bases: <code>NotificationParams</code></p> <p>Parameters for logging message notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingMessageNotificationParams.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: Any\n</code></pre> <p>The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingMessageNotificationParams.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: LoggingLevel\n</code></pre> <p>The severity of this log message.</p>"},{"location":"reference/mcp/types/#mcp.types.LoggingMessageNotificationParams.logger","title":"logger  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logger: str | None = None\n</code></pre> <p>An optional name of the logger issuing this message.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelHint","title":"ModelHint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Hints to use for model selection.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelHint.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>A hint for a model name.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelPreferences","title":"ModelPreferences","text":"<p>               Bases: <code>BaseModel</code></p> <p>The server's preferences for model selection, requested by the client during sampling.</p> <p>Because LLMs can vary along multiple dimensions, choosing the \"best\" model is rarely straightforward.  Different models excel in different areas\u2014some are faster but less capable, others are more capable but more expensive, and so on. This interface allows servers to express their priorities across multiple dimensions to help clients make an appropriate selection for their use case.</p> <p>These preferences are always advisory. The client MAY ignore them. It is also up to the client to decide how to interpret these preferences and how to balance them against other considerations.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelPreferences.costPriority","title":"costPriority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>costPriority: float | None = None\n</code></pre> <p>How much to prioritize cost when selecting a model. A value of 0 means cost is not important, while a value of 1 means cost is the most important factor.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelPreferences.hints","title":"hints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hints: list[ModelHint] | None = None\n</code></pre> <p>Optional hints to use for model selection.</p> <p>If multiple hints are specified, the client MUST evaluate them in order (such that the first match is taken).</p> <p>The client SHOULD prioritize these hints over the numeric priorities, but MAY still use the priorities to select from ambiguous matches.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelPreferences.intelligencePriority","title":"intelligencePriority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>intelligencePriority: float | None = None\n</code></pre> <p>How much to prioritize intelligence and capabilities when selecting a model. A value of 0 means intelligence is not important, while a value of 1 means intelligence is the most important factor.</p>"},{"location":"reference/mcp/types/#mcp.types.ModelPreferences.speedPriority","title":"speedPriority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>speedPriority: float | None = None\n</code></pre> <p>How much to prioritize sampling speed (latency) when selecting a model. A value of 0 means speed is not important, while a value of 1 means speed is the most important factor.</p>"},{"location":"reference/mcp/types/#mcp.types.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.NotificationParams","title":"NotificationParams","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/types/#mcp.types.NotificationParams.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: Meta | None = Field(alias='_meta', default=None)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.PaginatedRequest","title":"PaginatedRequest","text":"<p>               Bases: <code>Request[PaginatedRequestParams | None, MethodT]</code>, <code>Generic[MethodT]</code></p> <p>Base class for paginated requests, matching the schema's PaginatedRequest interface.</p>"},{"location":"reference/mcp/types/#mcp.types.PaginatedRequestParams","title":"PaginatedRequestParams","text":"<p>               Bases: <code>RequestParams</code></p>"},{"location":"reference/mcp/types/#mcp.types.PaginatedRequestParams.cursor","title":"cursor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cursor: Cursor | None = None\n</code></pre> <p>An opaque token representing the current pagination position. If provided, the server should return results starting after this cursor.</p>"},{"location":"reference/mcp/types/#mcp.types.PaginatedResult","title":"PaginatedResult","text":"<p>               Bases: <code>Result</code></p>"},{"location":"reference/mcp/types/#mcp.types.PaginatedResult.nextCursor","title":"nextCursor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nextCursor: Cursor | None = None\n</code></pre> <p>An opaque token representing the pagination position after the last returned result. If present, there may be more results available.</p>"},{"location":"reference/mcp/types/#mcp.types.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotificationParams","title":"ProgressNotificationParams","text":"<p>               Bases: <code>NotificationParams</code></p> <p>Parameters for progress notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotificationParams.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre> <p>Message related to progress. This should provide relevant human readable progress information.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotificationParams.progress","title":"progress  <code>instance-attribute</code>","text":"<pre><code>progress: float\n</code></pre> <p>The progress thus far. This should increase every time progress is made, even if the total is unknown.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotificationParams.progressToken","title":"progressToken  <code>instance-attribute</code>","text":"<pre><code>progressToken: ProgressToken\n</code></pre> <p>The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.</p>"},{"location":"reference/mcp/types/#mcp.types.ProgressNotificationParams.total","title":"total  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total: float | None = None\n</code></pre> <p>Total number of items to process (or total progress required), if known.</p>"},{"location":"reference/mcp/types/#mcp.types.Prompt","title":"Prompt","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A prompt or prompt template that the server offers.</p>"},{"location":"reference/mcp/types/#mcp.types.Prompt.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: list[PromptArgument] | None = None\n</code></pre> <p>A list of arguments to use for templating the prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.Prompt.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description of what this prompt provides.</p>"},{"location":"reference/mcp/types/#mcp.types.Prompt.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptArgument","title":"PromptArgument","text":"<p>               Bases: <code>BaseModel</code></p> <p>An argument for a prompt template.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptArgument.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the argument.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptArgument.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the argument.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptArgument.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool | None = None\n</code></pre> <p>Whether this argument must be provided.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptListChangedNotification","title":"PromptListChangedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/prompts/list_changed']]</code></p> <p>An optional notification from the server to the client, informing it that the list of prompts it offers has changed.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptMessage","title":"PromptMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a message returned as part of a prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptReference","title":"PromptReference","text":"<p>               Bases: <code>BaseModel</code></p> <p>Identifies a prompt.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptReference.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the prompt or prompt template</p>"},{"location":"reference/mcp/types/#mcp.types.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p>"},{"location":"reference/mcp/types/#mcp.types.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"reference/mcp/types/#mcp.types.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p>"},{"location":"reference/mcp/types/#mcp.types.ReadResourceRequestParams","title":"ReadResourceRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for reading a resource.</p>"},{"location":"reference/mcp/types/#mcp.types.ReadResourceRequestParams.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.</p>"},{"location":"reference/mcp/types/#mcp.types.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p>"},{"location":"reference/mcp/types/#mcp.types.Request","title":"Request","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[RequestParamsT, MethodT]</code></p> <p>Base class for JSON-RPC requests.</p>"},{"location":"reference/mcp/types/#mcp.types.RequestParams","title":"RequestParams","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/types/#mcp.types.RequestParams.Meta","title":"Meta","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/mcp/types/#mcp.types.RequestParams.Meta.progressToken","title":"progressToken  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>progressToken: ProgressToken | None = None\n</code></pre> <p>If specified, the caller requests out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource","title":"Resource","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A known resource that the server is capable of reading.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"reference/mcp/types/#mcp.types.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceContents","title":"ResourceContents","text":"<p>               Bases: <code>BaseModel</code></p> <p>The contents of a specific resource or sub-resource.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceContents.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceContents.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceContents.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceLink","title":"ResourceLink","text":"<p>               Bases: <code>Resource</code></p> <p>A resource that the server is capable of reading, included in a prompt or tool call result.</p> <p>Note: resource links returned by tools are not guaranteed to appear in the results of <code>resources/list</code> requests.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceListChangedNotification","title":"ResourceListChangedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/resources/list_changed']]</code></p> <p>An optional notification from the server to the client, informing it that the list of resources it can read from has changed.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplate","title":"ResourceTemplate","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A template description for resources available on the server.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplate.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of what this template is for.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplate.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplate.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplate.uriTemplate","title":"uriTemplate  <code>instance-attribute</code>","text":"<pre><code>uriTemplate: str\n</code></pre> <p>A URI template (according to RFC 6570) that can be used to construct resource URIs.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplateReference","title":"ResourceTemplateReference","text":"<p>               Bases: <code>BaseModel</code></p> <p>A reference to a resource or resource template definition.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceTemplateReference.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: str\n</code></pre> <p>The URI or URI template of the resource.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceUpdatedNotificationParams","title":"ResourceUpdatedNotificationParams","text":"<p>               Bases: <code>NotificationParams</code></p> <p>Parameters for resource update notifications.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourceUpdatedNotificationParams.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"reference/mcp/types/#mcp.types.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"reference/mcp/types/#mcp.types.Result","title":"Result","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for JSON-RPC results.</p>"},{"location":"reference/mcp/types/#mcp.types.Result.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.Root","title":"Root","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a root directory or file that the server can operate on.</p>"},{"location":"reference/mcp/types/#mcp.types.Root.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.Root.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>An optional name for the root. This can be used to provide a human-readable identifier for the root, which may be useful for display purposes or for referencing the root in other parts of the application.</p>"},{"location":"reference/mcp/types/#mcp.types.Root.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: FileUrl\n</code></pre> <p>The URI identifying the root. This must start with file:// for now. This restriction may be relaxed in future versions of the protocol to allow other URI schemes.</p>"},{"location":"reference/mcp/types/#mcp.types.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p>"},{"location":"reference/mcp/types/#mcp.types.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"reference/mcp/types/#mcp.types.RootsListChangedNotification","title":"RootsListChangedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/roots/list_changed']]</code></p> <p>A notification from the client to the server, informing it that the list of roots has changed.</p> <p>This notification should be sent whenever the client adds, removes, or modifies any root. The server should then request an updated list of roots using the ListRootsRequest.</p>"},{"location":"reference/mcp/types/#mcp.types.SamplingCapability","title":"SamplingCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for sampling operations.</p>"},{"location":"reference/mcp/types/#mcp.types.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a message in an LLM conversation for sampling/generation requests.</p> <p>SamplingMessage is used to structure conversation history when requesting LLM text generation through the MCP sampling protocol. Each message represents a single turn in the conversation with a specific role and content.</p> <p>This class is primarily used with <code>ServerSession.create_message</code> to send conversation context to LLMs via MCP clients. The message format follows standard LLM conversation patterns with distinct roles for users and assistants.</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>Role</code> <p>The speaker role, either \"user\" for human input or \"assistant\" for AI responses.</p> <code>content</code> <code>TextContent | ImageContent | AudioContent</code> <p>The message content, which can be <code>TextContent</code>,  <code>ImageContent</code>, or <code>AudioContent</code>.</p> <p>Examples:</p> <p>Creating a simple text message:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nuser_msg = SamplingMessage(\n    role=\"user\",\n    content=TextContent(type=\"text\", text=\"Hello, how are you?\")\n)\n</code></pre> <p>Creating an assistant response:</p> <pre><code>assistant_msg = SamplingMessage(\n    role=\"assistant\",\n    content=TextContent(type=\"text\", text=\"I'm doing well, thank you!\")\n)\n</code></pre> <p>Creating a message with image content:</p> <pre><code>import base64\n\n# Assuming you have image_bytes containing image data\nimage_data = base64.b64encode(image_bytes).decode()\n\nimage_msg = SamplingMessage(\n    role=\"user\",\n    content=ImageContent(\n        type=\"image\",\n        data=image_data,\n        mimeType=\"image/jpeg\"\n    )\n)\n</code></pre> <p>Building a conversation history:</p> <pre><code>conversation = [\n    SamplingMessage(\n        role=\"user\",\n        content=TextContent(type=\"text\", text=\"What's 2+2?\")\n    ),\n    SamplingMessage(\n        role=\"assistant\",\n        content=TextContent(type=\"text\", text=\"2+2 equals 4.\")\n    ),\n    SamplingMessage(\n        role=\"user\", \n        content=TextContent(type=\"text\", text=\"Now what's 4+4?\")\n    )\n]\n\n# Use in create_message call  \nresult = await session.create_message(\n    messages=conversation,\n    max_tokens=50\n)\n</code></pre> Note <p>The role field is constrained to \"user\" or \"assistant\" only. The content supports multiple media types, but actual support depends on the LLM provider and client implementation.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.completions","title":"completions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completions: CompletionsCapability | None = None\n</code></pre> <p>Present if the server offers autocompletion suggestions for prompts and resources.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"reference/mcp/types/#mcp.types.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"reference/mcp/types/#mcp.types.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p>"},{"location":"reference/mcp/types/#mcp.types.SetLevelRequestParams","title":"SetLevelRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for setting the logging level.</p>"},{"location":"reference/mcp/types/#mcp.types.SetLevelRequestParams.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: LoggingLevel\n</code></pre> <p>The level of logging that the client wants to receive from the server.</p>"},{"location":"reference/mcp/types/#mcp.types.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p>"},{"location":"reference/mcp/types/#mcp.types.SubscribeRequestParams","title":"SubscribeRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for subscribing to a resource.</p>"},{"location":"reference/mcp/types/#mcp.types.SubscribeRequestParams.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.</p>"},{"location":"reference/mcp/types/#mcp.types.TextContent","title":"TextContent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Text content for a message.</p>"},{"location":"reference/mcp/types/#mcp.types.TextContent.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.TextContent.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: str\n</code></pre> <p>The text content of the message.</p>"},{"location":"reference/mcp/types/#mcp.types.TextResourceContents","title":"TextResourceContents","text":"<p>               Bases: <code>ResourceContents</code></p> <p>Text contents of a resource.</p>"},{"location":"reference/mcp/types/#mcp.types.TextResourceContents.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: str\n</code></pre> <p>The text of the item. This must only be set if the item can actually be represented as text (not binary data).</p>"},{"location":"reference/mcp/types/#mcp.types.Tool","title":"Tool","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Definition for a tool the client can call.</p>"},{"location":"reference/mcp/types/#mcp.types.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"reference/mcp/types/#mcp.types.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"reference/mcp/types/#mcp.types.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"reference/mcp/types/#mcp.types.Tool.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"reference/mcp/types/#mcp.types.Tool.outputSchema","title":"outputSchema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputSchema: dict[str, Any] | None = None\n</code></pre> <p>An optional JSON Schema object defining the structure of the tool's output returned in the structuredContent field of a CallToolResult.</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations","title":"ToolAnnotations","text":"<p>               Bases: <code>BaseModel</code></p> <p>Additional properties describing a Tool to clients.</p> <p>NOTE: all properties in ToolAnnotations are hints. They are not guaranteed to provide a faithful description of tool behavior (including descriptive properties like <code>title</code>).</p> <p>Clients should never make tool use decisions based on ToolAnnotations received from untrusted servers.</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations.destructiveHint","title":"destructiveHint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>destructiveHint: bool | None = None\n</code></pre> <p>If true, the tool may perform destructive updates to its environment. If false, the tool performs only additive updates. (This property is meaningful only when <code>readOnlyHint == false</code>) Default: true</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations.idempotentHint","title":"idempotentHint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idempotentHint: bool | None = None\n</code></pre> <p>If true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment. (This property is meaningful only when <code>readOnlyHint == false</code>) Default: false</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations.openWorldHint","title":"openWorldHint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>openWorldHint: bool | None = None\n</code></pre> <p>If true, this tool may interact with an \"open world\" of external entities. If false, the tool's domain of interaction is closed. For example, the world of a web search tool is open, whereas that of a memory tool is not. Default: true</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations.readOnlyHint","title":"readOnlyHint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>readOnlyHint: bool | None = None\n</code></pre> <p>If true, the tool does not modify its environment. Default: false</p>"},{"location":"reference/mcp/types/#mcp.types.ToolAnnotations.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None = None\n</code></pre> <p>A human-readable title for the tool.</p>"},{"location":"reference/mcp/types/#mcp.types.ToolListChangedNotification","title":"ToolListChangedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/tools/list_changed']]</code></p> <p>An optional notification from the server to the client, informing it that the list of tools it offers has changed.</p>"},{"location":"reference/mcp/types/#mcp.types.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p>"},{"location":"reference/mcp/types/#mcp.types.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"reference/mcp/types/#mcp.types.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p>"},{"location":"reference/mcp/types/#mcp.types.UnsubscribeRequestParams","title":"UnsubscribeRequestParams","text":"<p>               Bases: <code>RequestParams</code></p> <p>Parameters for unsubscribing from a resource.</p>"},{"location":"reference/mcp/types/#mcp.types.UnsubscribeRequestParams.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of the resource to unsubscribe from.</p>"}]}